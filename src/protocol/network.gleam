//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Network Domain  
////
//// Network domain allows tracking network activities of the page. It exposes information about http,
//// file, data and other requests and responses, their headers, bodies, timing, etc.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Network/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import chrome
import gleam/dict
import gleam/dynamic
import gleam/json
import gleam/list
import gleam/option
import gleam/result
import protocol/debugger
import protocol/runtime
import protocol/security

/// Resource type as it was perceived by the rendering engine.
pub type ResourceType {
  ResourceTypeDocument
  ResourceTypeStylesheet
  ResourceTypeImage
  ResourceTypeMedia
  ResourceTypeFont
  ResourceTypeScript
  ResourceTypeTextTrack
  ResourceTypeXhr
  ResourceTypeFetch
  ResourceTypePrefetch
  ResourceTypeEventSource
  ResourceTypeWebSocket
  ResourceTypeManifest
  ResourceTypeSignedExchange
  ResourceTypePing
  ResourceTypeCspViolationReport
  ResourceTypePreflight
  ResourceTypeOther
}

@internal
pub fn encode__resource_type(value__: ResourceType) {
  case value__ {
    ResourceTypeDocument -> "Document"
    ResourceTypeStylesheet -> "Stylesheet"
    ResourceTypeImage -> "Image"
    ResourceTypeMedia -> "Media"
    ResourceTypeFont -> "Font"
    ResourceTypeScript -> "Script"
    ResourceTypeTextTrack -> "TextTrack"
    ResourceTypeXhr -> "XHR"
    ResourceTypeFetch -> "Fetch"
    ResourceTypePrefetch -> "Prefetch"
    ResourceTypeEventSource -> "EventSource"
    ResourceTypeWebSocket -> "WebSocket"
    ResourceTypeManifest -> "Manifest"
    ResourceTypeSignedExchange -> "SignedExchange"
    ResourceTypePing -> "Ping"
    ResourceTypeCspViolationReport -> "CSPViolationReport"
    ResourceTypePreflight -> "Preflight"
    ResourceTypeOther -> "Other"
  }
  |> json.string()
}

@internal
pub fn decode__resource_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("Document") -> Ok(ResourceTypeDocument)
    Ok("Stylesheet") -> Ok(ResourceTypeStylesheet)
    Ok("Image") -> Ok(ResourceTypeImage)
    Ok("Media") -> Ok(ResourceTypeMedia)
    Ok("Font") -> Ok(ResourceTypeFont)
    Ok("Script") -> Ok(ResourceTypeScript)
    Ok("TextTrack") -> Ok(ResourceTypeTextTrack)
    Ok("XHR") -> Ok(ResourceTypeXhr)
    Ok("Fetch") -> Ok(ResourceTypeFetch)
    Ok("Prefetch") -> Ok(ResourceTypePrefetch)
    Ok("EventSource") -> Ok(ResourceTypeEventSource)
    Ok("WebSocket") -> Ok(ResourceTypeWebSocket)
    Ok("Manifest") -> Ok(ResourceTypeManifest)
    Ok("SignedExchange") -> Ok(ResourceTypeSignedExchange)
    Ok("Ping") -> Ok(ResourceTypePing)
    Ok("CSPViolationReport") -> Ok(ResourceTypeCspViolationReport)
    Ok("Preflight") -> Ok(ResourceTypePreflight)
    Ok("Other") -> Ok(ResourceTypeOther)
    _ -> Error(chrome.ProtocolError)
  }
}

/// Unique loader identifier.
pub type LoaderId {
  LoaderId(String)
}

@internal
pub fn encode__loader_id(value__: LoaderId) {
  case value__ {
    LoaderId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__loader_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(LoaderId, dynamic.string)
  |> result.replace_error(chrome.ProtocolError)
}

/// Unique request identifier.
pub type RequestId {
  RequestId(String)
}

@internal
pub fn encode__request_id(value__: RequestId) {
  case value__ {
    RequestId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__request_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(RequestId, dynamic.string)
  |> result.replace_error(chrome.ProtocolError)
}

/// Unique intercepted request identifier.
pub type InterceptionId {
  InterceptionId(String)
}

@internal
pub fn encode__interception_id(value__: InterceptionId) {
  case value__ {
    InterceptionId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__interception_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(InterceptionId, dynamic.string)
  |> result.replace_error(chrome.ProtocolError)
}

/// Network level fetch failure reason.
pub type ErrorReason {
  ErrorReasonFailed
  ErrorReasonAborted
  ErrorReasonTimedOut
  ErrorReasonAccessDenied
  ErrorReasonConnectionClosed
  ErrorReasonConnectionReset
  ErrorReasonConnectionRefused
  ErrorReasonConnectionAborted
  ErrorReasonConnectionFailed
  ErrorReasonNameNotResolved
  ErrorReasonInternetDisconnected
  ErrorReasonAddressUnreachable
  ErrorReasonBlockedByClient
  ErrorReasonBlockedByResponse
}

@internal
pub fn encode__error_reason(value__: ErrorReason) {
  case value__ {
    ErrorReasonFailed -> "Failed"
    ErrorReasonAborted -> "Aborted"
    ErrorReasonTimedOut -> "TimedOut"
    ErrorReasonAccessDenied -> "AccessDenied"
    ErrorReasonConnectionClosed -> "ConnectionClosed"
    ErrorReasonConnectionReset -> "ConnectionReset"
    ErrorReasonConnectionRefused -> "ConnectionRefused"
    ErrorReasonConnectionAborted -> "ConnectionAborted"
    ErrorReasonConnectionFailed -> "ConnectionFailed"
    ErrorReasonNameNotResolved -> "NameNotResolved"
    ErrorReasonInternetDisconnected -> "InternetDisconnected"
    ErrorReasonAddressUnreachable -> "AddressUnreachable"
    ErrorReasonBlockedByClient -> "BlockedByClient"
    ErrorReasonBlockedByResponse -> "BlockedByResponse"
  }
  |> json.string()
}

@internal
pub fn decode__error_reason(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("Failed") -> Ok(ErrorReasonFailed)
    Ok("Aborted") -> Ok(ErrorReasonAborted)
    Ok("TimedOut") -> Ok(ErrorReasonTimedOut)
    Ok("AccessDenied") -> Ok(ErrorReasonAccessDenied)
    Ok("ConnectionClosed") -> Ok(ErrorReasonConnectionClosed)
    Ok("ConnectionReset") -> Ok(ErrorReasonConnectionReset)
    Ok("ConnectionRefused") -> Ok(ErrorReasonConnectionRefused)
    Ok("ConnectionAborted") -> Ok(ErrorReasonConnectionAborted)
    Ok("ConnectionFailed") -> Ok(ErrorReasonConnectionFailed)
    Ok("NameNotResolved") -> Ok(ErrorReasonNameNotResolved)
    Ok("InternetDisconnected") -> Ok(ErrorReasonInternetDisconnected)
    Ok("AddressUnreachable") -> Ok(ErrorReasonAddressUnreachable)
    Ok("BlockedByClient") -> Ok(ErrorReasonBlockedByClient)
    Ok("BlockedByResponse") -> Ok(ErrorReasonBlockedByResponse)
    _ -> Error(chrome.ProtocolError)
  }
}

/// UTC time in seconds, counted from January 1, 1970.
pub type TimeSinceEpoch {
  TimeSinceEpoch(Float)
}

@internal
pub fn encode__time_since_epoch(value__: TimeSinceEpoch) {
  case value__ {
    TimeSinceEpoch(inner_value__) -> json.float(inner_value__)
  }
}

@internal
pub fn decode__time_since_epoch(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(TimeSinceEpoch, dynamic.float)
  |> result.replace_error(chrome.ProtocolError)
}

/// Monotonically increasing time in seconds since an arbitrary point in the past.
pub type MonotonicTime {
  MonotonicTime(Float)
}

@internal
pub fn encode__monotonic_time(value__: MonotonicTime) {
  case value__ {
    MonotonicTime(inner_value__) -> json.float(inner_value__)
  }
}

@internal
pub fn decode__monotonic_time(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(MonotonicTime, dynamic.float)
  |> result.replace_error(chrome.ProtocolError)
}

/// Request / response headers as keys / values of JSON object.
pub type Headers {
  Headers(dict.Dict(String, String))
}

@internal
pub fn encode__headers(value__: Headers) {
  case value__ {
    Headers(inner_value__) ->
      dict.to_list(inner_value__)
      |> list.map(fn(i) { #(i.0, json.string(i.1)) })
      |> json.object
  }
}

// TODO implement decoder for Dict 
/// The underlying connection technology that the browser is supposedly using.
pub type ConnectionType {
  ConnectionTypeNone
  ConnectionTypeCellular2g
  ConnectionTypeCellular3g
  ConnectionTypeCellular4g
  ConnectionTypeBluetooth
  ConnectionTypeEthernet
  ConnectionTypeWifi
  ConnectionTypeWimax
  ConnectionTypeOther
}

@internal
pub fn encode__connection_type(value__: ConnectionType) {
  case value__ {
    ConnectionTypeNone -> "none"
    ConnectionTypeCellular2g -> "cellular2g"
    ConnectionTypeCellular3g -> "cellular3g"
    ConnectionTypeCellular4g -> "cellular4g"
    ConnectionTypeBluetooth -> "bluetooth"
    ConnectionTypeEthernet -> "ethernet"
    ConnectionTypeWifi -> "wifi"
    ConnectionTypeWimax -> "wimax"
    ConnectionTypeOther -> "other"
  }
  |> json.string()
}

@internal
pub fn decode__connection_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("none") -> Ok(ConnectionTypeNone)
    Ok("cellular2g") -> Ok(ConnectionTypeCellular2g)
    Ok("cellular3g") -> Ok(ConnectionTypeCellular3g)
    Ok("cellular4g") -> Ok(ConnectionTypeCellular4g)
    Ok("bluetooth") -> Ok(ConnectionTypeBluetooth)
    Ok("ethernet") -> Ok(ConnectionTypeEthernet)
    Ok("wifi") -> Ok(ConnectionTypeWifi)
    Ok("wimax") -> Ok(ConnectionTypeWimax)
    Ok("other") -> Ok(ConnectionTypeOther)
    _ -> Error(chrome.ProtocolError)
  }
}

/// Represents the cookie's 'SameSite' status:
/// https://tools.ietf.org/html/draft-west-first-party-cookies
pub type CookieSameSite {
  CookieSameSiteStrict
  CookieSameSiteLax
  CookieSameSiteNone
}

@internal
pub fn encode__cookie_same_site(value__: CookieSameSite) {
  case value__ {
    CookieSameSiteStrict -> "Strict"
    CookieSameSiteLax -> "Lax"
    CookieSameSiteNone -> "None"
  }
  |> json.string()
}

@internal
pub fn decode__cookie_same_site(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("Strict") -> Ok(CookieSameSiteStrict)
    Ok("Lax") -> Ok(CookieSameSiteLax)
    Ok("None") -> Ok(CookieSameSiteNone)
    _ -> Error(chrome.ProtocolError)
  }
}

/// Timing information for the request.
pub type ResourceTiming {
  ResourceTiming(
    request_time: Float,
    proxy_start: Float,
    proxy_end: Float,
    dns_start: Float,
    dns_end: Float,
    connect_start: Float,
    connect_end: Float,
    ssl_start: Float,
    ssl_end: Float,
    send_start: Float,
    send_end: Float,
    receive_headers_end: Float,
  )
}

@internal
pub fn encode__resource_timing(value__: ResourceTiming) {
  json.object([
    #("requestTime", json.float(value__.request_time)),
    #("proxyStart", json.float(value__.proxy_start)),
    #("proxyEnd", json.float(value__.proxy_end)),
    #("dnsStart", json.float(value__.dns_start)),
    #("dnsEnd", json.float(value__.dns_end)),
    #("connectStart", json.float(value__.connect_start)),
    #("connectEnd", json.float(value__.connect_end)),
    #("sslStart", json.float(value__.ssl_start)),
    #("sslEnd", json.float(value__.ssl_end)),
    #("sendStart", json.float(value__.send_start)),
    #("sendEnd", json.float(value__.send_end)),
    #("receiveHeadersEnd", json.float(value__.receive_headers_end)),
  ])
}

// TODO implement decoder for Object with props
/// Loading priority of a resource request.
pub type ResourcePriority {
  ResourcePriorityVeryLow
  ResourcePriorityLow
  ResourcePriorityMedium
  ResourcePriorityHigh
  ResourcePriorityVeryHigh
}

@internal
pub fn encode__resource_priority(value__: ResourcePriority) {
  case value__ {
    ResourcePriorityVeryLow -> "VeryLow"
    ResourcePriorityLow -> "Low"
    ResourcePriorityMedium -> "Medium"
    ResourcePriorityHigh -> "High"
    ResourcePriorityVeryHigh -> "VeryHigh"
  }
  |> json.string()
}

@internal
pub fn decode__resource_priority(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("VeryLow") -> Ok(ResourcePriorityVeryLow)
    Ok("Low") -> Ok(ResourcePriorityLow)
    Ok("Medium") -> Ok(ResourcePriorityMedium)
    Ok("High") -> Ok(ResourcePriorityHigh)
    Ok("VeryHigh") -> Ok(ResourcePriorityVeryHigh)
    _ -> Error(chrome.ProtocolError)
  }
}

/// Post data entry for HTTP request
pub type PostDataEntry {
  PostDataEntry(bytes: option.Option(String))
}

@internal
pub fn encode__post_data_entry(value__: PostDataEntry) {
  json.object([
    #("bytes", {
      case value__.bytes {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
  ])
}

// TODO implement decoder for Object with props
/// HTTP request data.
pub type Request {
  Request(
    url: String,
    url_fragment: option.Option(String),
    method: String,
    headers: Headers,
    has_post_data: option.Option(Bool),
    mixed_content_type: option.Option(security.MixedContentType),
    initial_priority: ResourcePriority,
    referrer_policy: RequestReferrerPolicy,
    is_link_preload: option.Option(Bool),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `referrerPolicy` of `Request`
pub type RequestReferrerPolicy {
  RequestReferrerPolicyUnsafeUrl
  RequestReferrerPolicyNoReferrerWhenDowngrade
  RequestReferrerPolicyNoReferrer
  RequestReferrerPolicyOrigin
  RequestReferrerPolicyOriginWhenCrossOrigin
  RequestReferrerPolicySameOrigin
  RequestReferrerPolicyStrictOrigin
  RequestReferrerPolicyStrictOriginWhenCrossOrigin
}

@internal
pub fn encode__request_referrer_policy(value__: RequestReferrerPolicy) {
  case value__ {
    RequestReferrerPolicyUnsafeUrl -> "unsafe-url"
    RequestReferrerPolicyNoReferrerWhenDowngrade -> "no-referrer-when-downgrade"
    RequestReferrerPolicyNoReferrer -> "no-referrer"
    RequestReferrerPolicyOrigin -> "origin"
    RequestReferrerPolicyOriginWhenCrossOrigin -> "origin-when-cross-origin"
    RequestReferrerPolicySameOrigin -> "same-origin"
    RequestReferrerPolicyStrictOrigin -> "strict-origin"
    RequestReferrerPolicyStrictOriginWhenCrossOrigin ->
      "strict-origin-when-cross-origin"
  }
  |> json.string()
}

@internal
pub fn decode__request_referrer_policy(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("unsafe-url") -> Ok(RequestReferrerPolicyUnsafeUrl)
    Ok("no-referrer-when-downgrade") ->
      Ok(RequestReferrerPolicyNoReferrerWhenDowngrade)
    Ok("no-referrer") -> Ok(RequestReferrerPolicyNoReferrer)
    Ok("origin") -> Ok(RequestReferrerPolicyOrigin)
    Ok("origin-when-cross-origin") ->
      Ok(RequestReferrerPolicyOriginWhenCrossOrigin)
    Ok("same-origin") -> Ok(RequestReferrerPolicySameOrigin)
    Ok("strict-origin") -> Ok(RequestReferrerPolicyStrictOrigin)
    Ok("strict-origin-when-cross-origin") ->
      Ok(RequestReferrerPolicyStrictOriginWhenCrossOrigin)
    _ -> Error(chrome.ProtocolError)
  }
}

@internal
pub fn encode__request(value__: Request) {
  json.object([
    #("url", json.string(value__.url)),
    #("urlFragment", {
      case value__.url_fragment {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("method", json.string(value__.method)),
    #("headers", encode__headers(value__.headers)),
    #("hasPostData", {
      case value__.has_post_data {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
    #("mixedContentType", {
      case value__.mixed_content_type {
        option.Some(value__) -> security.encode__mixed_content_type(value__)
        option.None -> json.null()
      }
    }),
    #("initialPriority", encode__resource_priority(value__.initial_priority)),
    #(
      "referrerPolicy",
      encode__request_referrer_policy(value__.referrer_policy),
    ),
    #("isLinkPreload", {
      case value__.is_link_preload {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
  ])
}

// TODO implement decoder for Object with props
/// Details of a signed certificate timestamp (SCT).
pub type SignedCertificateTimestamp {
  SignedCertificateTimestamp(
    status: String,
    origin: String,
    log_description: String,
    log_id: String,
    timestamp: Float,
    hash_algorithm: String,
    signature_algorithm: String,
    signature_data: String,
  )
}

@internal
pub fn encode__signed_certificate_timestamp(value__: SignedCertificateTimestamp) {
  json.object([
    #("status", json.string(value__.status)),
    #("origin", json.string(value__.origin)),
    #("logDescription", json.string(value__.log_description)),
    #("logId", json.string(value__.log_id)),
    #("timestamp", json.float(value__.timestamp)),
    #("hashAlgorithm", json.string(value__.hash_algorithm)),
    #("signatureAlgorithm", json.string(value__.signature_algorithm)),
    #("signatureData", json.string(value__.signature_data)),
  ])
}

// TODO implement decoder for Object with props
/// Security details about a request.
pub type SecurityDetails {
  SecurityDetails(
    protocol: String,
    key_exchange: String,
    key_exchange_group: option.Option(String),
    cipher: String,
    mac: option.Option(String),
    certificate_id: security.CertificateId,
    subject_name: String,
    san_list: List(String),
    issuer: String,
    valid_from: TimeSinceEpoch,
    valid_to: TimeSinceEpoch,
    signed_certificate_timestamp_list: List(SignedCertificateTimestamp),
    certificate_transparency_compliance: CertificateTransparencyCompliance,
    server_signature_algorithm: option.Option(Int),
    encrypted_client_hello: Bool,
  )
}

@internal
pub fn encode__security_details(value__: SecurityDetails) {
  json.object([
    #("protocol", json.string(value__.protocol)),
    #("keyExchange", json.string(value__.key_exchange)),
    #("keyExchangeGroup", {
      case value__.key_exchange_group {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("cipher", json.string(value__.cipher)),
    #("mac", {
      case value__.mac {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("certificateId", security.encode__certificate_id(value__.certificate_id)),
    #("subjectName", json.string(value__.subject_name)),
    #("sanList", json.array(value__.san_list, of: json.string)),
    #("issuer", json.string(value__.issuer)),
    #("validFrom", encode__time_since_epoch(value__.valid_from)),
    #("validTo", encode__time_since_epoch(value__.valid_to)),
    #(
      "signedCertificateTimestampList",
      json.array(
        value__.signed_certificate_timestamp_list,
        of: encode__signed_certificate_timestamp,
      ),
    ),
    #(
      "certificateTransparencyCompliance",
      encode__certificate_transparency_compliance(
        value__.certificate_transparency_compliance,
      ),
    ),
    #("serverSignatureAlgorithm", {
      case value__.server_signature_algorithm {
        option.Some(value__) -> json.int(value__)
        option.None -> json.null()
      }
    }),
    #("encryptedClientHello", json.bool(value__.encrypted_client_hello)),
  ])
}

// TODO implement decoder for Object with props
/// Whether the request complied with Certificate Transparency policy.
pub type CertificateTransparencyCompliance {
  CertificateTransparencyComplianceUnknown
  CertificateTransparencyComplianceNotCompliant
  CertificateTransparencyComplianceCompliant
}

@internal
pub fn encode__certificate_transparency_compliance(value__: CertificateTransparencyCompliance) {
  case value__ {
    CertificateTransparencyComplianceUnknown -> "unknown"
    CertificateTransparencyComplianceNotCompliant -> "not-compliant"
    CertificateTransparencyComplianceCompliant -> "compliant"
  }
  |> json.string()
}

@internal
pub fn decode__certificate_transparency_compliance(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("unknown") -> Ok(CertificateTransparencyComplianceUnknown)
    Ok("not-compliant") -> Ok(CertificateTransparencyComplianceNotCompliant)
    Ok("compliant") -> Ok(CertificateTransparencyComplianceCompliant)
    _ -> Error(chrome.ProtocolError)
  }
}

/// The reason why request was blocked.
pub type BlockedReason {
  BlockedReasonOther
  BlockedReasonCsp
  BlockedReasonMixedContent
  BlockedReasonOrigin
  BlockedReasonInspector
  BlockedReasonSubresourceFilter
  BlockedReasonContentType
  BlockedReasonCoepFrameResourceNeedsCoepHeader
  BlockedReasonCoopSandboxedIframeCannotNavigateToCoopPage
  BlockedReasonCorpNotSameOrigin
  BlockedReasonCorpNotSameOriginAfterDefaultedToSameOriginByCoep
  BlockedReasonCorpNotSameSite
}

@internal
pub fn encode__blocked_reason(value__: BlockedReason) {
  case value__ {
    BlockedReasonOther -> "other"
    BlockedReasonCsp -> "csp"
    BlockedReasonMixedContent -> "mixed-content"
    BlockedReasonOrigin -> "origin"
    BlockedReasonInspector -> "inspector"
    BlockedReasonSubresourceFilter -> "subresource-filter"
    BlockedReasonContentType -> "content-type"
    BlockedReasonCoepFrameResourceNeedsCoepHeader ->
      "coep-frame-resource-needs-coep-header"
    BlockedReasonCoopSandboxedIframeCannotNavigateToCoopPage ->
      "coop-sandboxed-iframe-cannot-navigate-to-coop-page"
    BlockedReasonCorpNotSameOrigin -> "corp-not-same-origin"
    BlockedReasonCorpNotSameOriginAfterDefaultedToSameOriginByCoep ->
      "corp-not-same-origin-after-defaulted-to-same-origin-by-coep"
    BlockedReasonCorpNotSameSite -> "corp-not-same-site"
  }
  |> json.string()
}

@internal
pub fn decode__blocked_reason(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("other") -> Ok(BlockedReasonOther)
    Ok("csp") -> Ok(BlockedReasonCsp)
    Ok("mixed-content") -> Ok(BlockedReasonMixedContent)
    Ok("origin") -> Ok(BlockedReasonOrigin)
    Ok("inspector") -> Ok(BlockedReasonInspector)
    Ok("subresource-filter") -> Ok(BlockedReasonSubresourceFilter)
    Ok("content-type") -> Ok(BlockedReasonContentType)
    Ok("coep-frame-resource-needs-coep-header") ->
      Ok(BlockedReasonCoepFrameResourceNeedsCoepHeader)
    Ok("coop-sandboxed-iframe-cannot-navigate-to-coop-page") ->
      Ok(BlockedReasonCoopSandboxedIframeCannotNavigateToCoopPage)
    Ok("corp-not-same-origin") -> Ok(BlockedReasonCorpNotSameOrigin)
    Ok("corp-not-same-origin-after-defaulted-to-same-origin-by-coep") ->
      Ok(BlockedReasonCorpNotSameOriginAfterDefaultedToSameOriginByCoep)
    Ok("corp-not-same-site") -> Ok(BlockedReasonCorpNotSameSite)
    _ -> Error(chrome.ProtocolError)
  }
}

/// The reason why request was blocked.
pub type CorsError {
  CorsErrorDisallowedByMode
  CorsErrorInvalidResponse
  CorsErrorWildcardOriginNotAllowed
  CorsErrorMissingAllowOriginHeader
  CorsErrorMultipleAllowOriginValues
  CorsErrorInvalidAllowOriginValue
  CorsErrorAllowOriginMismatch
  CorsErrorInvalidAllowCredentials
  CorsErrorCorsDisabledScheme
  CorsErrorPreflightInvalidStatus
  CorsErrorPreflightDisallowedRedirect
  CorsErrorPreflightWildcardOriginNotAllowed
  CorsErrorPreflightMissingAllowOriginHeader
  CorsErrorPreflightMultipleAllowOriginValues
  CorsErrorPreflightInvalidAllowOriginValue
  CorsErrorPreflightAllowOriginMismatch
  CorsErrorPreflightInvalidAllowCredentials
  CorsErrorPreflightMissingAllowExternal
  CorsErrorPreflightInvalidAllowExternal
  CorsErrorPreflightMissingAllowPrivateNetwork
  CorsErrorPreflightInvalidAllowPrivateNetwork
  CorsErrorInvalidAllowMethodsPreflightResponse
  CorsErrorInvalidAllowHeadersPreflightResponse
  CorsErrorMethodDisallowedByPreflightResponse
  CorsErrorHeaderDisallowedByPreflightResponse
  CorsErrorRedirectContainsCredentials
  CorsErrorInsecurePrivateNetwork
  CorsErrorInvalidPrivateNetworkAccess
  CorsErrorUnexpectedPrivateNetworkAccess
  CorsErrorNoCorsRedirectModeNotFollow
  CorsErrorPreflightMissingPrivateNetworkAccessId
  CorsErrorPreflightMissingPrivateNetworkAccessName
  CorsErrorPrivateNetworkAccessPermissionUnavailable
  CorsErrorPrivateNetworkAccessPermissionDenied
}

@internal
pub fn encode__cors_error(value__: CorsError) {
  case value__ {
    CorsErrorDisallowedByMode -> "DisallowedByMode"
    CorsErrorInvalidResponse -> "InvalidResponse"
    CorsErrorWildcardOriginNotAllowed -> "WildcardOriginNotAllowed"
    CorsErrorMissingAllowOriginHeader -> "MissingAllowOriginHeader"
    CorsErrorMultipleAllowOriginValues -> "MultipleAllowOriginValues"
    CorsErrorInvalidAllowOriginValue -> "InvalidAllowOriginValue"
    CorsErrorAllowOriginMismatch -> "AllowOriginMismatch"
    CorsErrorInvalidAllowCredentials -> "InvalidAllowCredentials"
    CorsErrorCorsDisabledScheme -> "CorsDisabledScheme"
    CorsErrorPreflightInvalidStatus -> "PreflightInvalidStatus"
    CorsErrorPreflightDisallowedRedirect -> "PreflightDisallowedRedirect"
    CorsErrorPreflightWildcardOriginNotAllowed ->
      "PreflightWildcardOriginNotAllowed"
    CorsErrorPreflightMissingAllowOriginHeader ->
      "PreflightMissingAllowOriginHeader"
    CorsErrorPreflightMultipleAllowOriginValues ->
      "PreflightMultipleAllowOriginValues"
    CorsErrorPreflightInvalidAllowOriginValue ->
      "PreflightInvalidAllowOriginValue"
    CorsErrorPreflightAllowOriginMismatch -> "PreflightAllowOriginMismatch"
    CorsErrorPreflightInvalidAllowCredentials ->
      "PreflightInvalidAllowCredentials"
    CorsErrorPreflightMissingAllowExternal -> "PreflightMissingAllowExternal"
    CorsErrorPreflightInvalidAllowExternal -> "PreflightInvalidAllowExternal"
    CorsErrorPreflightMissingAllowPrivateNetwork ->
      "PreflightMissingAllowPrivateNetwork"
    CorsErrorPreflightInvalidAllowPrivateNetwork ->
      "PreflightInvalidAllowPrivateNetwork"
    CorsErrorInvalidAllowMethodsPreflightResponse ->
      "InvalidAllowMethodsPreflightResponse"
    CorsErrorInvalidAllowHeadersPreflightResponse ->
      "InvalidAllowHeadersPreflightResponse"
    CorsErrorMethodDisallowedByPreflightResponse ->
      "MethodDisallowedByPreflightResponse"
    CorsErrorHeaderDisallowedByPreflightResponse ->
      "HeaderDisallowedByPreflightResponse"
    CorsErrorRedirectContainsCredentials -> "RedirectContainsCredentials"
    CorsErrorInsecurePrivateNetwork -> "InsecurePrivateNetwork"
    CorsErrorInvalidPrivateNetworkAccess -> "InvalidPrivateNetworkAccess"
    CorsErrorUnexpectedPrivateNetworkAccess -> "UnexpectedPrivateNetworkAccess"
    CorsErrorNoCorsRedirectModeNotFollow -> "NoCorsRedirectModeNotFollow"
    CorsErrorPreflightMissingPrivateNetworkAccessId ->
      "PreflightMissingPrivateNetworkAccessId"
    CorsErrorPreflightMissingPrivateNetworkAccessName ->
      "PreflightMissingPrivateNetworkAccessName"
    CorsErrorPrivateNetworkAccessPermissionUnavailable ->
      "PrivateNetworkAccessPermissionUnavailable"
    CorsErrorPrivateNetworkAccessPermissionDenied ->
      "PrivateNetworkAccessPermissionDenied"
  }
  |> json.string()
}

@internal
pub fn decode__cors_error(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("DisallowedByMode") -> Ok(CorsErrorDisallowedByMode)
    Ok("InvalidResponse") -> Ok(CorsErrorInvalidResponse)
    Ok("WildcardOriginNotAllowed") -> Ok(CorsErrorWildcardOriginNotAllowed)
    Ok("MissingAllowOriginHeader") -> Ok(CorsErrorMissingAllowOriginHeader)
    Ok("MultipleAllowOriginValues") -> Ok(CorsErrorMultipleAllowOriginValues)
    Ok("InvalidAllowOriginValue") -> Ok(CorsErrorInvalidAllowOriginValue)
    Ok("AllowOriginMismatch") -> Ok(CorsErrorAllowOriginMismatch)
    Ok("InvalidAllowCredentials") -> Ok(CorsErrorInvalidAllowCredentials)
    Ok("CorsDisabledScheme") -> Ok(CorsErrorCorsDisabledScheme)
    Ok("PreflightInvalidStatus") -> Ok(CorsErrorPreflightInvalidStatus)
    Ok("PreflightDisallowedRedirect") ->
      Ok(CorsErrorPreflightDisallowedRedirect)
    Ok("PreflightWildcardOriginNotAllowed") ->
      Ok(CorsErrorPreflightWildcardOriginNotAllowed)
    Ok("PreflightMissingAllowOriginHeader") ->
      Ok(CorsErrorPreflightMissingAllowOriginHeader)
    Ok("PreflightMultipleAllowOriginValues") ->
      Ok(CorsErrorPreflightMultipleAllowOriginValues)
    Ok("PreflightInvalidAllowOriginValue") ->
      Ok(CorsErrorPreflightInvalidAllowOriginValue)
    Ok("PreflightAllowOriginMismatch") ->
      Ok(CorsErrorPreflightAllowOriginMismatch)
    Ok("PreflightInvalidAllowCredentials") ->
      Ok(CorsErrorPreflightInvalidAllowCredentials)
    Ok("PreflightMissingAllowExternal") ->
      Ok(CorsErrorPreflightMissingAllowExternal)
    Ok("PreflightInvalidAllowExternal") ->
      Ok(CorsErrorPreflightInvalidAllowExternal)
    Ok("PreflightMissingAllowPrivateNetwork") ->
      Ok(CorsErrorPreflightMissingAllowPrivateNetwork)
    Ok("PreflightInvalidAllowPrivateNetwork") ->
      Ok(CorsErrorPreflightInvalidAllowPrivateNetwork)
    Ok("InvalidAllowMethodsPreflightResponse") ->
      Ok(CorsErrorInvalidAllowMethodsPreflightResponse)
    Ok("InvalidAllowHeadersPreflightResponse") ->
      Ok(CorsErrorInvalidAllowHeadersPreflightResponse)
    Ok("MethodDisallowedByPreflightResponse") ->
      Ok(CorsErrorMethodDisallowedByPreflightResponse)
    Ok("HeaderDisallowedByPreflightResponse") ->
      Ok(CorsErrorHeaderDisallowedByPreflightResponse)
    Ok("RedirectContainsCredentials") ->
      Ok(CorsErrorRedirectContainsCredentials)
    Ok("InsecurePrivateNetwork") -> Ok(CorsErrorInsecurePrivateNetwork)
    Ok("InvalidPrivateNetworkAccess") ->
      Ok(CorsErrorInvalidPrivateNetworkAccess)
    Ok("UnexpectedPrivateNetworkAccess") ->
      Ok(CorsErrorUnexpectedPrivateNetworkAccess)
    Ok("NoCorsRedirectModeNotFollow") ->
      Ok(CorsErrorNoCorsRedirectModeNotFollow)
    Ok("PreflightMissingPrivateNetworkAccessId") ->
      Ok(CorsErrorPreflightMissingPrivateNetworkAccessId)
    Ok("PreflightMissingPrivateNetworkAccessName") ->
      Ok(CorsErrorPreflightMissingPrivateNetworkAccessName)
    Ok("PrivateNetworkAccessPermissionUnavailable") ->
      Ok(CorsErrorPrivateNetworkAccessPermissionUnavailable)
    Ok("PrivateNetworkAccessPermissionDenied") ->
      Ok(CorsErrorPrivateNetworkAccessPermissionDenied)
    _ -> Error(chrome.ProtocolError)
  }
}

pub type CorsErrorStatus {
  CorsErrorStatus(cors_error: CorsError, failed_parameter: String)
}

@internal
pub fn encode__cors_error_status(value__: CorsErrorStatus) {
  json.object([
    #("corsError", encode__cors_error(value__.cors_error)),
    #("failedParameter", json.string(value__.failed_parameter)),
  ])
}

// TODO implement decoder for Object with props
/// Source of serviceworker response.
pub type ServiceWorkerResponseSource {
  ServiceWorkerResponseSourceCacheStorage
  ServiceWorkerResponseSourceHttpCache
  ServiceWorkerResponseSourceFallbackCode
  ServiceWorkerResponseSourceNetwork
}

@internal
pub fn encode__service_worker_response_source(value__: ServiceWorkerResponseSource) {
  case value__ {
    ServiceWorkerResponseSourceCacheStorage -> "cache-storage"
    ServiceWorkerResponseSourceHttpCache -> "http-cache"
    ServiceWorkerResponseSourceFallbackCode -> "fallback-code"
    ServiceWorkerResponseSourceNetwork -> "network"
  }
  |> json.string()
}

@internal
pub fn decode__service_worker_response_source(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("cache-storage") -> Ok(ServiceWorkerResponseSourceCacheStorage)
    Ok("http-cache") -> Ok(ServiceWorkerResponseSourceHttpCache)
    Ok("fallback-code") -> Ok(ServiceWorkerResponseSourceFallbackCode)
    Ok("network") -> Ok(ServiceWorkerResponseSourceNetwork)
    _ -> Error(chrome.ProtocolError)
  }
}

/// Source of service worker router.
pub type ServiceWorkerRouterSource {
  ServiceWorkerRouterSourceNetwork
  ServiceWorkerRouterSourceCache
  ServiceWorkerRouterSourceFetchEvent
  ServiceWorkerRouterSourceRaceNetworkAndFetchHandler
}

@internal
pub fn encode__service_worker_router_source(value__: ServiceWorkerRouterSource) {
  case value__ {
    ServiceWorkerRouterSourceNetwork -> "network"
    ServiceWorkerRouterSourceCache -> "cache"
    ServiceWorkerRouterSourceFetchEvent -> "fetch-event"
    ServiceWorkerRouterSourceRaceNetworkAndFetchHandler ->
      "race-network-and-fetch-handler"
  }
  |> json.string()
}

@internal
pub fn decode__service_worker_router_source(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("network") -> Ok(ServiceWorkerRouterSourceNetwork)
    Ok("cache") -> Ok(ServiceWorkerRouterSourceCache)
    Ok("fetch-event") -> Ok(ServiceWorkerRouterSourceFetchEvent)
    Ok("race-network-and-fetch-handler") ->
      Ok(ServiceWorkerRouterSourceRaceNetworkAndFetchHandler)
    _ -> Error(chrome.ProtocolError)
  }
}

/// HTTP response data.
pub type Response {
  Response(
    url: String,
    status: Int,
    status_text: String,
    headers: Headers,
    mime_type: String,
    charset: String,
    request_headers: option.Option(Headers),
    connection_reused: Bool,
    connection_id: Float,
    remote_ip_address: option.Option(String),
    remote_port: option.Option(Int),
    from_disk_cache: option.Option(Bool),
    from_service_worker: option.Option(Bool),
    from_prefetch_cache: option.Option(Bool),
    from_early_hints: option.Option(Bool),
    encoded_data_length: Float,
    timing: option.Option(ResourceTiming),
    service_worker_response_source: option.Option(ServiceWorkerResponseSource),
    response_time: option.Option(TimeSinceEpoch),
    cache_storage_cache_name: option.Option(String),
    protocol: option.Option(String),
    security_state: security.SecurityState,
    security_details: option.Option(SecurityDetails),
  )
}

@internal
pub fn encode__response(value__: Response) {
  json.object([
    #("url", json.string(value__.url)),
    #("status", json.int(value__.status)),
    #("statusText", json.string(value__.status_text)),
    #("headers", encode__headers(value__.headers)),
    #("mimeType", json.string(value__.mime_type)),
    #("charset", json.string(value__.charset)),
    #("requestHeaders", {
      case value__.request_headers {
        option.Some(value__) -> encode__headers(value__)
        option.None -> json.null()
      }
    }),
    #("connectionReused", json.bool(value__.connection_reused)),
    #("connectionId", json.float(value__.connection_id)),
    #("remoteIPAddress", {
      case value__.remote_ip_address {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("remotePort", {
      case value__.remote_port {
        option.Some(value__) -> json.int(value__)
        option.None -> json.null()
      }
    }),
    #("fromDiskCache", {
      case value__.from_disk_cache {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
    #("fromServiceWorker", {
      case value__.from_service_worker {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
    #("fromPrefetchCache", {
      case value__.from_prefetch_cache {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
    #("fromEarlyHints", {
      case value__.from_early_hints {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
    #("encodedDataLength", json.float(value__.encoded_data_length)),
    #("timing", {
      case value__.timing {
        option.Some(value__) -> encode__resource_timing(value__)
        option.None -> json.null()
      }
    }),
    #("serviceWorkerResponseSource", {
      case value__.service_worker_response_source {
        option.Some(value__) -> encode__service_worker_response_source(value__)
        option.None -> json.null()
      }
    }),
    #("responseTime", {
      case value__.response_time {
        option.Some(value__) -> encode__time_since_epoch(value__)
        option.None -> json.null()
      }
    }),
    #("cacheStorageCacheName", {
      case value__.cache_storage_cache_name {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("protocol", {
      case value__.protocol {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("securityState", security.encode__security_state(value__.security_state)),
    #("securityDetails", {
      case value__.security_details {
        option.Some(value__) -> encode__security_details(value__)
        option.None -> json.null()
      }
    }),
  ])
}

// TODO implement decoder for Object with props
/// WebSocket request data.
pub type WebSocketRequest {
  WebSocketRequest(headers: Headers)
}

@internal
pub fn encode__web_socket_request(value__: WebSocketRequest) {
  json.object([#("headers", encode__headers(value__.headers))])
}

// TODO implement decoder for Object with props
/// WebSocket response data.
pub type WebSocketResponse {
  WebSocketResponse(
    status: Int,
    status_text: String,
    headers: Headers,
    headers_text: option.Option(String),
    request_headers: option.Option(Headers),
    request_headers_text: option.Option(String),
  )
}

@internal
pub fn encode__web_socket_response(value__: WebSocketResponse) {
  json.object([
    #("status", json.int(value__.status)),
    #("statusText", json.string(value__.status_text)),
    #("headers", encode__headers(value__.headers)),
    #("headersText", {
      case value__.headers_text {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("requestHeaders", {
      case value__.request_headers {
        option.Some(value__) -> encode__headers(value__)
        option.None -> json.null()
      }
    }),
    #("requestHeadersText", {
      case value__.request_headers_text {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
  ])
}

// TODO implement decoder for Object with props
/// WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
pub type WebSocketFrame {
  WebSocketFrame(opcode: Float, mask: Bool, payload_data: String)
}

@internal
pub fn encode__web_socket_frame(value__: WebSocketFrame) {
  json.object([
    #("opcode", json.float(value__.opcode)),
    #("mask", json.bool(value__.mask)),
    #("payloadData", json.string(value__.payload_data)),
  ])
}

// TODO implement decoder for Object with props
/// Information about the cached resource.
pub type CachedResource {
  CachedResource(
    url: String,
    type_: ResourceType,
    response: option.Option(Response),
    body_size: Float,
  )
}

@internal
pub fn encode__cached_resource(value__: CachedResource) {
  json.object([
    #("url", json.string(value__.url)),
    #("type", encode__resource_type(value__.type_)),
    #("response", {
      case value__.response {
        option.Some(value__) -> encode__response(value__)
        option.None -> json.null()
      }
    }),
    #("bodySize", json.float(value__.body_size)),
  ])
}

// TODO implement decoder for Object with props
/// Information about the request initiator.
pub type Initiator {
  Initiator(
    type_: InitiatorType,
    stack: option.Option(runtime.StackTrace),
    url: option.Option(String),
    line_number: option.Option(Float),
    column_number: option.Option(Float),
    request_id: option.Option(RequestId),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `Initiator`
pub type InitiatorType {
  InitiatorTypeParser
  InitiatorTypeScript
  InitiatorTypePreload
  InitiatorTypeSignedExchange
  InitiatorTypePreflight
  InitiatorTypeOther
}

@internal
pub fn encode__initiator_type(value__: InitiatorType) {
  case value__ {
    InitiatorTypeParser -> "parser"
    InitiatorTypeScript -> "script"
    InitiatorTypePreload -> "preload"
    InitiatorTypeSignedExchange -> "SignedExchange"
    InitiatorTypePreflight -> "preflight"
    InitiatorTypeOther -> "other"
  }
  |> json.string()
}

@internal
pub fn decode__initiator_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("parser") -> Ok(InitiatorTypeParser)
    Ok("script") -> Ok(InitiatorTypeScript)
    Ok("preload") -> Ok(InitiatorTypePreload)
    Ok("SignedExchange") -> Ok(InitiatorTypeSignedExchange)
    Ok("preflight") -> Ok(InitiatorTypePreflight)
    Ok("other") -> Ok(InitiatorTypeOther)
    _ -> Error(chrome.ProtocolError)
  }
}

@internal
pub fn encode__initiator(value__: Initiator) {
  json.object([
    #("type", encode__initiator_type(value__.type_)),
    #("stack", {
      case value__.stack {
        option.Some(value__) -> runtime.encode__stack_trace(value__)
        option.None -> json.null()
      }
    }),
    #("url", {
      case value__.url {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("lineNumber", {
      case value__.line_number {
        option.Some(value__) -> json.float(value__)
        option.None -> json.null()
      }
    }),
    #("columnNumber", {
      case value__.column_number {
        option.Some(value__) -> json.float(value__)
        option.None -> json.null()
      }
    }),
    #("requestId", {
      case value__.request_id {
        option.Some(value__) -> encode__request_id(value__)
        option.None -> json.null()
      }
    }),
  ])
}

// TODO implement decoder for Object with props
/// Cookie object
pub type Cookie {
  Cookie(
    name: String,
    value: String,
    domain: String,
    path: String,
    expires: Float,
    size: Int,
    http_only: Bool,
    secure: Bool,
    session: Bool,
    same_site: option.Option(CookieSameSite),
  )
}

@internal
pub fn encode__cookie(value__: Cookie) {
  json.object([
    #("name", json.string(value__.name)),
    #("value", json.string(value__.value)),
    #("domain", json.string(value__.domain)),
    #("path", json.string(value__.path)),
    #("expires", json.float(value__.expires)),
    #("size", json.int(value__.size)),
    #("httpOnly", json.bool(value__.http_only)),
    #("secure", json.bool(value__.secure)),
    #("session", json.bool(value__.session)),
    #("sameSite", {
      case value__.same_site {
        option.Some(value__) -> encode__cookie_same_site(value__)
        option.None -> json.null()
      }
    }),
  ])
}

// TODO implement decoder for Object with props
/// Cookie parameter object
pub type CookieParam {
  CookieParam(
    name: String,
    value: String,
    url: option.Option(String),
    domain: option.Option(String),
    path: option.Option(String),
    secure: option.Option(Bool),
    http_only: option.Option(Bool),
    same_site: option.Option(CookieSameSite),
    expires: option.Option(TimeSinceEpoch),
  )
}

@internal
pub fn encode__cookie_param(value__: CookieParam) {
  json.object([
    #("name", json.string(value__.name)),
    #("value", json.string(value__.value)),
    #("url", {
      case value__.url {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("domain", {
      case value__.domain {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("path", {
      case value__.path {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("secure", {
      case value__.secure {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
    #("httpOnly", {
      case value__.http_only {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
    #("sameSite", {
      case value__.same_site {
        option.Some(value__) -> encode__cookie_same_site(value__)
        option.None -> json.null()
      }
    }),
    #("expires", {
      case value__.expires {
        option.Some(value__) -> encode__time_since_epoch(value__)
        option.None -> json.null()
      }
    }),
  ])
}
// TODO implement decoder for Object with props
