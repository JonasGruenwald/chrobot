//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Debugger Domain  
////
//// Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
//// breakpoints, stepping through execution, exploring stack traces, etc.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Debugger/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import chrobot/internal/utils
import chrome
import gleam/dynamic
import gleam/json
import gleam/option
import gleam/result
import protocol/runtime

/// Breakpoint identifier.
pub type BreakpointId {
  BreakpointId(String)
}

@internal
pub fn encode__breakpoint_id(value__: BreakpointId) {
  case value__ {
    BreakpointId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__breakpoint_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(BreakpointId, dynamic.string)
}

/// Call frame identifier.
pub type CallFrameId {
  CallFrameId(String)
}

@internal
pub fn encode__call_frame_id(value__: CallFrameId) {
  case value__ {
    CallFrameId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__call_frame_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(CallFrameId, dynamic.string)
}

/// Location in the source code.
pub type Location {
  Location(
    script_id: runtime.ScriptId,
    line_number: Int,
    column_number: option.Option(Int),
  )
}

@internal
pub fn encode__location(value__: Location) {
  json.object(
    [
      #("scriptId", runtime.encode__script_id(value__.script_id)),
      #("lineNumber", json.int(value__.line_number)),
    ]
    |> utils.add_optional(value__.column_number, fn(inner_value__) {
      #("columnNumber", json.int(inner_value__))
    }),
  )
}

@internal
pub fn decode__location(value__: dynamic.Dynamic) {
  use script_id <- result.try(dynamic.field(
    "scriptId",
    runtime.decode__script_id,
  )(value__))
  use line_number <- result.try(dynamic.field("lineNumber", dynamic.int)(
    value__,
  ))
  use column_number <- result.try(dynamic.optional_field(
    "columnNumber",
    dynamic.int,
  )(value__))

  Ok(Location(
    script_id: script_id,
    line_number: line_number,
    column_number: column_number,
  ))
}

/// JavaScript call frame. Array of call frames form the call stack.
pub type CallFrame {
  CallFrame(
    call_frame_id: CallFrameId,
    function_name: String,
    function_location: option.Option(Location),
    location: Location,
    scope_chain: List(Scope),
    this: runtime.RemoteObject,
    return_value: option.Option(runtime.RemoteObject),
  )
}

@internal
pub fn encode__call_frame(value__: CallFrame) {
  json.object(
    [
      #("callFrameId", encode__call_frame_id(value__.call_frame_id)),
      #("functionName", json.string(value__.function_name)),
      #("location", encode__location(value__.location)),
      #("scopeChain", json.array(value__.scope_chain, of: encode__scope)),
      #("this", runtime.encode__remote_object(value__.this)),
    ]
    |> utils.add_optional(value__.function_location, fn(inner_value__) {
      #("functionLocation", encode__location(inner_value__))
    })
    |> utils.add_optional(value__.return_value, fn(inner_value__) {
      #("returnValue", runtime.encode__remote_object(inner_value__))
    }),
  )
}

@internal
pub fn decode__call_frame(value__: dynamic.Dynamic) {
  use call_frame_id <- result.try(dynamic.field(
    "callFrameId",
    decode__call_frame_id,
  )(value__))
  use function_name <- result.try(dynamic.field("functionName", dynamic.string)(
    value__,
  ))
  use function_location <- result.try(dynamic.optional_field(
    "functionLocation",
    decode__location,
  )(value__))
  use location <- result.try(dynamic.field("location", decode__location)(
    value__,
  ))
  use scope_chain <- result.try(dynamic.field(
    "scopeChain",
    dynamic.list(decode__scope),
  )(value__))
  use this <- result.try(dynamic.field("this", runtime.decode__remote_object)(
    value__,
  ))
  use return_value <- result.try(dynamic.optional_field(
    "returnValue",
    runtime.decode__remote_object,
  )(value__))

  Ok(CallFrame(
    call_frame_id: call_frame_id,
    function_name: function_name,
    function_location: function_location,
    location: location,
    scope_chain: scope_chain,
    this: this,
    return_value: return_value,
  ))
}

/// Scope description.
pub type Scope {
  Scope(
    type_: ScopeType,
    object: runtime.RemoteObject,
    name: option.Option(String),
    start_location: option.Option(Location),
    end_location: option.Option(Location),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `Scope`
pub type ScopeType {
  ScopeTypeGlobal
  ScopeTypeLocal
  ScopeTypeWith
  ScopeTypeClosure
  ScopeTypeCatch
  ScopeTypeBlock
  ScopeTypeScript
  ScopeTypeEval
  ScopeTypeModule
  ScopeTypeWasmExpressionStack
}

@internal
pub fn encode__scope_type(value__: ScopeType) {
  case value__ {
    ScopeTypeGlobal -> "global"
    ScopeTypeLocal -> "local"
    ScopeTypeWith -> "with"
    ScopeTypeClosure -> "closure"
    ScopeTypeCatch -> "catch"
    ScopeTypeBlock -> "block"
    ScopeTypeScript -> "script"
    ScopeTypeEval -> "eval"
    ScopeTypeModule -> "module"
    ScopeTypeWasmExpressionStack -> "wasm-expression-stack"
  }
  |> json.string()
}

@internal
pub fn decode__scope_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("global") -> Ok(ScopeTypeGlobal)
    Ok("local") -> Ok(ScopeTypeLocal)
    Ok("with") -> Ok(ScopeTypeWith)
    Ok("closure") -> Ok(ScopeTypeClosure)
    Ok("catch") -> Ok(ScopeTypeCatch)
    Ok("block") -> Ok(ScopeTypeBlock)
    Ok("script") -> Ok(ScopeTypeScript)
    Ok("eval") -> Ok(ScopeTypeEval)
    Ok("module") -> Ok(ScopeTypeModule)
    Ok("wasm-expression-stack") -> Ok(ScopeTypeWasmExpressionStack)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

@internal
pub fn encode__scope(value__: Scope) {
  json.object(
    [
      #("type", encode__scope_type(value__.type_)),
      #("object", runtime.encode__remote_object(value__.object)),
    ]
    |> utils.add_optional(value__.name, fn(inner_value__) {
      #("name", json.string(inner_value__))
    })
    |> utils.add_optional(value__.start_location, fn(inner_value__) {
      #("startLocation", encode__location(inner_value__))
    })
    |> utils.add_optional(value__.end_location, fn(inner_value__) {
      #("endLocation", encode__location(inner_value__))
    }),
  )
}

@internal
pub fn decode__scope(value__: dynamic.Dynamic) {
  use type_ <- result.try(dynamic.field("type", decode__scope_type)(value__))
  use object <- result.try(dynamic.field(
    "object",
    runtime.decode__remote_object,
  )(value__))
  use name <- result.try(dynamic.optional_field("name", dynamic.string)(value__))
  use start_location <- result.try(dynamic.optional_field(
    "startLocation",
    decode__location,
  )(value__))
  use end_location <- result.try(dynamic.optional_field(
    "endLocation",
    decode__location,
  )(value__))

  Ok(Scope(
    type_: type_,
    object: object,
    name: name,
    start_location: start_location,
    end_location: end_location,
  ))
}

/// Search match for resource.
pub type SearchMatch {
  SearchMatch(line_number: Float, line_content: String)
}

@internal
pub fn encode__search_match(value__: SearchMatch) {
  json.object([
    #("lineNumber", json.float(value__.line_number)),
    #("lineContent", json.string(value__.line_content)),
  ])
}

@internal
pub fn decode__search_match(value__: dynamic.Dynamic) {
  use line_number <- result.try(dynamic.field("lineNumber", dynamic.float)(
    value__,
  ))
  use line_content <- result.try(dynamic.field("lineContent", dynamic.string)(
    value__,
  ))

  Ok(SearchMatch(line_number: line_number, line_content: line_content))
}

pub type BreakLocation {
  BreakLocation(
    script_id: runtime.ScriptId,
    line_number: Int,
    column_number: option.Option(Int),
    type_: option.Option(BreakLocationType),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `BreakLocation`
pub type BreakLocationType {
  BreakLocationTypeDebuggerStatement
  BreakLocationTypeCall
  BreakLocationTypeReturn
}

@internal
pub fn encode__break_location_type(value__: BreakLocationType) {
  case value__ {
    BreakLocationTypeDebuggerStatement -> "debuggerStatement"
    BreakLocationTypeCall -> "call"
    BreakLocationTypeReturn -> "return"
  }
  |> json.string()
}

@internal
pub fn decode__break_location_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("debuggerStatement") -> Ok(BreakLocationTypeDebuggerStatement)
    Ok("call") -> Ok(BreakLocationTypeCall)
    Ok("return") -> Ok(BreakLocationTypeReturn)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

@internal
pub fn encode__break_location(value__: BreakLocation) {
  json.object(
    [
      #("scriptId", runtime.encode__script_id(value__.script_id)),
      #("lineNumber", json.int(value__.line_number)),
    ]
    |> utils.add_optional(value__.column_number, fn(inner_value__) {
      #("columnNumber", json.int(inner_value__))
    })
    |> utils.add_optional(value__.type_, fn(inner_value__) {
      #("type", encode__break_location_type(inner_value__))
    }),
  )
}

@internal
pub fn decode__break_location(value__: dynamic.Dynamic) {
  use script_id <- result.try(dynamic.field(
    "scriptId",
    runtime.decode__script_id,
  )(value__))
  use line_number <- result.try(dynamic.field("lineNumber", dynamic.int)(
    value__,
  ))
  use column_number <- result.try(dynamic.optional_field(
    "columnNumber",
    dynamic.int,
  )(value__))
  use type_ <- result.try(dynamic.optional_field(
    "type",
    decode__break_location_type,
  )(value__))

  Ok(BreakLocation(
    script_id: script_id,
    line_number: line_number,
    column_number: column_number,
    type_: type_,
  ))
}

/// Enum of possible script languages.
pub type ScriptLanguage {
  ScriptLanguageJavaScript
  ScriptLanguageWebAssembly
}

@internal
pub fn encode__script_language(value__: ScriptLanguage) {
  case value__ {
    ScriptLanguageJavaScript -> "JavaScript"
    ScriptLanguageWebAssembly -> "WebAssembly"
  }
  |> json.string()
}

@internal
pub fn decode__script_language(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("JavaScript") -> Ok(ScriptLanguageJavaScript)
    Ok("WebAssembly") -> Ok(ScriptLanguageWebAssembly)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Debug symbols available for a wasm script.
pub type DebugSymbols {
  DebugSymbols(type_: DebugSymbolsType, external_url: option.Option(String))
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `DebugSymbols`
pub type DebugSymbolsType {
  DebugSymbolsTypeNone
  DebugSymbolsTypeSourceMap
  DebugSymbolsTypeEmbeddedDwarf
  DebugSymbolsTypeExternalDwarf
}

@internal
pub fn encode__debug_symbols_type(value__: DebugSymbolsType) {
  case value__ {
    DebugSymbolsTypeNone -> "None"
    DebugSymbolsTypeSourceMap -> "SourceMap"
    DebugSymbolsTypeEmbeddedDwarf -> "EmbeddedDWARF"
    DebugSymbolsTypeExternalDwarf -> "ExternalDWARF"
  }
  |> json.string()
}

@internal
pub fn decode__debug_symbols_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("None") -> Ok(DebugSymbolsTypeNone)
    Ok("SourceMap") -> Ok(DebugSymbolsTypeSourceMap)
    Ok("EmbeddedDWARF") -> Ok(DebugSymbolsTypeEmbeddedDwarf)
    Ok("ExternalDWARF") -> Ok(DebugSymbolsTypeExternalDwarf)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

@internal
pub fn encode__debug_symbols(value__: DebugSymbols) {
  json.object(
    [#("type", encode__debug_symbols_type(value__.type_))]
    |> utils.add_optional(value__.external_url, fn(inner_value__) {
      #("externalURL", json.string(inner_value__))
    }),
  )
}

@internal
pub fn decode__debug_symbols(value__: dynamic.Dynamic) {
  use type_ <- result.try(dynamic.field("type", decode__debug_symbols_type)(
    value__,
  ))
  use external_url <- result.try(dynamic.optional_field(
    "externalURL",
    dynamic.string,
  )(value__))

  Ok(DebugSymbols(type_: type_, external_url: external_url))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `evaluate_on_call_frame`
pub type EvaluateOnCallFrameResponse {
  EvaluateOnCallFrameResponse(
    result: runtime.RemoteObject,
    exception_details: option.Option(runtime.ExceptionDetails),
  )
}

@internal
pub fn decode__evaluate_on_call_frame_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field(
    "result",
    runtime.decode__remote_object,
  )(value__))
  use exception_details <- result.try(dynamic.optional_field(
    "exceptionDetails",
    runtime.decode__exception_details,
  )(value__))

  Ok(EvaluateOnCallFrameResponse(
    result: result,
    exception_details: exception_details,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_possible_breakpoints`
pub type GetPossibleBreakpointsResponse {
  GetPossibleBreakpointsResponse(locations: List(BreakLocation))
}

@internal
pub fn decode__get_possible_breakpoints_response(value__: dynamic.Dynamic) {
  use locations <- result.try(dynamic.field(
    "locations",
    dynamic.list(decode__break_location),
  )(value__))

  Ok(GetPossibleBreakpointsResponse(locations: locations))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_script_source`
pub type GetScriptSourceResponse {
  GetScriptSourceResponse(
    script_source: String,
    bytecode: option.Option(String),
  )
}

@internal
pub fn decode__get_script_source_response(value__: dynamic.Dynamic) {
  use script_source <- result.try(dynamic.field("scriptSource", dynamic.string)(
    value__,
  ))
  use bytecode <- result.try(dynamic.optional_field("bytecode", dynamic.string)(
    value__,
  ))

  Ok(GetScriptSourceResponse(script_source: script_source, bytecode: bytecode))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `search_in_content`
pub type SearchInContentResponse {
  SearchInContentResponse(result: List(SearchMatch))
}

@internal
pub fn decode__search_in_content_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field(
    "result",
    dynamic.list(decode__search_match),
  )(value__))

  Ok(SearchInContentResponse(result: result))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_breakpoint`
pub type SetBreakpointResponse {
  SetBreakpointResponse(breakpoint_id: BreakpointId, actual_location: Location)
}

@internal
pub fn decode__set_breakpoint_response(value__: dynamic.Dynamic) {
  use breakpoint_id <- result.try(dynamic.field(
    "breakpointId",
    decode__breakpoint_id,
  )(value__))
  use actual_location <- result.try(dynamic.field(
    "actualLocation",
    decode__location,
  )(value__))

  Ok(SetBreakpointResponse(
    breakpoint_id: breakpoint_id,
    actual_location: actual_location,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_instrumentation_breakpoint`
pub type SetInstrumentationBreakpointResponse {
  SetInstrumentationBreakpointResponse(breakpoint_id: BreakpointId)
}

@internal
pub fn decode__set_instrumentation_breakpoint_response(value__: dynamic.Dynamic) {
  use breakpoint_id <- result.try(dynamic.field(
    "breakpointId",
    decode__breakpoint_id,
  )(value__))

  Ok(SetInstrumentationBreakpointResponse(breakpoint_id: breakpoint_id))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_breakpoint_by_url`
pub type SetBreakpointByUrlResponse {
  SetBreakpointByUrlResponse(
    breakpoint_id: BreakpointId,
    locations: List(Location),
  )
}

@internal
pub fn decode__set_breakpoint_by_url_response(value__: dynamic.Dynamic) {
  use breakpoint_id <- result.try(dynamic.field(
    "breakpointId",
    decode__breakpoint_id,
  )(value__))
  use locations <- result.try(dynamic.field(
    "locations",
    dynamic.list(decode__location),
  )(value__))

  Ok(SetBreakpointByUrlResponse(
    breakpoint_id: breakpoint_id,
    locations: locations,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_script_source`
pub type SetScriptSourceResponse {
  SetScriptSourceResponse(
    exception_details: option.Option(runtime.ExceptionDetails),
  )
}

@internal
pub fn decode__set_script_source_response(value__: dynamic.Dynamic) {
  use exception_details <- result.try(dynamic.optional_field(
    "exceptionDetails",
    runtime.decode__exception_details,
  )(value__))

  Ok(SetScriptSourceResponse(exception_details: exception_details))
}

/// Continues execution until specific location is reached.
pub fn continue_to_location(
  browser_subject,
  location: Location,
  target_call_frames: option.Option(ContinueToLocationTargetCallFrames),
) {
  let _ =
    chrome.call(
      browser_subject,
      "Debugger.continueToLocation",
      option.Some(json.object(
        [#("location", encode__location(location))]
        |> utils.add_optional(target_call_frames, fn(inner_value__) {
          #(
            "targetCallFrames",
            encode__continue_to_location_target_call_frames(inner_value__),
          )
        }),
      )),
      10_000,
    )
  Nil
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `targetCallFrames` of `continueToLocation`
pub type ContinueToLocationTargetCallFrames {
  ContinueToLocationTargetCallFramesAny
  ContinueToLocationTargetCallFramesCurrent
}

@internal
pub fn encode__continue_to_location_target_call_frames(value__: ContinueToLocationTargetCallFrames) {
  case value__ {
    ContinueToLocationTargetCallFramesAny -> "any"
    ContinueToLocationTargetCallFramesCurrent -> "current"
  }
  |> json.string()
}

@internal
pub fn decode__continue_to_location_target_call_frames(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("any") -> Ok(ContinueToLocationTargetCallFramesAny)
    Ok("current") -> Ok(ContinueToLocationTargetCallFramesCurrent)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Disables debugger for given page.
pub fn disable(browser_subject) {
  let _ = chrome.call(browser_subject, "Debugger.disable", option.None, 10_000)
  Nil
}

/// Enables debugger for the given page. Clients should not assume that the debugging has been
/// enabled until the result for this command is received.
pub fn enable(browser_subject) {
  let _ = chrome.call(browser_subject, "Debugger.enable", option.None, 10_000)
  Nil
}

/// Evaluates expression on a given call frame.
pub fn evaluate_on_call_frame(
  browser_subject,
  call_frame_id: CallFrameId,
  expression: String,
  object_group: option.Option(String),
  include_command_line_api: option.Option(Bool),
  silent: option.Option(Bool),
  return_by_value: option.Option(Bool),
  throw_on_side_effect: option.Option(Bool),
) {
  chrome.call(
    browser_subject,
    "Debugger.evaluateOnCallFrame",
    option.Some(json.object(
      [
        #("callFrameId", encode__call_frame_id(call_frame_id)),
        #("expression", json.string(expression)),
      ]
      |> utils.add_optional(object_group, fn(inner_value__) {
        #("objectGroup", json.string(inner_value__))
      })
      |> utils.add_optional(include_command_line_api, fn(inner_value__) {
        #("includeCommandLineAPI", json.bool(inner_value__))
      })
      |> utils.add_optional(silent, fn(inner_value__) {
        #("silent", json.bool(inner_value__))
      })
      |> utils.add_optional(return_by_value, fn(inner_value__) {
        #("returnByValue", json.bool(inner_value__))
      })
      |> utils.add_optional(throw_on_side_effect, fn(inner_value__) {
        #("throwOnSideEffect", json.bool(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__evaluate_on_call_frame_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Returns possible locations for breakpoint. scriptId in start and end range locations should be
/// the same.
pub fn get_possible_breakpoints(
  browser_subject,
  start: Location,
  end: option.Option(Location),
  restrict_to_function: option.Option(Bool),
) {
  chrome.call(
    browser_subject,
    "Debugger.getPossibleBreakpoints",
    option.Some(json.object(
      [#("start", encode__location(start))]
      |> utils.add_optional(end, fn(inner_value__) {
        #("end", encode__location(inner_value__))
      })
      |> utils.add_optional(restrict_to_function, fn(inner_value__) {
        #("restrictToFunction", json.bool(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__get_possible_breakpoints_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Returns source for the script with given id.
pub fn get_script_source(browser_subject, script_id: runtime.ScriptId) {
  chrome.call(
    browser_subject,
    "Debugger.getScriptSource",
    option.Some(
      json.object([#("scriptId", runtime.encode__script_id(script_id))]),
    ),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__get_script_source_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Stops on the next JavaScript statement.
pub fn pause(browser_subject) {
  let _ = chrome.call(browser_subject, "Debugger.pause", option.None, 10_000)
  Nil
}

/// Removes JavaScript breakpoint.
pub fn remove_breakpoint(browser_subject, breakpoint_id: BreakpointId) {
  let _ =
    chrome.call(
      browser_subject,
      "Debugger.removeBreakpoint",
      option.Some(
        json.object([#("breakpointId", encode__breakpoint_id(breakpoint_id))]),
      ),
      10_000,
    )
  Nil
}

/// Restarts particular call frame from the beginning. The old, deprecated
/// behavior of `restartFrame` is to stay paused and allow further CDP commands
/// after a restart was scheduled. This can cause problems with restarting, so
/// we now continue execution immediatly after it has been scheduled until we
/// reach the beginning of the restarted frame.
/// 
/// To stay back-wards compatible, `restartFrame` now expects a `mode`
/// parameter to be present. If the `mode` parameter is missing, `restartFrame`
/// errors out.
/// 
/// The various return values are deprecated and `callFrames` is always empty.
/// Use the call frames from the `Debugger#paused` events instead, that fires
/// once V8 pauses at the beginning of the restarted function.
pub fn restart_frame(browser_subject, call_frame_id: CallFrameId) {
  let _ =
    chrome.call(
      browser_subject,
      "Debugger.restartFrame",
      option.Some(
        json.object([#("callFrameId", encode__call_frame_id(call_frame_id))]),
      ),
      10_000,
    )
  Nil
}

/// Resumes JavaScript execution.
pub fn resume(browser_subject, terminate_on_resume: option.Option(Bool)) {
  let _ =
    chrome.call(
      browser_subject,
      "Debugger.resume",
      option.Some(json.object(
        []
        |> utils.add_optional(terminate_on_resume, fn(inner_value__) {
          #("terminateOnResume", json.bool(inner_value__))
        }),
      )),
      10_000,
    )
  Nil
}

/// Searches for given string in script content.
pub fn search_in_content(
  browser_subject,
  script_id: runtime.ScriptId,
  query: String,
  case_sensitive: option.Option(Bool),
  is_regex: option.Option(Bool),
) {
  chrome.call(
    browser_subject,
    "Debugger.searchInContent",
    option.Some(json.object(
      [
        #("scriptId", runtime.encode__script_id(script_id)),
        #("query", json.string(query)),
      ]
      |> utils.add_optional(case_sensitive, fn(inner_value__) {
        #("caseSensitive", json.bool(inner_value__))
      })
      |> utils.add_optional(is_regex, fn(inner_value__) {
        #("isRegex", json.bool(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__search_in_content_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Enables or disables async call stacks tracking.
pub fn set_async_call_stack_depth(browser_subject, max_depth: Int) {
  let _ =
    chrome.call(
      browser_subject,
      "Debugger.setAsyncCallStackDepth",
      option.Some(json.object([#("maxDepth", json.int(max_depth))])),
      10_000,
    )
  Nil
}

/// Sets JavaScript breakpoint at a given location.
pub fn set_breakpoint(
  browser_subject,
  location: Location,
  condition: option.Option(String),
) {
  chrome.call(
    browser_subject,
    "Debugger.setBreakpoint",
    option.Some(json.object(
      [#("location", encode__location(location))]
      |> utils.add_optional(condition, fn(inner_value__) {
        #("condition", json.string(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__set_breakpoint_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Sets instrumentation breakpoint.
pub fn set_instrumentation_breakpoint(
  browser_subject,
  instrumentation: SetInstrumentationBreakpointInstrumentation,
) {
  chrome.call(
    browser_subject,
    "Debugger.setInstrumentationBreakpoint",
    option.Some(
      json.object([
        #(
          "instrumentation",
          encode__set_instrumentation_breakpoint_instrumentation(
            instrumentation,
          ),
        ),
      ]),
    ),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__set_instrumentation_breakpoint_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `instrumentation` of `setInstrumentationBreakpoint`
pub type SetInstrumentationBreakpointInstrumentation {
  SetInstrumentationBreakpointInstrumentationBeforeScriptExecution
  SetInstrumentationBreakpointInstrumentationBeforeScriptWithSourceMapExecution
}

@internal
pub fn encode__set_instrumentation_breakpoint_instrumentation(value__: SetInstrumentationBreakpointInstrumentation) {
  case value__ {
    SetInstrumentationBreakpointInstrumentationBeforeScriptExecution ->
      "beforeScriptExecution"
    SetInstrumentationBreakpointInstrumentationBeforeScriptWithSourceMapExecution ->
      "beforeScriptWithSourceMapExecution"
  }
  |> json.string()
}

@internal
pub fn decode__set_instrumentation_breakpoint_instrumentation(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("beforeScriptExecution") ->
      Ok(SetInstrumentationBreakpointInstrumentationBeforeScriptExecution)
    Ok("beforeScriptWithSourceMapExecution") ->
      Ok(
        SetInstrumentationBreakpointInstrumentationBeforeScriptWithSourceMapExecution,
      )
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
/// command is issued, all existing parsed scripts will have breakpoints resolved and returned in
/// `locations` property. Further matching script parsing will result in subsequent
/// `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
pub fn set_breakpoint_by_url(
  browser_subject,
  line_number: Int,
  url: option.Option(String),
  url_regex: option.Option(String),
  script_hash: option.Option(String),
  column_number: option.Option(Int),
  condition: option.Option(String),
) {
  chrome.call(
    browser_subject,
    "Debugger.setBreakpointByUrl",
    option.Some(json.object(
      [#("lineNumber", json.int(line_number))]
      |> utils.add_optional(url, fn(inner_value__) {
        #("url", json.string(inner_value__))
      })
      |> utils.add_optional(url_regex, fn(inner_value__) {
        #("urlRegex", json.string(inner_value__))
      })
      |> utils.add_optional(script_hash, fn(inner_value__) {
        #("scriptHash", json.string(inner_value__))
      })
      |> utils.add_optional(column_number, fn(inner_value__) {
        #("columnNumber", json.int(inner_value__))
      })
      |> utils.add_optional(condition, fn(inner_value__) {
        #("condition", json.string(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__set_breakpoint_by_url_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Activates / deactivates all breakpoints on the page.
pub fn set_breakpoints_active(browser_subject, active: Bool) {
  let _ =
    chrome.call(
      browser_subject,
      "Debugger.setBreakpointsActive",
      option.Some(json.object([#("active", json.bool(active))])),
      10_000,
    )
  Nil
}

/// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
/// or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
pub fn set_pause_on_exceptions(
  browser_subject,
  state: SetPauseOnExceptionsState,
) {
  let _ =
    chrome.call(
      browser_subject,
      "Debugger.setPauseOnExceptions",
      option.Some(
        json.object([#("state", encode__set_pause_on_exceptions_state(state))]),
      ),
      10_000,
    )
  Nil
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `state` of `setPauseOnExceptions`
pub type SetPauseOnExceptionsState {
  SetPauseOnExceptionsStateNone
  SetPauseOnExceptionsStateCaught
  SetPauseOnExceptionsStateUncaught
  SetPauseOnExceptionsStateAll
}

@internal
pub fn encode__set_pause_on_exceptions_state(value__: SetPauseOnExceptionsState) {
  case value__ {
    SetPauseOnExceptionsStateNone -> "none"
    SetPauseOnExceptionsStateCaught -> "caught"
    SetPauseOnExceptionsStateUncaught -> "uncaught"
    SetPauseOnExceptionsStateAll -> "all"
  }
  |> json.string()
}

@internal
pub fn decode__set_pause_on_exceptions_state(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("none") -> Ok(SetPauseOnExceptionsStateNone)
    Ok("caught") -> Ok(SetPauseOnExceptionsStateCaught)
    Ok("uncaught") -> Ok(SetPauseOnExceptionsStateUncaught)
    Ok("all") -> Ok(SetPauseOnExceptionsStateAll)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Edits JavaScript source live.
/// 
/// In general, functions that are currently on the stack can not be edited with
/// a single exception: If the edited function is the top-most stack frame and
/// that is the only activation of that function on the stack. In this case
/// the live edit will be successful and a `Debugger.restartFrame` for the
/// top-most function is automatically triggered.
pub fn set_script_source(
  browser_subject,
  script_id: runtime.ScriptId,
  script_source: String,
  dry_run: option.Option(Bool),
) {
  chrome.call(
    browser_subject,
    "Debugger.setScriptSource",
    option.Some(json.object(
      [
        #("scriptId", runtime.encode__script_id(script_id)),
        #("scriptSource", json.string(script_source)),
      ]
      |> utils.add_optional(dry_run, fn(inner_value__) {
        #("dryRun", json.bool(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__set_script_source_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
pub fn set_skip_all_pauses(browser_subject, skip: Bool) {
  let _ =
    chrome.call(
      browser_subject,
      "Debugger.setSkipAllPauses",
      option.Some(json.object([#("skip", json.bool(skip))])),
      10_000,
    )
  Nil
}

/// Changes value of variable in a callframe. Object-based scopes are not supported and must be
/// mutated manually.
pub fn set_variable_value(
  browser_subject,
  scope_number: Int,
  variable_name: String,
  new_value: runtime.CallArgument,
  call_frame_id: CallFrameId,
) {
  let _ =
    chrome.call(
      browser_subject,
      "Debugger.setVariableValue",
      option.Some(
        json.object([
          #("scopeNumber", json.int(scope_number)),
          #("variableName", json.string(variable_name)),
          #("newValue", runtime.encode__call_argument(new_value)),
          #("callFrameId", encode__call_frame_id(call_frame_id)),
        ]),
      ),
      10_000,
    )
  Nil
}

/// Steps into the function call.
pub fn step_into(browser_subject) {
  let _ = chrome.call(browser_subject, "Debugger.stepInto", option.None, 10_000)
  Nil
}

/// Steps out of the function call.
pub fn step_out(browser_subject) {
  let _ = chrome.call(browser_subject, "Debugger.stepOut", option.None, 10_000)
  Nil
}

/// Steps over the statement.
pub fn step_over(browser_subject) {
  let _ = chrome.call(browser_subject, "Debugger.stepOver", option.None, 10_000)
  Nil
}
