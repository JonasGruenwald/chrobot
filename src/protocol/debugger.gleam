//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Debugger Domain  
////
//// Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
//// breakpoints, stepping through execution, exploring stack traces, etc.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Debugger/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import gleam/dynamic
import gleam/json
import gleam/option
import gleam/result
import protocol/runtime

/// Breakpoint identifier.
pub type BreakpointId {
  BreakpointId(String)
}

@internal
pub fn encode__breakpoint_id(value__: BreakpointId) {
  case value__ {
    BreakpointId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__breakpoint_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(BreakpointId, dynamic.string)
}

/// Call frame identifier.
pub type CallFrameId {
  CallFrameId(String)
}

@internal
pub fn encode__call_frame_id(value__: CallFrameId) {
  case value__ {
    CallFrameId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__call_frame_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(CallFrameId, dynamic.string)
}

/// Location in the source code.
pub type Location {
  Location(
    script_id: runtime.ScriptId,
    line_number: Int,
    column_number: option.Option(Int),
  )
}

@internal
pub fn encode__location(value__: Location) {
  json.object([
    #("scriptId", runtime.encode__script_id(value__.script_id)),
    #("lineNumber", json.int(value__.line_number)),
    #("columnNumber", {
      case value__.column_number {
        option.Some(value__) -> json.int(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__location(value__: dynamic.Dynamic) {
  use script_id <- result.try(dynamic.field(
    "scriptId",
    runtime.decode__script_id,
  )(value__))
  use line_number <- result.try(dynamic.field("lineNumber", dynamic.int)(
    value__,
  ))
  use column_number <- result.try(dynamic.optional_field(
    "columnNumber",
    dynamic.int,
  )(value__))

  Ok(Location(
    script_id: script_id,
    line_number: line_number,
    column_number: column_number,
  ))
}

/// JavaScript call frame. Array of call frames form the call stack.
pub type CallFrame {
  CallFrame(
    call_frame_id: CallFrameId,
    function_name: String,
    function_location: option.Option(Location),
    location: Location,
    scope_chain: List(Scope),
    this: runtime.RemoteObject,
    return_value: option.Option(runtime.RemoteObject),
  )
}

@internal
pub fn encode__call_frame(value__: CallFrame) {
  json.object([
    #("callFrameId", encode__call_frame_id(value__.call_frame_id)),
    #("functionName", json.string(value__.function_name)),
    #("functionLocation", {
      case value__.function_location {
        option.Some(value__) -> encode__location(value__)
        option.None -> json.null()
      }
    }),
    #("location", encode__location(value__.location)),
    #("scopeChain", json.array(value__.scope_chain, of: encode__scope)),
    #("this", runtime.encode__remote_object(value__.this)),
    #("returnValue", {
      case value__.return_value {
        option.Some(value__) -> runtime.encode__remote_object(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__call_frame(value__: dynamic.Dynamic) {
  use call_frame_id <- result.try(dynamic.field(
    "callFrameId",
    decode__call_frame_id,
  )(value__))
  use function_name <- result.try(dynamic.field("functionName", dynamic.string)(
    value__,
  ))
  use function_location <- result.try(dynamic.optional_field(
    "functionLocation",
    decode__location,
  )(value__))
  use location <- result.try(dynamic.field("location", decode__location)(
    value__,
  ))
  use scope_chain <- result.try(dynamic.field(
    "scopeChain",
    dynamic.list(decode__scope),
  )(value__))
  use this <- result.try(dynamic.field("this", runtime.decode__remote_object)(
    value__,
  ))
  use return_value <- result.try(dynamic.optional_field(
    "returnValue",
    runtime.decode__remote_object,
  )(value__))

  Ok(CallFrame(
    call_frame_id: call_frame_id,
    function_name: function_name,
    function_location: function_location,
    location: location,
    scope_chain: scope_chain,
    this: this,
    return_value: return_value,
  ))
}

/// Scope description.
pub type Scope {
  Scope(
    type_: ScopeType,
    object: runtime.RemoteObject,
    name: option.Option(String),
    start_location: option.Option(Location),
    end_location: option.Option(Location),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `Scope`
pub type ScopeType {
  ScopeTypeGlobal
  ScopeTypeLocal
  ScopeTypeWith
  ScopeTypeClosure
  ScopeTypeCatch
  ScopeTypeBlock
  ScopeTypeScript
  ScopeTypeEval
  ScopeTypeModule
  ScopeTypeWasmExpressionStack
}

@internal
pub fn encode__scope_type(value__: ScopeType) {
  case value__ {
    ScopeTypeGlobal -> "global"
    ScopeTypeLocal -> "local"
    ScopeTypeWith -> "with"
    ScopeTypeClosure -> "closure"
    ScopeTypeCatch -> "catch"
    ScopeTypeBlock -> "block"
    ScopeTypeScript -> "script"
    ScopeTypeEval -> "eval"
    ScopeTypeModule -> "module"
    ScopeTypeWasmExpressionStack -> "wasm-expression-stack"
  }
  |> json.string()
}

@internal
pub fn decode__scope_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("global") -> Ok(ScopeTypeGlobal)
    Ok("local") -> Ok(ScopeTypeLocal)
    Ok("with") -> Ok(ScopeTypeWith)
    Ok("closure") -> Ok(ScopeTypeClosure)
    Ok("catch") -> Ok(ScopeTypeCatch)
    Ok("block") -> Ok(ScopeTypeBlock)
    Ok("script") -> Ok(ScopeTypeScript)
    Ok("eval") -> Ok(ScopeTypeEval)
    Ok("module") -> Ok(ScopeTypeModule)
    Ok("wasm-expression-stack") -> Ok(ScopeTypeWasmExpressionStack)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

@internal
pub fn encode__scope(value__: Scope) {
  json.object([
    #("type", encode__scope_type(value__.type_)),
    #("object", runtime.encode__remote_object(value__.object)),
    #("name", {
      case value__.name {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("startLocation", {
      case value__.start_location {
        option.Some(value__) -> encode__location(value__)
        option.None -> json.null()
      }
    }),
    #("endLocation", {
      case value__.end_location {
        option.Some(value__) -> encode__location(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__scope(value__: dynamic.Dynamic) {
  use type_ <- result.try(dynamic.field("type", decode__scope_type)(value__))
  use object <- result.try(dynamic.field(
    "object",
    runtime.decode__remote_object,
  )(value__))
  use name <- result.try(dynamic.optional_field("name", dynamic.string)(value__))
  use start_location <- result.try(dynamic.optional_field(
    "startLocation",
    decode__location,
  )(value__))
  use end_location <- result.try(dynamic.optional_field(
    "endLocation",
    decode__location,
  )(value__))

  Ok(Scope(
    type_: type_,
    object: object,
    name: name,
    start_location: start_location,
    end_location: end_location,
  ))
}

/// Search match for resource.
pub type SearchMatch {
  SearchMatch(line_number: Float, line_content: String)
}

@internal
pub fn encode__search_match(value__: SearchMatch) {
  json.object([
    #("lineNumber", json.float(value__.line_number)),
    #("lineContent", json.string(value__.line_content)),
  ])
}

@internal
pub fn decode__search_match(value__: dynamic.Dynamic) {
  use line_number <- result.try(dynamic.field("lineNumber", dynamic.float)(
    value__,
  ))
  use line_content <- result.try(dynamic.field("lineContent", dynamic.string)(
    value__,
  ))

  Ok(SearchMatch(line_number: line_number, line_content: line_content))
}

pub type BreakLocation {
  BreakLocation(
    script_id: runtime.ScriptId,
    line_number: Int,
    column_number: option.Option(Int),
    type_: option.Option(BreakLocationType),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `BreakLocation`
pub type BreakLocationType {
  BreakLocationTypeDebuggerStatement
  BreakLocationTypeCall
  BreakLocationTypeReturn
}

@internal
pub fn encode__break_location_type(value__: BreakLocationType) {
  case value__ {
    BreakLocationTypeDebuggerStatement -> "debuggerStatement"
    BreakLocationTypeCall -> "call"
    BreakLocationTypeReturn -> "return"
  }
  |> json.string()
}

@internal
pub fn decode__break_location_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("debuggerStatement") -> Ok(BreakLocationTypeDebuggerStatement)
    Ok("call") -> Ok(BreakLocationTypeCall)
    Ok("return") -> Ok(BreakLocationTypeReturn)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

@internal
pub fn encode__break_location(value__: BreakLocation) {
  json.object([
    #("scriptId", runtime.encode__script_id(value__.script_id)),
    #("lineNumber", json.int(value__.line_number)),
    #("columnNumber", {
      case value__.column_number {
        option.Some(value__) -> json.int(value__)
        option.None -> json.null()
      }
    }),
    #("type", {
      case value__.type_ {
        option.Some(value__) -> encode__break_location_type(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__break_location(value__: dynamic.Dynamic) {
  use script_id <- result.try(dynamic.field(
    "scriptId",
    runtime.decode__script_id,
  )(value__))
  use line_number <- result.try(dynamic.field("lineNumber", dynamic.int)(
    value__,
  ))
  use column_number <- result.try(dynamic.optional_field(
    "columnNumber",
    dynamic.int,
  )(value__))
  use type_ <- result.try(dynamic.optional_field(
    "type",
    decode__break_location_type,
  )(value__))

  Ok(BreakLocation(
    script_id: script_id,
    line_number: line_number,
    column_number: column_number,
    type_: type_,
  ))
}

/// Enum of possible script languages.
pub type ScriptLanguage {
  ScriptLanguageJavaScript
  ScriptLanguageWebAssembly
}

@internal
pub fn encode__script_language(value__: ScriptLanguage) {
  case value__ {
    ScriptLanguageJavaScript -> "JavaScript"
    ScriptLanguageWebAssembly -> "WebAssembly"
  }
  |> json.string()
}

@internal
pub fn decode__script_language(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("JavaScript") -> Ok(ScriptLanguageJavaScript)
    Ok("WebAssembly") -> Ok(ScriptLanguageWebAssembly)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Debug symbols available for a wasm script.
pub type DebugSymbols {
  DebugSymbols(type_: DebugSymbolsType, external_url: option.Option(String))
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `DebugSymbols`
pub type DebugSymbolsType {
  DebugSymbolsTypeNone
  DebugSymbolsTypeSourceMap
  DebugSymbolsTypeEmbeddedDwarf
  DebugSymbolsTypeExternalDwarf
}

@internal
pub fn encode__debug_symbols_type(value__: DebugSymbolsType) {
  case value__ {
    DebugSymbolsTypeNone -> "None"
    DebugSymbolsTypeSourceMap -> "SourceMap"
    DebugSymbolsTypeEmbeddedDwarf -> "EmbeddedDWARF"
    DebugSymbolsTypeExternalDwarf -> "ExternalDWARF"
  }
  |> json.string()
}

@internal
pub fn decode__debug_symbols_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("None") -> Ok(DebugSymbolsTypeNone)
    Ok("SourceMap") -> Ok(DebugSymbolsTypeSourceMap)
    Ok("EmbeddedDWARF") -> Ok(DebugSymbolsTypeEmbeddedDwarf)
    Ok("ExternalDWARF") -> Ok(DebugSymbolsTypeExternalDwarf)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

@internal
pub fn encode__debug_symbols(value__: DebugSymbols) {
  json.object([
    #("type", encode__debug_symbols_type(value__.type_)),
    #("externalURL", {
      case value__.external_url {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__debug_symbols(value__: dynamic.Dynamic) {
  use type_ <- result.try(dynamic.field("type", decode__debug_symbols_type)(
    value__,
  ))
  use external_url <- result.try(dynamic.optional_field(
    "externalURL",
    dynamic.string,
  )(value__))

  Ok(DebugSymbols(type_: type_, external_url: external_url))
}
