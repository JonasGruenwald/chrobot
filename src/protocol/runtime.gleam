//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Runtime Domain  
////
//// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
//// Evaluation results are returned as mirror object that expose object type, string representation
//// and unique identifier that can be used for further object reference. Original objects are
//// maintained in memory unless they are either explicitly released or are released along with the
//// other objects in their object group.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import chrome
import gleam/dict
import gleam/dynamic
import gleam/json
import gleam/option

/// Unique script identifier.
pub type ScriptId {
  ScriptId(String)
}

@internal
pub fn encode__script_id(value: ScriptId) {
  case value {
    ScriptId(inner_value) -> json.string(inner_value)
  }
}

/// Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
pub type SerializationOptions {
  SerializationOptions(
    serialization: SerializationOptionsSerialization,
    max_depth: option.Option(Int),
    additional_parameters: option.Option(dict.Dict(String, String)),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `serialization` of `SerializationOptions`
pub type SerializationOptionsSerialization {
  SerializationOptionsSerializationDeep
  SerializationOptionsSerializationJson
  SerializationOptionsSerializationIdOnly
}

@internal
pub fn encode__serialization_options_serialization(value: SerializationOptionsSerialization) {
  case value {
    SerializationOptionsSerializationDeep -> "deep"
    SerializationOptionsSerializationJson -> "json"
    SerializationOptionsSerializationIdOnly -> "idOnly"
  }
  |> json.string()
}

@internal
pub fn decode__serialization_options_serialization(value: dynamic.Dynamic) {
  case dynamic.string(value) {
    Ok("deep") -> Ok(SerializationOptionsSerializationDeep)
    Ok("json") -> Ok(SerializationOptionsSerializationJson)
    Ok("idOnly") -> Ok(SerializationOptionsSerializationIdOnly)
    _ -> Error(chrome.ProtocolError)
  }
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("serialization", None, None, None, None, EnumType(["deep", "json", "idOnly"])), PropertyDefinition("maxDepth", Some("Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode."), None, None, Some(True), PrimitiveType("integer")), PropertyDefinition("additionalParameters", Some("Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM\nserialization via `maxNodeDepth: integer` and `includeShadowTree: \"none\" | \"open\" | \"all\"`.\nValues can be only of type string or integer."), None, None, Some(True), ObjectType(None))]))
/// Represents deep serialized value.
pub type DeepSerializedValue {
  DeepSerializedValue(
    type_: DeepSerializedValueType,
    value: option.Option(dynamic.Dynamic),
    object_id: option.Option(String),
    weak_local_object_reference: option.Option(Int),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `DeepSerializedValue`
pub type DeepSerializedValueType {
  DeepSerializedValueTypeUndefined
  DeepSerializedValueTypeNull
  DeepSerializedValueTypeString
  DeepSerializedValueTypeNumber
  DeepSerializedValueTypeBoolean
  DeepSerializedValueTypeBigint
  DeepSerializedValueTypeRegexp
  DeepSerializedValueTypeDate
  DeepSerializedValueTypeSymbol
  DeepSerializedValueTypeArray
  DeepSerializedValueTypeObject
  DeepSerializedValueTypeFunction
  DeepSerializedValueTypeMap
  DeepSerializedValueTypeSet
  DeepSerializedValueTypeWeakmap
  DeepSerializedValueTypeWeakset
  DeepSerializedValueTypeError
  DeepSerializedValueTypeProxy
  DeepSerializedValueTypePromise
  DeepSerializedValueTypeTypedarray
  DeepSerializedValueTypeArraybuffer
  DeepSerializedValueTypeNode
  DeepSerializedValueTypeWindow
  DeepSerializedValueTypeGenerator
}

@internal
pub fn encode__deep_serialized_value_type(value: DeepSerializedValueType) {
  case value {
    DeepSerializedValueTypeUndefined -> "undefined"
    DeepSerializedValueTypeNull -> "null"
    DeepSerializedValueTypeString -> "string"
    DeepSerializedValueTypeNumber -> "number"
    DeepSerializedValueTypeBoolean -> "boolean"
    DeepSerializedValueTypeBigint -> "bigint"
    DeepSerializedValueTypeRegexp -> "regexp"
    DeepSerializedValueTypeDate -> "date"
    DeepSerializedValueTypeSymbol -> "symbol"
    DeepSerializedValueTypeArray -> "array"
    DeepSerializedValueTypeObject -> "object"
    DeepSerializedValueTypeFunction -> "function"
    DeepSerializedValueTypeMap -> "map"
    DeepSerializedValueTypeSet -> "set"
    DeepSerializedValueTypeWeakmap -> "weakmap"
    DeepSerializedValueTypeWeakset -> "weakset"
    DeepSerializedValueTypeError -> "error"
    DeepSerializedValueTypeProxy -> "proxy"
    DeepSerializedValueTypePromise -> "promise"
    DeepSerializedValueTypeTypedarray -> "typedarray"
    DeepSerializedValueTypeArraybuffer -> "arraybuffer"
    DeepSerializedValueTypeNode -> "node"
    DeepSerializedValueTypeWindow -> "window"
    DeepSerializedValueTypeGenerator -> "generator"
  }
  |> json.string()
}

@internal
pub fn decode__deep_serialized_value_type(value: dynamic.Dynamic) {
  case dynamic.string(value) {
    Ok("undefined") -> Ok(DeepSerializedValueTypeUndefined)
    Ok("null") -> Ok(DeepSerializedValueTypeNull)
    Ok("string") -> Ok(DeepSerializedValueTypeString)
    Ok("number") -> Ok(DeepSerializedValueTypeNumber)
    Ok("boolean") -> Ok(DeepSerializedValueTypeBoolean)
    Ok("bigint") -> Ok(DeepSerializedValueTypeBigint)
    Ok("regexp") -> Ok(DeepSerializedValueTypeRegexp)
    Ok("date") -> Ok(DeepSerializedValueTypeDate)
    Ok("symbol") -> Ok(DeepSerializedValueTypeSymbol)
    Ok("array") -> Ok(DeepSerializedValueTypeArray)
    Ok("object") -> Ok(DeepSerializedValueTypeObject)
    Ok("function") -> Ok(DeepSerializedValueTypeFunction)
    Ok("map") -> Ok(DeepSerializedValueTypeMap)
    Ok("set") -> Ok(DeepSerializedValueTypeSet)
    Ok("weakmap") -> Ok(DeepSerializedValueTypeWeakmap)
    Ok("weakset") -> Ok(DeepSerializedValueTypeWeakset)
    Ok("error") -> Ok(DeepSerializedValueTypeError)
    Ok("proxy") -> Ok(DeepSerializedValueTypeProxy)
    Ok("promise") -> Ok(DeepSerializedValueTypePromise)
    Ok("typedarray") -> Ok(DeepSerializedValueTypeTypedarray)
    Ok("arraybuffer") -> Ok(DeepSerializedValueTypeArraybuffer)
    Ok("node") -> Ok(DeepSerializedValueTypeNode)
    Ok("window") -> Ok(DeepSerializedValueTypeWindow)
    Ok("generator") -> Ok(DeepSerializedValueTypeGenerator)
    _ -> Error(chrome.ProtocolError)
  }
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("type", None, None, None, None, EnumType(["undefined", "null", "string", "number", "boolean", "bigint", "regexp", "date", "symbol", "array", "object", "function", "map", "set", "weakmap", "weakset", "error", "proxy", "promise", "typedarray", "arraybuffer", "node", "window", "generator"])), PropertyDefinition("value", None, None, None, Some(True), PrimitiveType("any")), PropertyDefinition("objectId", None, None, None, Some(True), PrimitiveType("string")), PropertyDefinition("weakLocalObjectReference", Some("Set if value reference met more then once during serialization. In such\ncase, value is provided only to one of the serialized values. Unique\nper value in the scope of one CDP call."), None, None, Some(True), PrimitiveType("integer"))]))
/// Unique object identifier.
pub type RemoteObjectId {
  RemoteObjectId(String)
}

@internal
pub fn encode__remote_object_id(value: RemoteObjectId) {
  case value {
    RemoteObjectId(inner_value) -> json.string(inner_value)
  }
}

/// Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
/// `-Infinity`, and bigint literals.
pub type UnserializableValue {
  UnserializableValue(String)
}

@internal
pub fn encode__unserializable_value(value: UnserializableValue) {
  case value {
    UnserializableValue(inner_value) -> json.string(inner_value)
  }
}

/// Mirror object referencing original JavaScript object.
pub type RemoteObject {
  RemoteObject(
    type_: RemoteObjectType,
    subtype: option.Option(RemoteObjectSubtype),
    class_name: option.Option(String),
    value: option.Option(dynamic.Dynamic),
    unserializable_value: option.Option(UnserializableValue),
    description: option.Option(String),
    object_id: option.Option(RemoteObjectId),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `RemoteObject`
pub type RemoteObjectType {
  RemoteObjectTypeObject
  RemoteObjectTypeFunction
  RemoteObjectTypeUndefined
  RemoteObjectTypeString
  RemoteObjectTypeNumber
  RemoteObjectTypeBoolean
  RemoteObjectTypeSymbol
  RemoteObjectTypeBigint
}

@internal
pub fn encode__remote_object_type(value: RemoteObjectType) {
  case value {
    RemoteObjectTypeObject -> "object"
    RemoteObjectTypeFunction -> "function"
    RemoteObjectTypeUndefined -> "undefined"
    RemoteObjectTypeString -> "string"
    RemoteObjectTypeNumber -> "number"
    RemoteObjectTypeBoolean -> "boolean"
    RemoteObjectTypeSymbol -> "symbol"
    RemoteObjectTypeBigint -> "bigint"
  }
  |> json.string()
}

@internal
pub fn decode__remote_object_type(value: dynamic.Dynamic) {
  case dynamic.string(value) {
    Ok("object") -> Ok(RemoteObjectTypeObject)
    Ok("function") -> Ok(RemoteObjectTypeFunction)
    Ok("undefined") -> Ok(RemoteObjectTypeUndefined)
    Ok("string") -> Ok(RemoteObjectTypeString)
    Ok("number") -> Ok(RemoteObjectTypeNumber)
    Ok("boolean") -> Ok(RemoteObjectTypeBoolean)
    Ok("symbol") -> Ok(RemoteObjectTypeSymbol)
    Ok("bigint") -> Ok(RemoteObjectTypeBigint)
    _ -> Error(chrome.ProtocolError)
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `subtype` of `RemoteObject`
pub type RemoteObjectSubtype {
  RemoteObjectSubtypeArray
  RemoteObjectSubtypeNull
  RemoteObjectSubtypeNode
  RemoteObjectSubtypeRegexp
  RemoteObjectSubtypeDate
  RemoteObjectSubtypeMap
  RemoteObjectSubtypeSet
  RemoteObjectSubtypeWeakmap
  RemoteObjectSubtypeWeakset
  RemoteObjectSubtypeIterator
  RemoteObjectSubtypeGenerator
  RemoteObjectSubtypeError
  RemoteObjectSubtypeProxy
  RemoteObjectSubtypePromise
  RemoteObjectSubtypeTypedarray
  RemoteObjectSubtypeArraybuffer
  RemoteObjectSubtypeDataview
  RemoteObjectSubtypeWebassemblymemory
  RemoteObjectSubtypeWasmvalue
}

@internal
pub fn encode__remote_object_subtype(value: RemoteObjectSubtype) {
  case value {
    RemoteObjectSubtypeArray -> "array"
    RemoteObjectSubtypeNull -> "null"
    RemoteObjectSubtypeNode -> "node"
    RemoteObjectSubtypeRegexp -> "regexp"
    RemoteObjectSubtypeDate -> "date"
    RemoteObjectSubtypeMap -> "map"
    RemoteObjectSubtypeSet -> "set"
    RemoteObjectSubtypeWeakmap -> "weakmap"
    RemoteObjectSubtypeWeakset -> "weakset"
    RemoteObjectSubtypeIterator -> "iterator"
    RemoteObjectSubtypeGenerator -> "generator"
    RemoteObjectSubtypeError -> "error"
    RemoteObjectSubtypeProxy -> "proxy"
    RemoteObjectSubtypePromise -> "promise"
    RemoteObjectSubtypeTypedarray -> "typedarray"
    RemoteObjectSubtypeArraybuffer -> "arraybuffer"
    RemoteObjectSubtypeDataview -> "dataview"
    RemoteObjectSubtypeWebassemblymemory -> "webassemblymemory"
    RemoteObjectSubtypeWasmvalue -> "wasmvalue"
  }
  |> json.string()
}

@internal
pub fn decode__remote_object_subtype(value: dynamic.Dynamic) {
  case dynamic.string(value) {
    Ok("array") -> Ok(RemoteObjectSubtypeArray)
    Ok("null") -> Ok(RemoteObjectSubtypeNull)
    Ok("node") -> Ok(RemoteObjectSubtypeNode)
    Ok("regexp") -> Ok(RemoteObjectSubtypeRegexp)
    Ok("date") -> Ok(RemoteObjectSubtypeDate)
    Ok("map") -> Ok(RemoteObjectSubtypeMap)
    Ok("set") -> Ok(RemoteObjectSubtypeSet)
    Ok("weakmap") -> Ok(RemoteObjectSubtypeWeakmap)
    Ok("weakset") -> Ok(RemoteObjectSubtypeWeakset)
    Ok("iterator") -> Ok(RemoteObjectSubtypeIterator)
    Ok("generator") -> Ok(RemoteObjectSubtypeGenerator)
    Ok("error") -> Ok(RemoteObjectSubtypeError)
    Ok("proxy") -> Ok(RemoteObjectSubtypeProxy)
    Ok("promise") -> Ok(RemoteObjectSubtypePromise)
    Ok("typedarray") -> Ok(RemoteObjectSubtypeTypedarray)
    Ok("arraybuffer") -> Ok(RemoteObjectSubtypeArraybuffer)
    Ok("dataview") -> Ok(RemoteObjectSubtypeDataview)
    Ok("webassemblymemory") -> Ok(RemoteObjectSubtypeWebassemblymemory)
    Ok("wasmvalue") -> Ok(RemoteObjectSubtypeWasmvalue)
    _ -> Error(chrome.ProtocolError)
  }
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("type", Some("Object type."), None, None, None, EnumType(["object", "function", "undefined", "string", "number", "boolean", "symbol", "bigint"])), PropertyDefinition("subtype", Some("Object subtype hint. Specified for `object` type values only.\nNOTE: If you change anything here, make sure to also update\n`subtype` in `ObjectPreview` and `PropertyPreview` below."), None, None, Some(True), EnumType(["array", "null", "node", "regexp", "date", "map", "set", "weakmap", "weakset", "iterator", "generator", "error", "proxy", "promise", "typedarray", "arraybuffer", "dataview", "webassemblymemory", "wasmvalue"])), PropertyDefinition("className", Some("Object class (constructor) name. Specified for `object` type values only."), None, None, Some(True), PrimitiveType("string")), PropertyDefinition("value", Some("Remote object value in case of primitive values or JSON values (if it was requested)."), None, None, Some(True), PrimitiveType("any")), PropertyDefinition("unserializableValue", Some("Primitive value which can not be JSON-stringified does not have `value`, but gets this\nproperty."), None, None, Some(True), RefType("UnserializableValue")), PropertyDefinition("description", Some("String representation of the object."), None, None, Some(True), PrimitiveType("string")), PropertyDefinition("objectId", Some("Unique object identifier (for non-primitive values)."), None, None, Some(True), RefType("RemoteObjectId"))]))
/// Object property descriptor.
pub type PropertyDescriptor {
  PropertyDescriptor(
    name: String,
    value: option.Option(RemoteObject),
    writable: option.Option(Bool),
    get: option.Option(RemoteObject),
    set: option.Option(RemoteObject),
    configurable: Bool,
    enumerable: Bool,
    was_thrown: option.Option(Bool),
    is_own: option.Option(Bool),
    symbol: option.Option(RemoteObject),
  )
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("name", Some("Property name or symbol description."), None, None, None, PrimitiveType("string")), PropertyDefinition("value", Some("The value associated with the property."), None, None, Some(True), RefType("RemoteObject")), PropertyDefinition("writable", Some("True if the value associated with the property may be changed (data descriptors only)."), None, None, Some(True), PrimitiveType("boolean")), PropertyDefinition("get", Some("A function which serves as a getter for the property, or `undefined` if there is no getter\n(accessor descriptors only)."), None, None, Some(True), RefType("RemoteObject")), PropertyDefinition("set", Some("A function which serves as a setter for the property, or `undefined` if there is no setter\n(accessor descriptors only)."), None, None, Some(True), RefType("RemoteObject")), PropertyDefinition("configurable", Some("True if the type of this property descriptor may be changed and if the property may be\ndeleted from the corresponding object."), None, None, None, PrimitiveType("boolean")), PropertyDefinition("enumerable", Some("True if this property shows up during enumeration of the properties on the corresponding\nobject."), None, None, None, PrimitiveType("boolean")), PropertyDefinition("wasThrown", Some("True if the result was thrown during the evaluation."), None, None, Some(True), PrimitiveType("boolean")), PropertyDefinition("isOwn", Some("True if the property is owned for the object."), None, None, Some(True), PrimitiveType("boolean")), PropertyDefinition("symbol", Some("Property symbol object, if the property is of the `symbol` type."), None, None, Some(True), RefType("RemoteObject"))]))
/// Object internal property descriptor. This property isn't normally visible in JavaScript code.
pub type InternalPropertyDescriptor {
  InternalPropertyDescriptor(name: String, value: option.Option(RemoteObject))
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("name", Some("Conventional property name."), None, None, None, PrimitiveType("string")), PropertyDefinition("value", Some("The value associated with the property."), None, None, Some(True), RefType("RemoteObject"))]))
/// Represents function call argument. Either remote object id `objectId`, primitive `value`,
/// unserializable primitive value or neither of (for undefined) them should be specified.
pub type CallArgument {
  CallArgument(
    value: option.Option(dynamic.Dynamic),
    unserializable_value: option.Option(UnserializableValue),
    object_id: option.Option(RemoteObjectId),
  )
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("value", Some("Primitive value or serializable javascript object."), None, None, Some(True), PrimitiveType("any")), PropertyDefinition("unserializableValue", Some("Primitive value which can not be JSON-stringified."), None, None, Some(True), RefType("UnserializableValue")), PropertyDefinition("objectId", Some("Remote object handle."), None, None, Some(True), RefType("RemoteObjectId"))]))
/// Id of an execution context.
pub type ExecutionContextId {
  ExecutionContextId(Int)
}

@internal
pub fn encode__execution_context_id(value: ExecutionContextId) {
  case value {
    ExecutionContextId(inner_value) -> json.int(inner_value)
  }
}

/// Description of an isolated world.
pub type ExecutionContextDescription {
  ExecutionContextDescription(
    id: ExecutionContextId,
    origin: String,
    name: String,
    aux_data: option.Option(dict.Dict(String, String)),
  )
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("id", Some("Unique id of the execution context. It can be used to specify in which execution context\nscript evaluation should be performed."), None, None, None, RefType("ExecutionContextId")), PropertyDefinition("origin", Some("Execution context origin."), None, None, None, PrimitiveType("string")), PropertyDefinition("name", Some("Human readable name describing given context."), None, None, None, PrimitiveType("string")), PropertyDefinition("auxData", Some("Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}"), None, None, Some(True), ObjectType(None))]))
/// Detailed information about exception (or error) that was thrown during script compilation or
/// execution.
pub type ExceptionDetails {
  ExceptionDetails(
    exception_id: Int,
    text: String,
    line_number: Int,
    column_number: Int,
    script_id: option.Option(ScriptId),
    url: option.Option(String),
    stack_trace: option.Option(StackTrace),
    exception: option.Option(RemoteObject),
    execution_context_id: option.Option(ExecutionContextId),
  )
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("exceptionId", Some("Exception id."), None, None, None, PrimitiveType("integer")), PropertyDefinition("text", Some("Exception text, which should be used together with exception object when available."), None, None, None, PrimitiveType("string")), PropertyDefinition("lineNumber", Some("Line number of the exception location (0-based)."), None, None, None, PrimitiveType("integer")), PropertyDefinition("columnNumber", Some("Column number of the exception location (0-based)."), None, None, None, PrimitiveType("integer")), PropertyDefinition("scriptId", Some("Script ID of the exception location."), None, None, Some(True), RefType("ScriptId")), PropertyDefinition("url", Some("URL of the exception location, to be used when the script was not reported."), None, None, Some(True), PrimitiveType("string")), PropertyDefinition("stackTrace", Some("JavaScript stack trace if available."), None, None, Some(True), RefType("StackTrace")), PropertyDefinition("exception", Some("Exception object if available."), None, None, Some(True), RefType("RemoteObject")), PropertyDefinition("executionContextId", Some("Identifier of the context where exception happened."), None, None, Some(True), RefType("ExecutionContextId"))]))
/// Number of milliseconds since epoch.
pub type Timestamp {
  Timestamp(Float)
}

@internal
pub fn encode__timestamp(value: Timestamp) {
  case value {
    Timestamp(inner_value) -> json.float(inner_value)
  }
}

/// Number of milliseconds.
pub type TimeDelta {
  TimeDelta(Float)
}

@internal
pub fn encode__time_delta(value: TimeDelta) {
  case value {
    TimeDelta(inner_value) -> json.float(inner_value)
  }
}

/// Stack entry for runtime errors and assertions.
pub type CallFrame {
  CallFrame(
    function_name: String,
    script_id: ScriptId,
    url: String,
    line_number: Int,
    column_number: Int,
  )
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("functionName", Some("JavaScript function name."), None, None, None, PrimitiveType("string")), PropertyDefinition("scriptId", Some("JavaScript script id."), None, None, None, RefType("ScriptId")), PropertyDefinition("url", Some("JavaScript script name or url."), None, None, None, PrimitiveType("string")), PropertyDefinition("lineNumber", Some("JavaScript script line number (0-based)."), None, None, None, PrimitiveType("integer")), PropertyDefinition("columnNumber", Some("JavaScript script column number (0-based)."), None, None, None, PrimitiveType("integer"))]))
/// Call frames for assertions or error messages.
pub type StackTrace {
  StackTrace(
    description: option.Option(String),
    call_frames: List(CallFrame),
    parent: option.Option(StackTrace),
  )
}
// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("description", Some("String label of this stack trace. For async traces this may be a name of the function that\ninitiated the async call."), None, None, Some(True), PrimitiveType("string")), PropertyDefinition("callFrames", Some("JavaScript function name."), None, None, None, ArrayType(ReferenceItem("CallFrame"))), PropertyDefinition("parent", Some("Asynchronous JavaScript stack trace that preceded this stack, if available."), None, None, Some(True), RefType("StackTrace"))]))
