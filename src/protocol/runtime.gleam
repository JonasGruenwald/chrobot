//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Runtime Domain  
////
//// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
//// Evaluation results are returned as mirror object that expose object type, string representation
//// and unique identifier that can be used for further object reference. Original objects are
//// maintained in memory unless they are either explicitly released or are released along with the
//// other objects in their object group.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import chrobot/internal/utils
import chrome
import gleam/dict
import gleam/dynamic
import gleam/json
import gleam/list
import gleam/option
import gleam/result

/// Unique script identifier.
pub type ScriptId {
  ScriptId(String)
}

@internal
pub fn encode__script_id(value__: ScriptId) {
  case value__ {
    ScriptId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__script_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(ScriptId, dynamic.string)
}

/// Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
pub type SerializationOptions {
  SerializationOptions(
    serialization: SerializationOptionsSerialization,
    max_depth: option.Option(Int),
    additional_parameters: option.Option(dict.Dict(String, String)),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `serialization` of `SerializationOptions`
pub type SerializationOptionsSerialization {
  SerializationOptionsSerializationDeep
  SerializationOptionsSerializationJson
  SerializationOptionsSerializationIdOnly
}

@internal
pub fn encode__serialization_options_serialization(value__: SerializationOptionsSerialization) {
  case value__ {
    SerializationOptionsSerializationDeep -> "deep"
    SerializationOptionsSerializationJson -> "json"
    SerializationOptionsSerializationIdOnly -> "idOnly"
  }
  |> json.string()
}

@internal
pub fn decode__serialization_options_serialization(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("deep") -> Ok(SerializationOptionsSerializationDeep)
    Ok("json") -> Ok(SerializationOptionsSerializationJson)
    Ok("idOnly") -> Ok(SerializationOptionsSerializationIdOnly)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

@internal
pub fn encode__serialization_options(value__: SerializationOptions) {
  json.object(
    [
      #(
        "serialization",
        encode__serialization_options_serialization(value__.serialization),
      ),
    ]
    |> utils.add_optional(value__.max_depth, fn(inner_value__) {
      #("maxDepth", json.int(inner_value__))
    })
    |> utils.add_optional(value__.additional_parameters, fn(inner_value__) {
      #(
        "additionalParameters",
        dict.to_list(inner_value__)
          |> list.map(fn(i) { #(i.0, json.string(i.1)) })
          |> json.object,
      )
    }),
  )
}

@internal
pub fn decode__serialization_options(value__: dynamic.Dynamic) {
  use serialization <- result.try(dynamic.field(
    "serialization",
    decode__serialization_options_serialization,
  )(value__))
  use max_depth <- result.try(dynamic.optional_field("maxDepth", dynamic.int)(
    value__,
  ))
  use additional_parameters <- result.try(dynamic.optional_field(
    "additionalParameters",
    dynamic.dict(dynamic.string, dynamic.string),
  )(value__))

  Ok(SerializationOptions(
    serialization: serialization,
    max_depth: max_depth,
    additional_parameters: additional_parameters,
  ))
}

/// Represents deep serialized value.
pub type DeepSerializedValue {
  DeepSerializedValue(
    type_: DeepSerializedValueType,
    value: option.Option(dynamic.Dynamic),
    object_id: option.Option(String),
    weak_local_object_reference: option.Option(Int),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `DeepSerializedValue`
pub type DeepSerializedValueType {
  DeepSerializedValueTypeUndefined
  DeepSerializedValueTypeNull
  DeepSerializedValueTypeString
  DeepSerializedValueTypeNumber
  DeepSerializedValueTypeBoolean
  DeepSerializedValueTypeBigint
  DeepSerializedValueTypeRegexp
  DeepSerializedValueTypeDate
  DeepSerializedValueTypeSymbol
  DeepSerializedValueTypeArray
  DeepSerializedValueTypeObject
  DeepSerializedValueTypeFunction
  DeepSerializedValueTypeMap
  DeepSerializedValueTypeSet
  DeepSerializedValueTypeWeakmap
  DeepSerializedValueTypeWeakset
  DeepSerializedValueTypeError
  DeepSerializedValueTypeProxy
  DeepSerializedValueTypePromise
  DeepSerializedValueTypeTypedarray
  DeepSerializedValueTypeArraybuffer
  DeepSerializedValueTypeNode
  DeepSerializedValueTypeWindow
  DeepSerializedValueTypeGenerator
}

@internal
pub fn encode__deep_serialized_value_type(value__: DeepSerializedValueType) {
  case value__ {
    DeepSerializedValueTypeUndefined -> "undefined"
    DeepSerializedValueTypeNull -> "null"
    DeepSerializedValueTypeString -> "string"
    DeepSerializedValueTypeNumber -> "number"
    DeepSerializedValueTypeBoolean -> "boolean"
    DeepSerializedValueTypeBigint -> "bigint"
    DeepSerializedValueTypeRegexp -> "regexp"
    DeepSerializedValueTypeDate -> "date"
    DeepSerializedValueTypeSymbol -> "symbol"
    DeepSerializedValueTypeArray -> "array"
    DeepSerializedValueTypeObject -> "object"
    DeepSerializedValueTypeFunction -> "function"
    DeepSerializedValueTypeMap -> "map"
    DeepSerializedValueTypeSet -> "set"
    DeepSerializedValueTypeWeakmap -> "weakmap"
    DeepSerializedValueTypeWeakset -> "weakset"
    DeepSerializedValueTypeError -> "error"
    DeepSerializedValueTypeProxy -> "proxy"
    DeepSerializedValueTypePromise -> "promise"
    DeepSerializedValueTypeTypedarray -> "typedarray"
    DeepSerializedValueTypeArraybuffer -> "arraybuffer"
    DeepSerializedValueTypeNode -> "node"
    DeepSerializedValueTypeWindow -> "window"
    DeepSerializedValueTypeGenerator -> "generator"
  }
  |> json.string()
}

@internal
pub fn decode__deep_serialized_value_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("undefined") -> Ok(DeepSerializedValueTypeUndefined)
    Ok("null") -> Ok(DeepSerializedValueTypeNull)
    Ok("string") -> Ok(DeepSerializedValueTypeString)
    Ok("number") -> Ok(DeepSerializedValueTypeNumber)
    Ok("boolean") -> Ok(DeepSerializedValueTypeBoolean)
    Ok("bigint") -> Ok(DeepSerializedValueTypeBigint)
    Ok("regexp") -> Ok(DeepSerializedValueTypeRegexp)
    Ok("date") -> Ok(DeepSerializedValueTypeDate)
    Ok("symbol") -> Ok(DeepSerializedValueTypeSymbol)
    Ok("array") -> Ok(DeepSerializedValueTypeArray)
    Ok("object") -> Ok(DeepSerializedValueTypeObject)
    Ok("function") -> Ok(DeepSerializedValueTypeFunction)
    Ok("map") -> Ok(DeepSerializedValueTypeMap)
    Ok("set") -> Ok(DeepSerializedValueTypeSet)
    Ok("weakmap") -> Ok(DeepSerializedValueTypeWeakmap)
    Ok("weakset") -> Ok(DeepSerializedValueTypeWeakset)
    Ok("error") -> Ok(DeepSerializedValueTypeError)
    Ok("proxy") -> Ok(DeepSerializedValueTypeProxy)
    Ok("promise") -> Ok(DeepSerializedValueTypePromise)
    Ok("typedarray") -> Ok(DeepSerializedValueTypeTypedarray)
    Ok("arraybuffer") -> Ok(DeepSerializedValueTypeArraybuffer)
    Ok("node") -> Ok(DeepSerializedValueTypeNode)
    Ok("window") -> Ok(DeepSerializedValueTypeWindow)
    Ok("generator") -> Ok(DeepSerializedValueTypeGenerator)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

@internal
pub fn encode__deep_serialized_value(value__: DeepSerializedValue) {
  json.object(
    [#("type", encode__deep_serialized_value_type(value__.type_))]
    |> utils.add_optional(value__.value, fn(inner_value__) {
      #(
        "value",
        // dynamic values cannot be encoded!
        json.null(),
      )
    })
    |> utils.add_optional(value__.object_id, fn(inner_value__) {
      #("objectId", json.string(inner_value__))
    })
    |> utils.add_optional(
      value__.weak_local_object_reference,
      fn(inner_value__) {
        #("weakLocalObjectReference", json.int(inner_value__))
      },
    ),
  )
}

@internal
pub fn decode__deep_serialized_value(value__: dynamic.Dynamic) {
  use type_ <- result.try(dynamic.field(
    "type",
    decode__deep_serialized_value_type,
  )(value__))
  use value <- result.try(dynamic.optional_field("value", dynamic.dynamic)(
    value__,
  ))
  use object_id <- result.try(dynamic.optional_field("objectId", dynamic.string)(
    value__,
  ))
  use weak_local_object_reference <- result.try(dynamic.optional_field(
    "weakLocalObjectReference",
    dynamic.int,
  )(value__))

  Ok(DeepSerializedValue(
    type_: type_,
    value: value,
    object_id: object_id,
    weak_local_object_reference: weak_local_object_reference,
  ))
}

/// Unique object identifier.
pub type RemoteObjectId {
  RemoteObjectId(String)
}

@internal
pub fn encode__remote_object_id(value__: RemoteObjectId) {
  case value__ {
    RemoteObjectId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__remote_object_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(RemoteObjectId, dynamic.string)
}

/// Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
/// `-Infinity`, and bigint literals.
pub type UnserializableValue {
  UnserializableValue(String)
}

@internal
pub fn encode__unserializable_value(value__: UnserializableValue) {
  case value__ {
    UnserializableValue(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__unserializable_value(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(UnserializableValue, dynamic.string)
}

/// Mirror object referencing original JavaScript object.
pub type RemoteObject {
  RemoteObject(
    type_: RemoteObjectType,
    subtype: option.Option(RemoteObjectSubtype),
    class_name: option.Option(String),
    value: option.Option(dynamic.Dynamic),
    unserializable_value: option.Option(UnserializableValue),
    description: option.Option(String),
    object_id: option.Option(RemoteObjectId),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `RemoteObject`
pub type RemoteObjectType {
  RemoteObjectTypeObject
  RemoteObjectTypeFunction
  RemoteObjectTypeUndefined
  RemoteObjectTypeString
  RemoteObjectTypeNumber
  RemoteObjectTypeBoolean
  RemoteObjectTypeSymbol
  RemoteObjectTypeBigint
}

@internal
pub fn encode__remote_object_type(value__: RemoteObjectType) {
  case value__ {
    RemoteObjectTypeObject -> "object"
    RemoteObjectTypeFunction -> "function"
    RemoteObjectTypeUndefined -> "undefined"
    RemoteObjectTypeString -> "string"
    RemoteObjectTypeNumber -> "number"
    RemoteObjectTypeBoolean -> "boolean"
    RemoteObjectTypeSymbol -> "symbol"
    RemoteObjectTypeBigint -> "bigint"
  }
  |> json.string()
}

@internal
pub fn decode__remote_object_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("object") -> Ok(RemoteObjectTypeObject)
    Ok("function") -> Ok(RemoteObjectTypeFunction)
    Ok("undefined") -> Ok(RemoteObjectTypeUndefined)
    Ok("string") -> Ok(RemoteObjectTypeString)
    Ok("number") -> Ok(RemoteObjectTypeNumber)
    Ok("boolean") -> Ok(RemoteObjectTypeBoolean)
    Ok("symbol") -> Ok(RemoteObjectTypeSymbol)
    Ok("bigint") -> Ok(RemoteObjectTypeBigint)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `subtype` of `RemoteObject`
pub type RemoteObjectSubtype {
  RemoteObjectSubtypeArray
  RemoteObjectSubtypeNull
  RemoteObjectSubtypeNode
  RemoteObjectSubtypeRegexp
  RemoteObjectSubtypeDate
  RemoteObjectSubtypeMap
  RemoteObjectSubtypeSet
  RemoteObjectSubtypeWeakmap
  RemoteObjectSubtypeWeakset
  RemoteObjectSubtypeIterator
  RemoteObjectSubtypeGenerator
  RemoteObjectSubtypeError
  RemoteObjectSubtypeProxy
  RemoteObjectSubtypePromise
  RemoteObjectSubtypeTypedarray
  RemoteObjectSubtypeArraybuffer
  RemoteObjectSubtypeDataview
  RemoteObjectSubtypeWebassemblymemory
  RemoteObjectSubtypeWasmvalue
}

@internal
pub fn encode__remote_object_subtype(value__: RemoteObjectSubtype) {
  case value__ {
    RemoteObjectSubtypeArray -> "array"
    RemoteObjectSubtypeNull -> "null"
    RemoteObjectSubtypeNode -> "node"
    RemoteObjectSubtypeRegexp -> "regexp"
    RemoteObjectSubtypeDate -> "date"
    RemoteObjectSubtypeMap -> "map"
    RemoteObjectSubtypeSet -> "set"
    RemoteObjectSubtypeWeakmap -> "weakmap"
    RemoteObjectSubtypeWeakset -> "weakset"
    RemoteObjectSubtypeIterator -> "iterator"
    RemoteObjectSubtypeGenerator -> "generator"
    RemoteObjectSubtypeError -> "error"
    RemoteObjectSubtypeProxy -> "proxy"
    RemoteObjectSubtypePromise -> "promise"
    RemoteObjectSubtypeTypedarray -> "typedarray"
    RemoteObjectSubtypeArraybuffer -> "arraybuffer"
    RemoteObjectSubtypeDataview -> "dataview"
    RemoteObjectSubtypeWebassemblymemory -> "webassemblymemory"
    RemoteObjectSubtypeWasmvalue -> "wasmvalue"
  }
  |> json.string()
}

@internal
pub fn decode__remote_object_subtype(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("array") -> Ok(RemoteObjectSubtypeArray)
    Ok("null") -> Ok(RemoteObjectSubtypeNull)
    Ok("node") -> Ok(RemoteObjectSubtypeNode)
    Ok("regexp") -> Ok(RemoteObjectSubtypeRegexp)
    Ok("date") -> Ok(RemoteObjectSubtypeDate)
    Ok("map") -> Ok(RemoteObjectSubtypeMap)
    Ok("set") -> Ok(RemoteObjectSubtypeSet)
    Ok("weakmap") -> Ok(RemoteObjectSubtypeWeakmap)
    Ok("weakset") -> Ok(RemoteObjectSubtypeWeakset)
    Ok("iterator") -> Ok(RemoteObjectSubtypeIterator)
    Ok("generator") -> Ok(RemoteObjectSubtypeGenerator)
    Ok("error") -> Ok(RemoteObjectSubtypeError)
    Ok("proxy") -> Ok(RemoteObjectSubtypeProxy)
    Ok("promise") -> Ok(RemoteObjectSubtypePromise)
    Ok("typedarray") -> Ok(RemoteObjectSubtypeTypedarray)
    Ok("arraybuffer") -> Ok(RemoteObjectSubtypeArraybuffer)
    Ok("dataview") -> Ok(RemoteObjectSubtypeDataview)
    Ok("webassemblymemory") -> Ok(RemoteObjectSubtypeWebassemblymemory)
    Ok("wasmvalue") -> Ok(RemoteObjectSubtypeWasmvalue)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

@internal
pub fn encode__remote_object(value__: RemoteObject) {
  json.object(
    [#("type", encode__remote_object_type(value__.type_))]
    |> utils.add_optional(value__.subtype, fn(inner_value__) {
      #("subtype", encode__remote_object_subtype(inner_value__))
    })
    |> utils.add_optional(value__.class_name, fn(inner_value__) {
      #("className", json.string(inner_value__))
    })
    |> utils.add_optional(value__.value, fn(inner_value__) {
      #(
        "value",
        // dynamic values cannot be encoded!
        json.null(),
      )
    })
    |> utils.add_optional(value__.unserializable_value, fn(inner_value__) {
      #("unserializableValue", encode__unserializable_value(inner_value__))
    })
    |> utils.add_optional(value__.description, fn(inner_value__) {
      #("description", json.string(inner_value__))
    })
    |> utils.add_optional(value__.object_id, fn(inner_value__) {
      #("objectId", encode__remote_object_id(inner_value__))
    }),
  )
}

@internal
pub fn decode__remote_object(value__: dynamic.Dynamic) {
  use type_ <- result.try(dynamic.field("type", decode__remote_object_type)(
    value__,
  ))
  use subtype <- result.try(dynamic.optional_field(
    "subtype",
    decode__remote_object_subtype,
  )(value__))
  use class_name <- result.try(dynamic.optional_field(
    "className",
    dynamic.string,
  )(value__))
  use value <- result.try(dynamic.optional_field("value", dynamic.dynamic)(
    value__,
  ))
  use unserializable_value <- result.try(dynamic.optional_field(
    "unserializableValue",
    decode__unserializable_value,
  )(value__))
  use description <- result.try(dynamic.optional_field(
    "description",
    dynamic.string,
  )(value__))
  use object_id <- result.try(dynamic.optional_field(
    "objectId",
    decode__remote_object_id,
  )(value__))

  Ok(RemoteObject(
    type_: type_,
    subtype: subtype,
    class_name: class_name,
    value: value,
    unserializable_value: unserializable_value,
    description: description,
    object_id: object_id,
  ))
}

/// Object property descriptor.
pub type PropertyDescriptor {
  PropertyDescriptor(
    name: String,
    value: option.Option(RemoteObject),
    writable: option.Option(Bool),
    get: option.Option(RemoteObject),
    set: option.Option(RemoteObject),
    configurable: Bool,
    enumerable: Bool,
    was_thrown: option.Option(Bool),
    is_own: option.Option(Bool),
    symbol: option.Option(RemoteObject),
  )
}

@internal
pub fn encode__property_descriptor(value__: PropertyDescriptor) {
  json.object(
    [
      #("name", json.string(value__.name)),
      #("configurable", json.bool(value__.configurable)),
      #("enumerable", json.bool(value__.enumerable)),
    ]
    |> utils.add_optional(value__.value, fn(inner_value__) {
      #("value", encode__remote_object(inner_value__))
    })
    |> utils.add_optional(value__.writable, fn(inner_value__) {
      #("writable", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.get, fn(inner_value__) {
      #("get", encode__remote_object(inner_value__))
    })
    |> utils.add_optional(value__.set, fn(inner_value__) {
      #("set", encode__remote_object(inner_value__))
    })
    |> utils.add_optional(value__.was_thrown, fn(inner_value__) {
      #("wasThrown", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.is_own, fn(inner_value__) {
      #("isOwn", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.symbol, fn(inner_value__) {
      #("symbol", encode__remote_object(inner_value__))
    }),
  )
}

@internal
pub fn decode__property_descriptor(value__: dynamic.Dynamic) {
  use name <- result.try(dynamic.field("name", dynamic.string)(value__))
  use value <- result.try(dynamic.optional_field("value", decode__remote_object)(
    value__,
  ))
  use writable <- result.try(dynamic.optional_field("writable", dynamic.bool)(
    value__,
  ))
  use get <- result.try(dynamic.optional_field("get", decode__remote_object)(
    value__,
  ))
  use set <- result.try(dynamic.optional_field("set", decode__remote_object)(
    value__,
  ))
  use configurable <- result.try(dynamic.field("configurable", dynamic.bool)(
    value__,
  ))
  use enumerable <- result.try(dynamic.field("enumerable", dynamic.bool)(
    value__,
  ))
  use was_thrown <- result.try(dynamic.optional_field("wasThrown", dynamic.bool)(
    value__,
  ))
  use is_own <- result.try(dynamic.optional_field("isOwn", dynamic.bool)(
    value__,
  ))
  use symbol <- result.try(dynamic.optional_field(
    "symbol",
    decode__remote_object,
  )(value__))

  Ok(PropertyDescriptor(
    name: name,
    value: value,
    writable: writable,
    get: get,
    set: set,
    configurable: configurable,
    enumerable: enumerable,
    was_thrown: was_thrown,
    is_own: is_own,
    symbol: symbol,
  ))
}

/// Object internal property descriptor. This property isn't normally visible in JavaScript code.
pub type InternalPropertyDescriptor {
  InternalPropertyDescriptor(name: String, value: option.Option(RemoteObject))
}

@internal
pub fn encode__internal_property_descriptor(value__: InternalPropertyDescriptor) {
  json.object(
    [#("name", json.string(value__.name))]
    |> utils.add_optional(value__.value, fn(inner_value__) {
      #("value", encode__remote_object(inner_value__))
    }),
  )
}

@internal
pub fn decode__internal_property_descriptor(value__: dynamic.Dynamic) {
  use name <- result.try(dynamic.field("name", dynamic.string)(value__))
  use value <- result.try(dynamic.optional_field("value", decode__remote_object)(
    value__,
  ))

  Ok(InternalPropertyDescriptor(name: name, value: value))
}

/// Represents function call argument. Either remote object id `objectId`, primitive `value`,
/// unserializable primitive value or neither of (for undefined) them should be specified.
pub type CallArgument {
  CallArgument(
    value: option.Option(dynamic.Dynamic),
    unserializable_value: option.Option(UnserializableValue),
    object_id: option.Option(RemoteObjectId),
  )
}

@internal
pub fn encode__call_argument(value__: CallArgument) {
  json.object(
    []
    |> utils.add_optional(value__.value, fn(inner_value__) {
      #(
        "value",
        // dynamic values cannot be encoded!
        json.null(),
      )
    })
    |> utils.add_optional(value__.unserializable_value, fn(inner_value__) {
      #("unserializableValue", encode__unserializable_value(inner_value__))
    })
    |> utils.add_optional(value__.object_id, fn(inner_value__) {
      #("objectId", encode__remote_object_id(inner_value__))
    }),
  )
}

@internal
pub fn decode__call_argument(value__: dynamic.Dynamic) {
  use value <- result.try(dynamic.optional_field("value", dynamic.dynamic)(
    value__,
  ))
  use unserializable_value <- result.try(dynamic.optional_field(
    "unserializableValue",
    decode__unserializable_value,
  )(value__))
  use object_id <- result.try(dynamic.optional_field(
    "objectId",
    decode__remote_object_id,
  )(value__))

  Ok(CallArgument(
    value: value,
    unserializable_value: unserializable_value,
    object_id: object_id,
  ))
}

/// Id of an execution context.
pub type ExecutionContextId {
  ExecutionContextId(Int)
}

@internal
pub fn encode__execution_context_id(value__: ExecutionContextId) {
  case value__ {
    ExecutionContextId(inner_value__) -> json.int(inner_value__)
  }
}

@internal
pub fn decode__execution_context_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(ExecutionContextId, dynamic.int)
}

/// Description of an isolated world.
pub type ExecutionContextDescription {
  ExecutionContextDescription(
    id: ExecutionContextId,
    origin: String,
    name: String,
    aux_data: option.Option(dict.Dict(String, String)),
  )
}

@internal
pub fn encode__execution_context_description(value__: ExecutionContextDescription) {
  json.object(
    [
      #("id", encode__execution_context_id(value__.id)),
      #("origin", json.string(value__.origin)),
      #("name", json.string(value__.name)),
    ]
    |> utils.add_optional(value__.aux_data, fn(inner_value__) {
      #(
        "auxData",
        dict.to_list(inner_value__)
          |> list.map(fn(i) { #(i.0, json.string(i.1)) })
          |> json.object,
      )
    }),
  )
}

@internal
pub fn decode__execution_context_description(value__: dynamic.Dynamic) {
  use id <- result.try(dynamic.field("id", decode__execution_context_id)(
    value__,
  ))
  use origin <- result.try(dynamic.field("origin", dynamic.string)(value__))
  use name <- result.try(dynamic.field("name", dynamic.string)(value__))
  use aux_data <- result.try(dynamic.optional_field(
    "auxData",
    dynamic.dict(dynamic.string, dynamic.string),
  )(value__))

  Ok(ExecutionContextDescription(
    id: id,
    origin: origin,
    name: name,
    aux_data: aux_data,
  ))
}

/// Detailed information about exception (or error) that was thrown during script compilation or
/// execution.
pub type ExceptionDetails {
  ExceptionDetails(
    exception_id: Int,
    text: String,
    line_number: Int,
    column_number: Int,
    script_id: option.Option(ScriptId),
    url: option.Option(String),
    stack_trace: option.Option(StackTrace),
    exception: option.Option(RemoteObject),
    execution_context_id: option.Option(ExecutionContextId),
  )
}

@internal
pub fn encode__exception_details(value__: ExceptionDetails) {
  json.object(
    [
      #("exceptionId", json.int(value__.exception_id)),
      #("text", json.string(value__.text)),
      #("lineNumber", json.int(value__.line_number)),
      #("columnNumber", json.int(value__.column_number)),
    ]
    |> utils.add_optional(value__.script_id, fn(inner_value__) {
      #("scriptId", encode__script_id(inner_value__))
    })
    |> utils.add_optional(value__.url, fn(inner_value__) {
      #("url", json.string(inner_value__))
    })
    |> utils.add_optional(value__.stack_trace, fn(inner_value__) {
      #("stackTrace", encode__stack_trace(inner_value__))
    })
    |> utils.add_optional(value__.exception, fn(inner_value__) {
      #("exception", encode__remote_object(inner_value__))
    })
    |> utils.add_optional(value__.execution_context_id, fn(inner_value__) {
      #("executionContextId", encode__execution_context_id(inner_value__))
    }),
  )
}

@internal
pub fn decode__exception_details(value__: dynamic.Dynamic) {
  use exception_id <- result.try(dynamic.field("exceptionId", dynamic.int)(
    value__,
  ))
  use text <- result.try(dynamic.field("text", dynamic.string)(value__))
  use line_number <- result.try(dynamic.field("lineNumber", dynamic.int)(
    value__,
  ))
  use column_number <- result.try(dynamic.field("columnNumber", dynamic.int)(
    value__,
  ))
  use script_id <- result.try(dynamic.optional_field(
    "scriptId",
    decode__script_id,
  )(value__))
  use url <- result.try(dynamic.optional_field("url", dynamic.string)(value__))
  use stack_trace <- result.try(dynamic.optional_field(
    "stackTrace",
    decode__stack_trace,
  )(value__))
  use exception <- result.try(dynamic.optional_field(
    "exception",
    decode__remote_object,
  )(value__))
  use execution_context_id <- result.try(dynamic.optional_field(
    "executionContextId",
    decode__execution_context_id,
  )(value__))

  Ok(ExceptionDetails(
    exception_id: exception_id,
    text: text,
    line_number: line_number,
    column_number: column_number,
    script_id: script_id,
    url: url,
    stack_trace: stack_trace,
    exception: exception,
    execution_context_id: execution_context_id,
  ))
}

/// Number of milliseconds since epoch.
pub type Timestamp {
  Timestamp(Float)
}

@internal
pub fn encode__timestamp(value__: Timestamp) {
  case value__ {
    Timestamp(inner_value__) -> json.float(inner_value__)
  }
}

@internal
pub fn decode__timestamp(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(Timestamp, dynamic.float)
}

/// Number of milliseconds.
pub type TimeDelta {
  TimeDelta(Float)
}

@internal
pub fn encode__time_delta(value__: TimeDelta) {
  case value__ {
    TimeDelta(inner_value__) -> json.float(inner_value__)
  }
}

@internal
pub fn decode__time_delta(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(TimeDelta, dynamic.float)
}

/// Stack entry for runtime errors and assertions.
pub type CallFrame {
  CallFrame(
    function_name: String,
    script_id: ScriptId,
    url: String,
    line_number: Int,
    column_number: Int,
  )
}

@internal
pub fn encode__call_frame(value__: CallFrame) {
  json.object([
    #("functionName", json.string(value__.function_name)),
    #("scriptId", encode__script_id(value__.script_id)),
    #("url", json.string(value__.url)),
    #("lineNumber", json.int(value__.line_number)),
    #("columnNumber", json.int(value__.column_number)),
  ])
}

@internal
pub fn decode__call_frame(value__: dynamic.Dynamic) {
  use function_name <- result.try(dynamic.field("functionName", dynamic.string)(
    value__,
  ))
  use script_id <- result.try(dynamic.field("scriptId", decode__script_id)(
    value__,
  ))
  use url <- result.try(dynamic.field("url", dynamic.string)(value__))
  use line_number <- result.try(dynamic.field("lineNumber", dynamic.int)(
    value__,
  ))
  use column_number <- result.try(dynamic.field("columnNumber", dynamic.int)(
    value__,
  ))

  Ok(CallFrame(
    function_name: function_name,
    script_id: script_id,
    url: url,
    line_number: line_number,
    column_number: column_number,
  ))
}

/// Call frames for assertions or error messages.
pub type StackTrace {
  StackTrace(
    description: option.Option(String),
    call_frames: List(CallFrame),
    parent: option.Option(StackTrace),
  )
}

@internal
pub fn encode__stack_trace(value__: StackTrace) {
  json.object(
    [#("callFrames", json.array(value__.call_frames, of: encode__call_frame))]
    |> utils.add_optional(value__.description, fn(inner_value__) {
      #("description", json.string(inner_value__))
    })
    |> utils.add_optional(value__.parent, fn(inner_value__) {
      #("parent", encode__stack_trace(inner_value__))
    }),
  )
}

@internal
pub fn decode__stack_trace(value__: dynamic.Dynamic) {
  use description <- result.try(dynamic.optional_field(
    "description",
    dynamic.string,
  )(value__))
  use call_frames <- result.try(dynamic.field(
    "callFrames",
    dynamic.list(decode__call_frame),
  )(value__))
  use parent <- result.try(dynamic.optional_field("parent", decode__stack_trace)(
    value__,
  ))

  Ok(StackTrace(
    description: description,
    call_frames: call_frames,
    parent: parent,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `await_promise`
pub type AwaitPromiseResponse {
  AwaitPromiseResponse(
    result: RemoteObject,
    exception_details: option.Option(ExceptionDetails),
  )
}

@internal
pub fn decode__await_promise_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field("result", decode__remote_object)(
    value__,
  ))
  use exception_details <- result.try(dynamic.optional_field(
    "exceptionDetails",
    decode__exception_details,
  )(value__))

  Ok(AwaitPromiseResponse(result: result, exception_details: exception_details))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `call_function_on`
pub type CallFunctionOnResponse {
  CallFunctionOnResponse(
    result: RemoteObject,
    exception_details: option.Option(ExceptionDetails),
  )
}

@internal
pub fn decode__call_function_on_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field("result", decode__remote_object)(
    value__,
  ))
  use exception_details <- result.try(dynamic.optional_field(
    "exceptionDetails",
    decode__exception_details,
  )(value__))

  Ok(CallFunctionOnResponse(
    result: result,
    exception_details: exception_details,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `compile_script`
pub type CompileScriptResponse {
  CompileScriptResponse(
    script_id: option.Option(ScriptId),
    exception_details: option.Option(ExceptionDetails),
  )
}

@internal
pub fn decode__compile_script_response(value__: dynamic.Dynamic) {
  use script_id <- result.try(dynamic.optional_field(
    "scriptId",
    decode__script_id,
  )(value__))
  use exception_details <- result.try(dynamic.optional_field(
    "exceptionDetails",
    decode__exception_details,
  )(value__))

  Ok(CompileScriptResponse(
    script_id: script_id,
    exception_details: exception_details,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `evaluate`
pub type EvaluateResponse {
  EvaluateResponse(
    result: RemoteObject,
    exception_details: option.Option(ExceptionDetails),
  )
}

@internal
pub fn decode__evaluate_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field("result", decode__remote_object)(
    value__,
  ))
  use exception_details <- result.try(dynamic.optional_field(
    "exceptionDetails",
    decode__exception_details,
  )(value__))

  Ok(EvaluateResponse(result: result, exception_details: exception_details))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_properties`
pub type GetPropertiesResponse {
  GetPropertiesResponse(
    result: List(PropertyDescriptor),
    internal_properties: option.Option(List(InternalPropertyDescriptor)),
    exception_details: option.Option(ExceptionDetails),
  )
}

@internal
pub fn decode__get_properties_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field(
    "result",
    dynamic.list(decode__property_descriptor),
  )(value__))
  use internal_properties <- result.try(dynamic.optional_field(
    "internalProperties",
    dynamic.list(decode__internal_property_descriptor),
  )(value__))
  use exception_details <- result.try(dynamic.optional_field(
    "exceptionDetails",
    decode__exception_details,
  )(value__))

  Ok(GetPropertiesResponse(
    result: result,
    internal_properties: internal_properties,
    exception_details: exception_details,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `global_lexical_scope_names`
pub type GlobalLexicalScopeNamesResponse {
  GlobalLexicalScopeNamesResponse(names: List(String))
}

@internal
pub fn decode__global_lexical_scope_names_response(value__: dynamic.Dynamic) {
  use names <- result.try(dynamic.field("names", dynamic.list(dynamic.string))(
    value__,
  ))

  Ok(GlobalLexicalScopeNamesResponse(names: names))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `query_objects`
pub type QueryObjectsResponse {
  QueryObjectsResponse(objects: RemoteObject)
}

@internal
pub fn decode__query_objects_response(value__: dynamic.Dynamic) {
  use objects <- result.try(dynamic.field("objects", decode__remote_object)(
    value__,
  ))

  Ok(QueryObjectsResponse(objects: objects))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `run_script`
pub type RunScriptResponse {
  RunScriptResponse(
    result: RemoteObject,
    exception_details: option.Option(ExceptionDetails),
  )
}

@internal
pub fn decode__run_script_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field("result", decode__remote_object)(
    value__,
  ))
  use exception_details <- result.try(dynamic.optional_field(
    "exceptionDetails",
    decode__exception_details,
  )(value__))

  Ok(RunScriptResponse(result: result, exception_details: exception_details))
}

/// Add handler to promise with given promise object id.
pub fn await_promise(
  callback__,
  promise_object_id: RemoteObjectId,
  return_by_value: option.Option(Bool),
  generate_preview: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Runtime.awaitPromise",
    option.Some(json.object(
      [#("promiseObjectId", encode__remote_object_id(promise_object_id))]
      |> utils.add_optional(return_by_value, fn(inner_value__) {
        #("returnByValue", json.bool(inner_value__))
      })
      |> utils.add_optional(generate_preview, fn(inner_value__) {
        #("generatePreview", json.bool(inner_value__))
      }),
    )),
  ))

  decode__await_promise_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Calls function with given declaration on the given object. Object group of the result is
/// inherited from the target object.
pub fn call_function_on(
  callback__,
  function_declaration: String,
  object_id: option.Option(RemoteObjectId),
  arguments: option.Option(List(CallArgument)),
  silent: option.Option(Bool),
  return_by_value: option.Option(Bool),
  user_gesture: option.Option(Bool),
  await_promise: option.Option(Bool),
  execution_context_id: option.Option(ExecutionContextId),
  object_group: option.Option(String),
) {
  use result__ <- result.try(callback__(
    "Runtime.callFunctionOn",
    option.Some(json.object(
      [#("functionDeclaration", json.string(function_declaration))]
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", encode__remote_object_id(inner_value__))
      })
      |> utils.add_optional(arguments, fn(inner_value__) {
        #("arguments", json.array(inner_value__, of: encode__call_argument))
      })
      |> utils.add_optional(silent, fn(inner_value__) {
        #("silent", json.bool(inner_value__))
      })
      |> utils.add_optional(return_by_value, fn(inner_value__) {
        #("returnByValue", json.bool(inner_value__))
      })
      |> utils.add_optional(user_gesture, fn(inner_value__) {
        #("userGesture", json.bool(inner_value__))
      })
      |> utils.add_optional(await_promise, fn(inner_value__) {
        #("awaitPromise", json.bool(inner_value__))
      })
      |> utils.add_optional(execution_context_id, fn(inner_value__) {
        #("executionContextId", encode__execution_context_id(inner_value__))
      })
      |> utils.add_optional(object_group, fn(inner_value__) {
        #("objectGroup", json.string(inner_value__))
      }),
    )),
  ))

  decode__call_function_on_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Compiles expression.
pub fn compile_script(
  callback__,
  expression: String,
  source_url: String,
  persist_script: Bool,
  execution_context_id: option.Option(ExecutionContextId),
) {
  use result__ <- result.try(callback__(
    "Runtime.compileScript",
    option.Some(json.object(
      [
        #("expression", json.string(expression)),
        #("sourceURL", json.string(source_url)),
        #("persistScript", json.bool(persist_script)),
      ]
      |> utils.add_optional(execution_context_id, fn(inner_value__) {
        #("executionContextId", encode__execution_context_id(inner_value__))
      }),
    )),
  ))

  decode__compile_script_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Disables reporting of execution contexts creation.
pub fn disable(callback__) {
  callback__("Runtime.disable", option.None)
}

/// Discards collected exceptions and console API calls.
pub fn discard_console_entries(callback__) {
  callback__("Runtime.discardConsoleEntries", option.None)
}

/// Enables reporting of execution contexts creation by means of `executionContextCreated` event.
/// When the reporting gets enabled the event will be sent immediately for each existing execution
/// context.
pub fn enable(callback__) {
  callback__("Runtime.enable", option.None)
}

/// Evaluates expression on global object.
pub fn evaluate(
  callback__,
  expression: String,
  object_group: option.Option(String),
  include_command_line_api: option.Option(Bool),
  silent: option.Option(Bool),
  context_id: option.Option(ExecutionContextId),
  return_by_value: option.Option(Bool),
  user_gesture: option.Option(Bool),
  await_promise: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Runtime.evaluate",
    option.Some(json.object(
      [#("expression", json.string(expression))]
      |> utils.add_optional(object_group, fn(inner_value__) {
        #("objectGroup", json.string(inner_value__))
      })
      |> utils.add_optional(include_command_line_api, fn(inner_value__) {
        #("includeCommandLineAPI", json.bool(inner_value__))
      })
      |> utils.add_optional(silent, fn(inner_value__) {
        #("silent", json.bool(inner_value__))
      })
      |> utils.add_optional(context_id, fn(inner_value__) {
        #("contextId", encode__execution_context_id(inner_value__))
      })
      |> utils.add_optional(return_by_value, fn(inner_value__) {
        #("returnByValue", json.bool(inner_value__))
      })
      |> utils.add_optional(user_gesture, fn(inner_value__) {
        #("userGesture", json.bool(inner_value__))
      })
      |> utils.add_optional(await_promise, fn(inner_value__) {
        #("awaitPromise", json.bool(inner_value__))
      }),
    )),
  ))

  decode__evaluate_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns properties of a given object. Object group of the result is inherited from the target
/// object.
pub fn get_properties(
  callback__,
  object_id: RemoteObjectId,
  own_properties: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Runtime.getProperties",
    option.Some(json.object(
      [#("objectId", encode__remote_object_id(object_id))]
      |> utils.add_optional(own_properties, fn(inner_value__) {
        #("ownProperties", json.bool(inner_value__))
      }),
    )),
  ))

  decode__get_properties_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns all let, const and class variables from global scope.
pub fn global_lexical_scope_names(
  callback__,
  execution_context_id: option.Option(ExecutionContextId),
) {
  use result__ <- result.try(callback__(
    "Runtime.globalLexicalScopeNames",
    option.Some(json.object(
      []
      |> utils.add_optional(execution_context_id, fn(inner_value__) {
        #("executionContextId", encode__execution_context_id(inner_value__))
      }),
    )),
  ))

  decode__global_lexical_scope_names_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// This generated protocol command has no description
pub fn query_objects(
  callback__,
  prototype_object_id: RemoteObjectId,
  object_group: option.Option(String),
) {
  use result__ <- result.try(callback__(
    "Runtime.queryObjects",
    option.Some(json.object(
      [#("prototypeObjectId", encode__remote_object_id(prototype_object_id))]
      |> utils.add_optional(object_group, fn(inner_value__) {
        #("objectGroup", json.string(inner_value__))
      }),
    )),
  ))

  decode__query_objects_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Releases remote object with given id.
pub fn release_object(callback__, object_id: RemoteObjectId) {
  callback__(
    "Runtime.releaseObject",
    option.Some(
      json.object([#("objectId", encode__remote_object_id(object_id))]),
    ),
  )
}

/// Releases all remote objects that belong to a given group.
pub fn release_object_group(callback__, object_group: String) {
  callback__(
    "Runtime.releaseObjectGroup",
    option.Some(json.object([#("objectGroup", json.string(object_group))])),
  )
}

/// Tells inspected instance to run if it was waiting for debugger to attach.
pub fn run_if_waiting_for_debugger(callback__) {
  callback__("Runtime.runIfWaitingForDebugger", option.None)
}

/// Runs script with given id in a given context.
pub fn run_script(
  callback__,
  script_id: ScriptId,
  execution_context_id: option.Option(ExecutionContextId),
  object_group: option.Option(String),
  silent: option.Option(Bool),
  include_command_line_api: option.Option(Bool),
  return_by_value: option.Option(Bool),
  generate_preview: option.Option(Bool),
  await_promise: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Runtime.runScript",
    option.Some(json.object(
      [#("scriptId", encode__script_id(script_id))]
      |> utils.add_optional(execution_context_id, fn(inner_value__) {
        #("executionContextId", encode__execution_context_id(inner_value__))
      })
      |> utils.add_optional(object_group, fn(inner_value__) {
        #("objectGroup", json.string(inner_value__))
      })
      |> utils.add_optional(silent, fn(inner_value__) {
        #("silent", json.bool(inner_value__))
      })
      |> utils.add_optional(include_command_line_api, fn(inner_value__) {
        #("includeCommandLineAPI", json.bool(inner_value__))
      })
      |> utils.add_optional(return_by_value, fn(inner_value__) {
        #("returnByValue", json.bool(inner_value__))
      })
      |> utils.add_optional(generate_preview, fn(inner_value__) {
        #("generatePreview", json.bool(inner_value__))
      })
      |> utils.add_optional(await_promise, fn(inner_value__) {
        #("awaitPromise", json.bool(inner_value__))
      }),
    )),
  ))

  decode__run_script_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Enables or disables async call stacks tracking.
pub fn set_async_call_stack_depth(callback__, max_depth: Int) {
  callback__(
    "Runtime.setAsyncCallStackDepth",
    option.Some(json.object([#("maxDepth", json.int(max_depth))])),
  )
}

/// If executionContextId is empty, adds binding with the given name on the
/// global objects of all inspected contexts, including those created later,
/// bindings survive reloads.
/// Binding function takes exactly one argument, this argument should be string,
/// in case of any other input, function throws an exception.
/// Each binding function call produces Runtime.bindingCalled notification.
pub fn add_binding(
  callback__,
  name: String,
  execution_context_name: option.Option(String),
) {
  callback__(
    "Runtime.addBinding",
    option.Some(json.object(
      [#("name", json.string(name))]
      |> utils.add_optional(execution_context_name, fn(inner_value__) {
        #("executionContextName", json.string(inner_value__))
      }),
    )),
  )
}

/// This method does not remove binding function from global object but
/// unsubscribes current runtime agent from Runtime.bindingCalled notifications.
pub fn remove_binding(callback__, name: String) {
  callback__(
    "Runtime.removeBinding",
    option.Some(json.object([#("name", json.string(name))])),
  )
}
