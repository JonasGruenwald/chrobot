//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Runtime Domain  
////
//// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
//// Evaluation results are returned as mirror object that expose object type, string representation
//// and unique identifier that can be used for further object reference. Original objects are
//// maintained in memory unless they are either explicitly released or are released along with the
//// other objects in their object group.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import chrome
import gleam/dict
import gleam/dynamic
import gleam/json
import gleam/list
import gleam/option
import gleam/result

/// Unique script identifier.
pub type ScriptId {
  ScriptId(String)
}

@internal
pub fn encode__script_id(value__: ScriptId) {
  case value__ {
    ScriptId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__script_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(ScriptId, dynamic.string)
  |> result.replace_error(chrome.ProtocolError)
}

/// Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
pub type SerializationOptions {
  SerializationOptions(
    serialization: SerializationOptionsSerialization,
    max_depth: option.Option(Int),
    additional_parameters: option.Option(dict.Dict(String, String)),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `serialization` of `SerializationOptions`
pub type SerializationOptionsSerialization {
  SerializationOptionsSerializationDeep
  SerializationOptionsSerializationJson
  SerializationOptionsSerializationIdOnly
}

@internal
pub fn encode__serialization_options_serialization(value__: SerializationOptionsSerialization) {
  case value__ {
    SerializationOptionsSerializationDeep -> "deep"
    SerializationOptionsSerializationJson -> "json"
    SerializationOptionsSerializationIdOnly -> "idOnly"
  }
  |> json.string()
}

@internal
pub fn decode__serialization_options_serialization(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("deep") -> Ok(SerializationOptionsSerializationDeep)
    Ok("json") -> Ok(SerializationOptionsSerializationJson)
    Ok("idOnly") -> Ok(SerializationOptionsSerializationIdOnly)
    _ -> Error(chrome.ProtocolError)
  }
}

@internal
pub fn encode__serialization_options(value__: SerializationOptions) {
  json.object([
    #(
      "serialization",
      encode__serialization_options_serialization(value__.serialization),
    ),
    #("maxDepth", {
      case value__.max_depth {
        option.Some(value__) -> json.int(value__)
        option.None -> json.null()
      }
    }),
    #("additionalParameters", {
      case value__.additional_parameters {
        option.Some(value__) ->
          dict.to_list(value__)
          |> list.map(fn(i) { #(i.0, json.string(i.1)) })
          |> json.object
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__serialization_options(value__: dynamic.Dynamic) {
  use serialization <- result.try(
    dynamic.field("serialization", decode__serialization_options_serialization)(
      value__,
    )
    |> result.replace_error(chrome.ProtocolError),
  )
  use max_depth <- result.try(
    dynamic.optional_field("maxDepth", dynamic.int)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use additional_parameters <- result.try(
    dynamic.optional_field(
      "additionalParameters",
      dynamic.dict(dynamic.string, dynamic.string),
    )(value__)
    |> result.replace_error(chrome.ProtocolError),
  )

  SerializationOptions(
    serialization: serialization,
    max_depth: max_depth,
    additional_parameters: additional_parameters,
  )
}

/// Represents deep serialized value.
pub type DeepSerializedValue {
  DeepSerializedValue(
    type_: DeepSerializedValueType,
    value: option.Option(dynamic.Dynamic),
    object_id: option.Option(String),
    weak_local_object_reference: option.Option(Int),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `DeepSerializedValue`
pub type DeepSerializedValueType {
  DeepSerializedValueTypeUndefined
  DeepSerializedValueTypeNull
  DeepSerializedValueTypeString
  DeepSerializedValueTypeNumber
  DeepSerializedValueTypeBoolean
  DeepSerializedValueTypeBigint
  DeepSerializedValueTypeRegexp
  DeepSerializedValueTypeDate
  DeepSerializedValueTypeSymbol
  DeepSerializedValueTypeArray
  DeepSerializedValueTypeObject
  DeepSerializedValueTypeFunction
  DeepSerializedValueTypeMap
  DeepSerializedValueTypeSet
  DeepSerializedValueTypeWeakmap
  DeepSerializedValueTypeWeakset
  DeepSerializedValueTypeError
  DeepSerializedValueTypeProxy
  DeepSerializedValueTypePromise
  DeepSerializedValueTypeTypedarray
  DeepSerializedValueTypeArraybuffer
  DeepSerializedValueTypeNode
  DeepSerializedValueTypeWindow
  DeepSerializedValueTypeGenerator
}

@internal
pub fn encode__deep_serialized_value_type(value__: DeepSerializedValueType) {
  case value__ {
    DeepSerializedValueTypeUndefined -> "undefined"
    DeepSerializedValueTypeNull -> "null"
    DeepSerializedValueTypeString -> "string"
    DeepSerializedValueTypeNumber -> "number"
    DeepSerializedValueTypeBoolean -> "boolean"
    DeepSerializedValueTypeBigint -> "bigint"
    DeepSerializedValueTypeRegexp -> "regexp"
    DeepSerializedValueTypeDate -> "date"
    DeepSerializedValueTypeSymbol -> "symbol"
    DeepSerializedValueTypeArray -> "array"
    DeepSerializedValueTypeObject -> "object"
    DeepSerializedValueTypeFunction -> "function"
    DeepSerializedValueTypeMap -> "map"
    DeepSerializedValueTypeSet -> "set"
    DeepSerializedValueTypeWeakmap -> "weakmap"
    DeepSerializedValueTypeWeakset -> "weakset"
    DeepSerializedValueTypeError -> "error"
    DeepSerializedValueTypeProxy -> "proxy"
    DeepSerializedValueTypePromise -> "promise"
    DeepSerializedValueTypeTypedarray -> "typedarray"
    DeepSerializedValueTypeArraybuffer -> "arraybuffer"
    DeepSerializedValueTypeNode -> "node"
    DeepSerializedValueTypeWindow -> "window"
    DeepSerializedValueTypeGenerator -> "generator"
  }
  |> json.string()
}

@internal
pub fn decode__deep_serialized_value_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("undefined") -> Ok(DeepSerializedValueTypeUndefined)
    Ok("null") -> Ok(DeepSerializedValueTypeNull)
    Ok("string") -> Ok(DeepSerializedValueTypeString)
    Ok("number") -> Ok(DeepSerializedValueTypeNumber)
    Ok("boolean") -> Ok(DeepSerializedValueTypeBoolean)
    Ok("bigint") -> Ok(DeepSerializedValueTypeBigint)
    Ok("regexp") -> Ok(DeepSerializedValueTypeRegexp)
    Ok("date") -> Ok(DeepSerializedValueTypeDate)
    Ok("symbol") -> Ok(DeepSerializedValueTypeSymbol)
    Ok("array") -> Ok(DeepSerializedValueTypeArray)
    Ok("object") -> Ok(DeepSerializedValueTypeObject)
    Ok("function") -> Ok(DeepSerializedValueTypeFunction)
    Ok("map") -> Ok(DeepSerializedValueTypeMap)
    Ok("set") -> Ok(DeepSerializedValueTypeSet)
    Ok("weakmap") -> Ok(DeepSerializedValueTypeWeakmap)
    Ok("weakset") -> Ok(DeepSerializedValueTypeWeakset)
    Ok("error") -> Ok(DeepSerializedValueTypeError)
    Ok("proxy") -> Ok(DeepSerializedValueTypeProxy)
    Ok("promise") -> Ok(DeepSerializedValueTypePromise)
    Ok("typedarray") -> Ok(DeepSerializedValueTypeTypedarray)
    Ok("arraybuffer") -> Ok(DeepSerializedValueTypeArraybuffer)
    Ok("node") -> Ok(DeepSerializedValueTypeNode)
    Ok("window") -> Ok(DeepSerializedValueTypeWindow)
    Ok("generator") -> Ok(DeepSerializedValueTypeGenerator)
    _ -> Error(chrome.ProtocolError)
  }
}

@internal
pub fn encode__deep_serialized_value(value__: DeepSerializedValue) {
  json.object([
    #("type", encode__deep_serialized_value_type(value__.type_)),
    #("value", {
      case value__.value {
        option.Some(value__) ->
          // dynamic values cannot be encoded!
          json.null()

        option.None -> json.null()
      }
    }),
    #("objectId", {
      case value__.object_id {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("weakLocalObjectReference", {
      case value__.weak_local_object_reference {
        option.Some(value__) -> json.int(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__deep_serialized_value(value__: dynamic.Dynamic) {
  use type_ <- result.try(
    dynamic.field("type", decode__deep_serialized_value_type)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use value <- result.try(
    dynamic.optional_field("value", dynamic.dynamic)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use object_id <- result.try(
    dynamic.optional_field("objectId", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use weak_local_object_reference <- result.try(
    dynamic.optional_field("weakLocalObjectReference", dynamic.int)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )

  DeepSerializedValue(
    type_: type_,
    value: value,
    object_id: object_id,
    weak_local_object_reference: weak_local_object_reference,
  )
}

/// Unique object identifier.
pub type RemoteObjectId {
  RemoteObjectId(String)
}

@internal
pub fn encode__remote_object_id(value__: RemoteObjectId) {
  case value__ {
    RemoteObjectId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__remote_object_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(RemoteObjectId, dynamic.string)
  |> result.replace_error(chrome.ProtocolError)
}

/// Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
/// `-Infinity`, and bigint literals.
pub type UnserializableValue {
  UnserializableValue(String)
}

@internal
pub fn encode__unserializable_value(value__: UnserializableValue) {
  case value__ {
    UnserializableValue(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__unserializable_value(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(UnserializableValue, dynamic.string)
  |> result.replace_error(chrome.ProtocolError)
}

/// Mirror object referencing original JavaScript object.
pub type RemoteObject {
  RemoteObject(
    type_: RemoteObjectType,
    subtype: option.Option(RemoteObjectSubtype),
    class_name: option.Option(String),
    value: option.Option(dynamic.Dynamic),
    unserializable_value: option.Option(UnserializableValue),
    description: option.Option(String),
    object_id: option.Option(RemoteObjectId),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `RemoteObject`
pub type RemoteObjectType {
  RemoteObjectTypeObject
  RemoteObjectTypeFunction
  RemoteObjectTypeUndefined
  RemoteObjectTypeString
  RemoteObjectTypeNumber
  RemoteObjectTypeBoolean
  RemoteObjectTypeSymbol
  RemoteObjectTypeBigint
}

@internal
pub fn encode__remote_object_type(value__: RemoteObjectType) {
  case value__ {
    RemoteObjectTypeObject -> "object"
    RemoteObjectTypeFunction -> "function"
    RemoteObjectTypeUndefined -> "undefined"
    RemoteObjectTypeString -> "string"
    RemoteObjectTypeNumber -> "number"
    RemoteObjectTypeBoolean -> "boolean"
    RemoteObjectTypeSymbol -> "symbol"
    RemoteObjectTypeBigint -> "bigint"
  }
  |> json.string()
}

@internal
pub fn decode__remote_object_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("object") -> Ok(RemoteObjectTypeObject)
    Ok("function") -> Ok(RemoteObjectTypeFunction)
    Ok("undefined") -> Ok(RemoteObjectTypeUndefined)
    Ok("string") -> Ok(RemoteObjectTypeString)
    Ok("number") -> Ok(RemoteObjectTypeNumber)
    Ok("boolean") -> Ok(RemoteObjectTypeBoolean)
    Ok("symbol") -> Ok(RemoteObjectTypeSymbol)
    Ok("bigint") -> Ok(RemoteObjectTypeBigint)
    _ -> Error(chrome.ProtocolError)
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `subtype` of `RemoteObject`
pub type RemoteObjectSubtype {
  RemoteObjectSubtypeArray
  RemoteObjectSubtypeNull
  RemoteObjectSubtypeNode
  RemoteObjectSubtypeRegexp
  RemoteObjectSubtypeDate
  RemoteObjectSubtypeMap
  RemoteObjectSubtypeSet
  RemoteObjectSubtypeWeakmap
  RemoteObjectSubtypeWeakset
  RemoteObjectSubtypeIterator
  RemoteObjectSubtypeGenerator
  RemoteObjectSubtypeError
  RemoteObjectSubtypeProxy
  RemoteObjectSubtypePromise
  RemoteObjectSubtypeTypedarray
  RemoteObjectSubtypeArraybuffer
  RemoteObjectSubtypeDataview
  RemoteObjectSubtypeWebassemblymemory
  RemoteObjectSubtypeWasmvalue
}

@internal
pub fn encode__remote_object_subtype(value__: RemoteObjectSubtype) {
  case value__ {
    RemoteObjectSubtypeArray -> "array"
    RemoteObjectSubtypeNull -> "null"
    RemoteObjectSubtypeNode -> "node"
    RemoteObjectSubtypeRegexp -> "regexp"
    RemoteObjectSubtypeDate -> "date"
    RemoteObjectSubtypeMap -> "map"
    RemoteObjectSubtypeSet -> "set"
    RemoteObjectSubtypeWeakmap -> "weakmap"
    RemoteObjectSubtypeWeakset -> "weakset"
    RemoteObjectSubtypeIterator -> "iterator"
    RemoteObjectSubtypeGenerator -> "generator"
    RemoteObjectSubtypeError -> "error"
    RemoteObjectSubtypeProxy -> "proxy"
    RemoteObjectSubtypePromise -> "promise"
    RemoteObjectSubtypeTypedarray -> "typedarray"
    RemoteObjectSubtypeArraybuffer -> "arraybuffer"
    RemoteObjectSubtypeDataview -> "dataview"
    RemoteObjectSubtypeWebassemblymemory -> "webassemblymemory"
    RemoteObjectSubtypeWasmvalue -> "wasmvalue"
  }
  |> json.string()
}

@internal
pub fn decode__remote_object_subtype(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("array") -> Ok(RemoteObjectSubtypeArray)
    Ok("null") -> Ok(RemoteObjectSubtypeNull)
    Ok("node") -> Ok(RemoteObjectSubtypeNode)
    Ok("regexp") -> Ok(RemoteObjectSubtypeRegexp)
    Ok("date") -> Ok(RemoteObjectSubtypeDate)
    Ok("map") -> Ok(RemoteObjectSubtypeMap)
    Ok("set") -> Ok(RemoteObjectSubtypeSet)
    Ok("weakmap") -> Ok(RemoteObjectSubtypeWeakmap)
    Ok("weakset") -> Ok(RemoteObjectSubtypeWeakset)
    Ok("iterator") -> Ok(RemoteObjectSubtypeIterator)
    Ok("generator") -> Ok(RemoteObjectSubtypeGenerator)
    Ok("error") -> Ok(RemoteObjectSubtypeError)
    Ok("proxy") -> Ok(RemoteObjectSubtypeProxy)
    Ok("promise") -> Ok(RemoteObjectSubtypePromise)
    Ok("typedarray") -> Ok(RemoteObjectSubtypeTypedarray)
    Ok("arraybuffer") -> Ok(RemoteObjectSubtypeArraybuffer)
    Ok("dataview") -> Ok(RemoteObjectSubtypeDataview)
    Ok("webassemblymemory") -> Ok(RemoteObjectSubtypeWebassemblymemory)
    Ok("wasmvalue") -> Ok(RemoteObjectSubtypeWasmvalue)
    _ -> Error(chrome.ProtocolError)
  }
}

@internal
pub fn encode__remote_object(value__: RemoteObject) {
  json.object([
    #("type", encode__remote_object_type(value__.type_)),
    #("subtype", {
      case value__.subtype {
        option.Some(value__) -> encode__remote_object_subtype(value__)
        option.None -> json.null()
      }
    }),
    #("className", {
      case value__.class_name {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("value", {
      case value__.value {
        option.Some(value__) ->
          // dynamic values cannot be encoded!
          json.null()

        option.None -> json.null()
      }
    }),
    #("unserializableValue", {
      case value__.unserializable_value {
        option.Some(value__) -> encode__unserializable_value(value__)
        option.None -> json.null()
      }
    }),
    #("description", {
      case value__.description {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("objectId", {
      case value__.object_id {
        option.Some(value__) -> encode__remote_object_id(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__remote_object(value__: dynamic.Dynamic) {
  use type_ <- result.try(
    dynamic.field("type", decode__remote_object_type)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use subtype <- result.try(
    dynamic.optional_field("subtype", decode__remote_object_subtype)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use class_name <- result.try(
    dynamic.optional_field("className", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use value <- result.try(
    dynamic.optional_field("value", dynamic.dynamic)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use unserializable_value <- result.try(
    dynamic.optional_field("unserializableValue", decode__unserializable_value)(
      value__,
    )
    |> result.replace_error(chrome.ProtocolError),
  )
  use description <- result.try(
    dynamic.optional_field("description", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use object_id <- result.try(
    dynamic.optional_field("objectId", decode__remote_object_id)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )

  RemoteObject(
    type_: type_,
    subtype: subtype,
    class_name: class_name,
    value: value,
    unserializable_value: unserializable_value,
    description: description,
    object_id: object_id,
  )
}

/// Object property descriptor.
pub type PropertyDescriptor {
  PropertyDescriptor(
    name: String,
    value: option.Option(RemoteObject),
    writable: option.Option(Bool),
    get: option.Option(RemoteObject),
    set: option.Option(RemoteObject),
    configurable: Bool,
    enumerable: Bool,
    was_thrown: option.Option(Bool),
    is_own: option.Option(Bool),
    symbol: option.Option(RemoteObject),
  )
}

@internal
pub fn encode__property_descriptor(value__: PropertyDescriptor) {
  json.object([
    #("name", json.string(value__.name)),
    #("value", {
      case value__.value {
        option.Some(value__) -> encode__remote_object(value__)
        option.None -> json.null()
      }
    }),
    #("writable", {
      case value__.writable {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
    #("get", {
      case value__.get {
        option.Some(value__) -> encode__remote_object(value__)
        option.None -> json.null()
      }
    }),
    #("set", {
      case value__.set {
        option.Some(value__) -> encode__remote_object(value__)
        option.None -> json.null()
      }
    }),
    #("configurable", json.bool(value__.configurable)),
    #("enumerable", json.bool(value__.enumerable)),
    #("wasThrown", {
      case value__.was_thrown {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
    #("isOwn", {
      case value__.is_own {
        option.Some(value__) -> json.bool(value__)
        option.None -> json.null()
      }
    }),
    #("symbol", {
      case value__.symbol {
        option.Some(value__) -> encode__remote_object(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__property_descriptor(value__: dynamic.Dynamic) {
  use name <- result.try(
    dynamic.field("name", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use value <- result.try(
    dynamic.optional_field("value", decode__remote_object)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use writable <- result.try(
    dynamic.optional_field("writable", dynamic.bool)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use get <- result.try(
    dynamic.optional_field("get", decode__remote_object)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use set <- result.try(
    dynamic.optional_field("set", decode__remote_object)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use configurable <- result.try(
    dynamic.field("configurable", dynamic.bool)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use enumerable <- result.try(
    dynamic.field("enumerable", dynamic.bool)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use was_thrown <- result.try(
    dynamic.optional_field("wasThrown", dynamic.bool)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use is_own <- result.try(
    dynamic.optional_field("isOwn", dynamic.bool)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use symbol <- result.try(
    dynamic.optional_field("symbol", decode__remote_object)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )

  PropertyDescriptor(
    name: name,
    value: value,
    writable: writable,
    get: get,
    set: set,
    configurable: configurable,
    enumerable: enumerable,
    was_thrown: was_thrown,
    is_own: is_own,
    symbol: symbol,
  )
}

/// Object internal property descriptor. This property isn't normally visible in JavaScript code.
pub type InternalPropertyDescriptor {
  InternalPropertyDescriptor(name: String, value: option.Option(RemoteObject))
}

@internal
pub fn encode__internal_property_descriptor(value__: InternalPropertyDescriptor) {
  json.object([
    #("name", json.string(value__.name)),
    #("value", {
      case value__.value {
        option.Some(value__) -> encode__remote_object(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__internal_property_descriptor(value__: dynamic.Dynamic) {
  use name <- result.try(
    dynamic.field("name", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use value <- result.try(
    dynamic.optional_field("value", decode__remote_object)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )

  InternalPropertyDescriptor(name: name, value: value)
}

/// Represents function call argument. Either remote object id `objectId`, primitive `value`,
/// unserializable primitive value or neither of (for undefined) them should be specified.
pub type CallArgument {
  CallArgument(
    value: option.Option(dynamic.Dynamic),
    unserializable_value: option.Option(UnserializableValue),
    object_id: option.Option(RemoteObjectId),
  )
}

@internal
pub fn encode__call_argument(value__: CallArgument) {
  json.object([
    #("value", {
      case value__.value {
        option.Some(value__) ->
          // dynamic values cannot be encoded!
          json.null()

        option.None -> json.null()
      }
    }),
    #("unserializableValue", {
      case value__.unserializable_value {
        option.Some(value__) -> encode__unserializable_value(value__)
        option.None -> json.null()
      }
    }),
    #("objectId", {
      case value__.object_id {
        option.Some(value__) -> encode__remote_object_id(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__call_argument(value__: dynamic.Dynamic) {
  use value <- result.try(
    dynamic.optional_field("value", dynamic.dynamic)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use unserializable_value <- result.try(
    dynamic.optional_field("unserializableValue", decode__unserializable_value)(
      value__,
    )
    |> result.replace_error(chrome.ProtocolError),
  )
  use object_id <- result.try(
    dynamic.optional_field("objectId", decode__remote_object_id)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )

  CallArgument(
    value: value,
    unserializable_value: unserializable_value,
    object_id: object_id,
  )
}

/// Id of an execution context.
pub type ExecutionContextId {
  ExecutionContextId(Int)
}

@internal
pub fn encode__execution_context_id(value__: ExecutionContextId) {
  case value__ {
    ExecutionContextId(inner_value__) -> json.int(inner_value__)
  }
}

@internal
pub fn decode__execution_context_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(ExecutionContextId, dynamic.int)
  |> result.replace_error(chrome.ProtocolError)
}

/// Description of an isolated world.
pub type ExecutionContextDescription {
  ExecutionContextDescription(
    id: ExecutionContextId,
    origin: String,
    name: String,
    aux_data: option.Option(dict.Dict(String, String)),
  )
}

@internal
pub fn encode__execution_context_description(value__: ExecutionContextDescription) {
  json.object([
    #("id", encode__execution_context_id(value__.id)),
    #("origin", json.string(value__.origin)),
    #("name", json.string(value__.name)),
    #("auxData", {
      case value__.aux_data {
        option.Some(value__) ->
          dict.to_list(value__)
          |> list.map(fn(i) { #(i.0, json.string(i.1)) })
          |> json.object
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__execution_context_description(value__: dynamic.Dynamic) {
  use id <- result.try(
    dynamic.field("id", decode__execution_context_id)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use origin <- result.try(
    dynamic.field("origin", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use name <- result.try(
    dynamic.field("name", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use aux_data <- result.try(
    dynamic.optional_field(
      "auxData",
      dynamic.dict(dynamic.string, dynamic.string),
    )(value__)
    |> result.replace_error(chrome.ProtocolError),
  )

  ExecutionContextDescription(
    id: id,
    origin: origin,
    name: name,
    aux_data: aux_data,
  )
}

/// Detailed information about exception (or error) that was thrown during script compilation or
/// execution.
pub type ExceptionDetails {
  ExceptionDetails(
    exception_id: Int,
    text: String,
    line_number: Int,
    column_number: Int,
    script_id: option.Option(ScriptId),
    url: option.Option(String),
    stack_trace: option.Option(StackTrace),
    exception: option.Option(RemoteObject),
    execution_context_id: option.Option(ExecutionContextId),
  )
}

@internal
pub fn encode__exception_details(value__: ExceptionDetails) {
  json.object([
    #("exceptionId", json.int(value__.exception_id)),
    #("text", json.string(value__.text)),
    #("lineNumber", json.int(value__.line_number)),
    #("columnNumber", json.int(value__.column_number)),
    #("scriptId", {
      case value__.script_id {
        option.Some(value__) -> encode__script_id(value__)
        option.None -> json.null()
      }
    }),
    #("url", {
      case value__.url {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("stackTrace", {
      case value__.stack_trace {
        option.Some(value__) -> encode__stack_trace(value__)
        option.None -> json.null()
      }
    }),
    #("exception", {
      case value__.exception {
        option.Some(value__) -> encode__remote_object(value__)
        option.None -> json.null()
      }
    }),
    #("executionContextId", {
      case value__.execution_context_id {
        option.Some(value__) -> encode__execution_context_id(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__exception_details(value__: dynamic.Dynamic) {
  use exception_id <- result.try(
    dynamic.field("exceptionId", dynamic.int)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use text <- result.try(
    dynamic.field("text", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use line_number <- result.try(
    dynamic.field("lineNumber", dynamic.int)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use column_number <- result.try(
    dynamic.field("columnNumber", dynamic.int)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use script_id <- result.try(
    dynamic.optional_field("scriptId", decode__script_id)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use url <- result.try(
    dynamic.optional_field("url", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use stack_trace <- result.try(
    dynamic.optional_field("stackTrace", decode__stack_trace)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use exception <- result.try(
    dynamic.optional_field("exception", decode__remote_object)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use execution_context_id <- result.try(
    dynamic.optional_field("executionContextId", decode__execution_context_id)(
      value__,
    )
    |> result.replace_error(chrome.ProtocolError),
  )

  ExceptionDetails(
    exception_id: exception_id,
    text: text,
    line_number: line_number,
    column_number: column_number,
    script_id: script_id,
    url: url,
    stack_trace: stack_trace,
    exception: exception,
    execution_context_id: execution_context_id,
  )
}

/// Number of milliseconds since epoch.
pub type Timestamp {
  Timestamp(Float)
}

@internal
pub fn encode__timestamp(value__: Timestamp) {
  case value__ {
    Timestamp(inner_value__) -> json.float(inner_value__)
  }
}

@internal
pub fn decode__timestamp(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(Timestamp, dynamic.float)
  |> result.replace_error(chrome.ProtocolError)
}

/// Number of milliseconds.
pub type TimeDelta {
  TimeDelta(Float)
}

@internal
pub fn encode__time_delta(value__: TimeDelta) {
  case value__ {
    TimeDelta(inner_value__) -> json.float(inner_value__)
  }
}

@internal
pub fn decode__time_delta(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(TimeDelta, dynamic.float)
  |> result.replace_error(chrome.ProtocolError)
}

/// Stack entry for runtime errors and assertions.
pub type CallFrame {
  CallFrame(
    function_name: String,
    script_id: ScriptId,
    url: String,
    line_number: Int,
    column_number: Int,
  )
}

@internal
pub fn encode__call_frame(value__: CallFrame) {
  json.object([
    #("functionName", json.string(value__.function_name)),
    #("scriptId", encode__script_id(value__.script_id)),
    #("url", json.string(value__.url)),
    #("lineNumber", json.int(value__.line_number)),
    #("columnNumber", json.int(value__.column_number)),
  ])
}

@internal
pub fn decode__call_frame(value__: dynamic.Dynamic) {
  use function_name <- result.try(
    dynamic.field("functionName", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use script_id <- result.try(
    dynamic.field("scriptId", decode__script_id)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use url <- result.try(
    dynamic.field("url", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use line_number <- result.try(
    dynamic.field("lineNumber", dynamic.int)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use column_number <- result.try(
    dynamic.field("columnNumber", dynamic.int)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )

  CallFrame(
    function_name: function_name,
    script_id: script_id,
    url: url,
    line_number: line_number,
    column_number: column_number,
  )
}

/// Call frames for assertions or error messages.
pub type StackTrace {
  StackTrace(
    description: option.Option(String),
    call_frames: List(CallFrame),
    parent: option.Option(StackTrace),
  )
}

@internal
pub fn encode__stack_trace(value__: StackTrace) {
  json.object([
    #("description", {
      case value__.description {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("callFrames", json.array(value__.call_frames, of: encode__call_frame)),
    #("parent", {
      case value__.parent {
        option.Some(value__) -> encode__stack_trace(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__stack_trace(value__: dynamic.Dynamic) {
  use description <- result.try(
    dynamic.optional_field("description", dynamic.string)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use call_frames <- result.try(
    dynamic.field("callFrames", dynamic.list(decode__call_frame))(value__)
    |> result.replace_error(chrome.ProtocolError),
  )
  use parent <- result.try(
    dynamic.optional_field("parent", decode__stack_trace)(value__)
    |> result.replace_error(chrome.ProtocolError),
  )

  StackTrace(description: description, call_frames: call_frames, parent: parent)
}
