//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## DOMDebugger Domain  
////
//// DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
//// execution will stop on these operations as if there was a regular breakpoint set.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/DOMDebugger/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import chrobot/internal/utils
import chrome
import gleam/dynamic
import gleam/json
import gleam/option
import gleam/result
import protocol/dom
import protocol/runtime

/// DOM breakpoint type.
pub type DOMBreakpointType {
  DOMBreakpointTypeSubtreeModified
  DOMBreakpointTypeAttributeModified
  DOMBreakpointTypeNodeRemoved
}

@internal
pub fn encode__dom_breakpoint_type(value__: DOMBreakpointType) {
  case value__ {
    DOMBreakpointTypeSubtreeModified -> "subtree-modified"
    DOMBreakpointTypeAttributeModified -> "attribute-modified"
    DOMBreakpointTypeNodeRemoved -> "node-removed"
  }
  |> json.string()
}

@internal
pub fn decode__dom_breakpoint_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("subtree-modified") -> Ok(DOMBreakpointTypeSubtreeModified)
    Ok("attribute-modified") -> Ok(DOMBreakpointTypeAttributeModified)
    Ok("node-removed") -> Ok(DOMBreakpointTypeNodeRemoved)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Object event listener.
pub type EventListener {
  EventListener(
    type_: String,
    use_capture: Bool,
    passive: Bool,
    once: Bool,
    script_id: runtime.ScriptId,
    line_number: Int,
    column_number: Int,
    handler: option.Option(runtime.RemoteObject),
    original_handler: option.Option(runtime.RemoteObject),
    backend_node_id: option.Option(dom.BackendNodeId),
  )
}

@internal
pub fn encode__event_listener(value__: EventListener) {
  json.object(
    [
      #("type", json.string(value__.type_)),
      #("useCapture", json.bool(value__.use_capture)),
      #("passive", json.bool(value__.passive)),
      #("once", json.bool(value__.once)),
      #("scriptId", runtime.encode__script_id(value__.script_id)),
      #("lineNumber", json.int(value__.line_number)),
      #("columnNumber", json.int(value__.column_number)),
    ]
    |> utils.add_optional(value__.handler, fn(inner_value__) {
      #("handler", runtime.encode__remote_object(inner_value__))
    })
    |> utils.add_optional(value__.original_handler, fn(inner_value__) {
      #("originalHandler", runtime.encode__remote_object(inner_value__))
    })
    |> utils.add_optional(value__.backend_node_id, fn(inner_value__) {
      #("backendNodeId", dom.encode__backend_node_id(inner_value__))
    }),
  )
}

@internal
pub fn decode__event_listener(value__: dynamic.Dynamic) {
  use type_ <- result.try(dynamic.field("type", dynamic.string)(value__))
  use use_capture <- result.try(dynamic.field("useCapture", dynamic.bool)(
    value__,
  ))
  use passive <- result.try(dynamic.field("passive", dynamic.bool)(value__))
  use once <- result.try(dynamic.field("once", dynamic.bool)(value__))
  use script_id <- result.try(dynamic.field(
    "scriptId",
    runtime.decode__script_id,
  )(value__))
  use line_number <- result.try(dynamic.field("lineNumber", dynamic.int)(
    value__,
  ))
  use column_number <- result.try(dynamic.field("columnNumber", dynamic.int)(
    value__,
  ))
  use handler <- result.try(dynamic.optional_field(
    "handler",
    runtime.decode__remote_object,
  )(value__))
  use original_handler <- result.try(dynamic.optional_field(
    "originalHandler",
    runtime.decode__remote_object,
  )(value__))
  use backend_node_id <- result.try(dynamic.optional_field(
    "backendNodeId",
    dom.decode__backend_node_id,
  )(value__))

  Ok(EventListener(
    type_: type_,
    use_capture: use_capture,
    passive: passive,
    once: once,
    script_id: script_id,
    line_number: line_number,
    column_number: column_number,
    handler: handler,
    original_handler: original_handler,
    backend_node_id: backend_node_id,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_event_listeners`
pub type GetEventListenersResponse {
  GetEventListenersResponse(listeners: List(EventListener))
}

@internal
pub fn decode__get_event_listeners_response(value__: dynamic.Dynamic) {
  use listeners <- result.try(dynamic.field(
    "listeners",
    dynamic.list(decode__event_listener),
  )(value__))

  Ok(GetEventListenersResponse(listeners: listeners))
}

/// Returns event listeners of the given object.
pub fn get_event_listeners(
  browser_subject,
  object_id: runtime.RemoteObjectId,
  depth: option.Option(Int),
  pierce: option.Option(Bool),
) {
  chrome.call(
    browser_subject,
    "DOMDebugger.getEventListeners",
    option.Some(json.object(
      [#("objectId", runtime.encode__remote_object_id(object_id))]
      |> utils.add_optional(depth, fn(inner_value__) {
        #("depth", json.int(inner_value__))
      })
      |> utils.add_optional(pierce, fn(inner_value__) {
        #("pierce", json.bool(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__get_event_listeners_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Removes DOM breakpoint that was set using `setDOMBreakpoint`.
pub fn remove_dom_breakpoint(
  browser_subject,
  node_id: dom.NodeId,
  type_: DOMBreakpointType,
) {
  let _ =
    chrome.call(
      browser_subject,
      "DOMDebugger.removeDOMBreakpoint",
      option.Some(
        json.object([
          #("nodeId", dom.encode__node_id(node_id)),
          #("type", encode__dom_breakpoint_type(type_)),
        ]),
      ),
      10_000,
    )
  Nil
}

/// Removes breakpoint on particular DOM event.
pub fn remove_event_listener_breakpoint(browser_subject, event_name: String) {
  let _ =
    chrome.call(
      browser_subject,
      "DOMDebugger.removeEventListenerBreakpoint",
      option.Some(json.object([#("eventName", json.string(event_name))])),
      10_000,
    )
  Nil
}

/// Removes breakpoint from XMLHttpRequest.
pub fn remove_xhr_breakpoint(browser_subject, url: String) {
  let _ =
    chrome.call(
      browser_subject,
      "DOMDebugger.removeXHRBreakpoint",
      option.Some(json.object([#("url", json.string(url))])),
      10_000,
    )
  Nil
}

/// Sets breakpoint on particular operation with DOM.
pub fn set_dom_breakpoint(
  browser_subject,
  node_id: dom.NodeId,
  type_: DOMBreakpointType,
) {
  let _ =
    chrome.call(
      browser_subject,
      "DOMDebugger.setDOMBreakpoint",
      option.Some(
        json.object([
          #("nodeId", dom.encode__node_id(node_id)),
          #("type", encode__dom_breakpoint_type(type_)),
        ]),
      ),
      10_000,
    )
  Nil
}

/// Sets breakpoint on particular DOM event.
pub fn set_event_listener_breakpoint(browser_subject, event_name: String) {
  let _ =
    chrome.call(
      browser_subject,
      "DOMDebugger.setEventListenerBreakpoint",
      option.Some(json.object([#("eventName", json.string(event_name))])),
      10_000,
    )
  Nil
}

/// Sets breakpoint on XMLHttpRequest.
pub fn set_xhr_breakpoint(browser_subject, url: String) {
  let _ =
    chrome.call(
      browser_subject,
      "DOMDebugger.setXHRBreakpoint",
      option.Some(json.object([#("url", json.string(url))])),
      10_000,
    )
  Nil
}
