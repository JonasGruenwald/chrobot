//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Fetch Domain  
////
//// A domain for letting clients substitute browser's network layer with client code.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Fetch/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import chrome
import gleam/dynamic
import gleam/json
import gleam/option
import protocol/io
import protocol/network
import protocol/page

/// Unique request identifier.
pub type RequestId {
  RequestId(String)
}

@internal
pub fn encode__request_id(value: RequestId) {
  case value {
    RequestId(inner_value) -> json.string(inner_value)
  }
}

/// Stages of the request to handle. Request will intercept before the request is
/// sent. Response will intercept after the response is received (but before response
/// body is received).
pub type RequestStage {
  RequestStageRequest
  RequestStageResponse
}

// TODO: implement type encoder for EnumType(["Request", "Response"])
pub type RequestPattern {
  RequestPattern(
    url_pattern: option.Option(String),
    resource_type: option.Option(network.ResourceType),
    request_stage: option.Option(RequestStage),
  )
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("urlPattern", Some("Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is\nbackslash. Omitting is equivalent to `\"*\"`."), None, None, Some(True), PrimitiveType("string")), PropertyDefinition("resourceType", Some("If set, only requests for matching resource types will be intercepted."), None, None, Some(True), RefType("Network.ResourceType")), PropertyDefinition("requestStage", Some("Stage at which to begin intercepting requests. Default is Request."), None, None, Some(True), RefType("RequestStage"))]))
/// Response HTTP header entry
pub type HeaderEntry {
  HeaderEntry(name: String, value: String)
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("name", None, None, None, None, PrimitiveType("string")), PropertyDefinition("value", None, None, None, None, PrimitiveType("string"))]))
/// Authorization challenge for HTTP status code 401 or 407.
pub type AuthChallenge {
  AuthChallenge(
    source: option.Option(AuthChallengeSource),
    origin: String,
    scheme: String,
    realm: String,
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `source` of `AuthChallenge`
pub type AuthChallengeSource {
  AuthChallengeSourceServer
  AuthChallengeSourceProxy
}

@internal
pub fn encode__auth_challenge_source(value: AuthChallengeSource) {
  case value {
    AuthChallengeSourceServer -> "Server"
    AuthChallengeSourceProxy -> "Proxy"
  }
  |> json.string()
}

@internal
pub fn decode__auth_challenge_source(value: dynamic.Dynamic) {
  case dynamic.string(value) {
    Ok("Server") -> Ok(AuthChallengeSourceServer)
    Ok("Proxy") -> Ok(AuthChallengeSourceProxy)
    _ -> Error(chrome.ProtocolError)
  }
}

// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("source", Some("Source of the authentication challenge."), None, None, Some(True), EnumType(["Server", "Proxy"])), PropertyDefinition("origin", Some("Origin of the challenger."), None, None, None, PrimitiveType("string")), PropertyDefinition("scheme", Some("The authentication scheme used, such as basic or digest"), None, None, None, PrimitiveType("string")), PropertyDefinition("realm", Some("The realm of the challenge. May be empty."), None, None, None, PrimitiveType("string"))]))
/// Response to an AuthChallenge.
pub type AuthChallengeResponse {
  AuthChallengeResponse(
    response: AuthChallengeResponseResponse,
    username: option.Option(String),
    password: option.Option(String),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `response` of `AuthChallengeResponse`
pub type AuthChallengeResponseResponse {
  AuthChallengeResponseResponseDefault
  AuthChallengeResponseResponseCancelAuth
  AuthChallengeResponseResponseProvideCredentials
}

@internal
pub fn encode__auth_challenge_response_response(value: AuthChallengeResponseResponse) {
  case value {
    AuthChallengeResponseResponseDefault -> "Default"
    AuthChallengeResponseResponseCancelAuth -> "CancelAuth"
    AuthChallengeResponseResponseProvideCredentials -> "ProvideCredentials"
  }
  |> json.string()
}

@internal
pub fn decode__auth_challenge_response_response(value: dynamic.Dynamic) {
  case dynamic.string(value) {
    Ok("Default") -> Ok(AuthChallengeResponseResponseDefault)
    Ok("CancelAuth") -> Ok(AuthChallengeResponseResponseCancelAuth)
    Ok("ProvideCredentials") ->
      Ok(AuthChallengeResponseResponseProvideCredentials)
    _ -> Error(chrome.ProtocolError)
  }
}
// TODO: implement type encoder for ObjectType(Some([PropertyDefinition("response", Some("The decision on what to do in response to the authorization challenge.  Default means\ndeferring to the default behavior of the net stack, which will likely either the Cancel\nauthentication or display a popup dialog box."), None, None, None, EnumType(["Default", "CancelAuth", "ProvideCredentials"])), PropertyDefinition("username", Some("The username to provide, possibly empty. Should only be set if response is\nProvideCredentials."), None, None, Some(True), PrimitiveType("string")), PropertyDefinition("password", Some("The password to provide, possibly empty. Should only be set if response is\nProvideCredentials."), None, None, Some(True), PrimitiveType("string"))]))
