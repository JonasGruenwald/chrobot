//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Profiler Domain  
////
//// This protocol domain has no description.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Profiler/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import gleam/dynamic
import gleam/json
import gleam/option
import gleam/result
import protocol/debugger
import protocol/runtime

/// Profile node. Holds callsite information, execution statistics and child nodes.
pub type ProfileNode {
  ProfileNode(
    id: Int,
    call_frame: runtime.CallFrame,
    hit_count: option.Option(Int),
    children: option.Option(List(Int)),
    deopt_reason: option.Option(String),
    position_ticks: option.Option(List(PositionTickInfo)),
  )
}

@internal
pub fn encode__profile_node(value__: ProfileNode) {
  json.object([
    #("id", json.int(value__.id)),
    #("callFrame", runtime.encode__call_frame(value__.call_frame)),
    #("hitCount", {
      case value__.hit_count {
        option.Some(value__) -> json.int(value__)
        option.None -> json.null()
      }
    }),
    #("children", {
      case value__.children {
        option.Some(value__) -> json.array(value__, of: json.int)
        option.None -> json.null()
      }
    }),
    #("deoptReason", {
      case value__.deopt_reason {
        option.Some(value__) -> json.string(value__)
        option.None -> json.null()
      }
    }),
    #("positionTicks", {
      case value__.position_ticks {
        option.Some(value__) ->
          json.array(value__, of: encode__position_tick_info)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__profile_node(value__: dynamic.Dynamic) {
  use id <- result.try(dynamic.field("id", dynamic.int)(value__))
  use call_frame <- result.try(dynamic.field(
    "callFrame",
    runtime.decode__call_frame,
  )(value__))
  use hit_count <- result.try(dynamic.optional_field("hitCount", dynamic.int)(
    value__,
  ))
  use children <- result.try(dynamic.optional_field(
    "children",
    dynamic.list(dynamic.int),
  )(value__))
  use deopt_reason <- result.try(dynamic.optional_field(
    "deoptReason",
    dynamic.string,
  )(value__))
  use position_ticks <- result.try(dynamic.optional_field(
    "positionTicks",
    dynamic.list(decode__position_tick_info),
  )(value__))

  Ok(ProfileNode(
    id: id,
    call_frame: call_frame,
    hit_count: hit_count,
    children: children,
    deopt_reason: deopt_reason,
    position_ticks: position_ticks,
  ))
}

/// Profile.
pub type Profile {
  Profile(
    nodes: List(ProfileNode),
    start_time: Float,
    end_time: Float,
    samples: option.Option(List(Int)),
    time_deltas: option.Option(List(Int)),
  )
}

@internal
pub fn encode__profile(value__: Profile) {
  json.object([
    #("nodes", json.array(value__.nodes, of: encode__profile_node)),
    #("startTime", json.float(value__.start_time)),
    #("endTime", json.float(value__.end_time)),
    #("samples", {
      case value__.samples {
        option.Some(value__) -> json.array(value__, of: json.int)
        option.None -> json.null()
      }
    }),
    #("timeDeltas", {
      case value__.time_deltas {
        option.Some(value__) -> json.array(value__, of: json.int)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__profile(value__: dynamic.Dynamic) {
  use nodes <- result.try(dynamic.field(
    "nodes",
    dynamic.list(decode__profile_node),
  )(value__))
  use start_time <- result.try(dynamic.field("startTime", dynamic.float)(
    value__,
  ))
  use end_time <- result.try(dynamic.field("endTime", dynamic.float)(value__))
  use samples <- result.try(dynamic.optional_field(
    "samples",
    dynamic.list(dynamic.int),
  )(value__))
  use time_deltas <- result.try(dynamic.optional_field(
    "timeDeltas",
    dynamic.list(dynamic.int),
  )(value__))

  Ok(Profile(
    nodes: nodes,
    start_time: start_time,
    end_time: end_time,
    samples: samples,
    time_deltas: time_deltas,
  ))
}

/// Specifies a number of samples attributed to a certain source position.
pub type PositionTickInfo {
  PositionTickInfo(line: Int, ticks: Int)
}

@internal
pub fn encode__position_tick_info(value__: PositionTickInfo) {
  json.object([
    #("line", json.int(value__.line)),
    #("ticks", json.int(value__.ticks)),
  ])
}

@internal
pub fn decode__position_tick_info(value__: dynamic.Dynamic) {
  use line <- result.try(dynamic.field("line", dynamic.int)(value__))
  use ticks <- result.try(dynamic.field("ticks", dynamic.int)(value__))

  Ok(PositionTickInfo(line: line, ticks: ticks))
}

/// Coverage data for a source range.
pub type CoverageRange {
  CoverageRange(start_offset: Int, end_offset: Int, count: Int)
}

@internal
pub fn encode__coverage_range(value__: CoverageRange) {
  json.object([
    #("startOffset", json.int(value__.start_offset)),
    #("endOffset", json.int(value__.end_offset)),
    #("count", json.int(value__.count)),
  ])
}

@internal
pub fn decode__coverage_range(value__: dynamic.Dynamic) {
  use start_offset <- result.try(dynamic.field("startOffset", dynamic.int)(
    value__,
  ))
  use end_offset <- result.try(dynamic.field("endOffset", dynamic.int)(value__))
  use count <- result.try(dynamic.field("count", dynamic.int)(value__))

  Ok(CoverageRange(
    start_offset: start_offset,
    end_offset: end_offset,
    count: count,
  ))
}

/// Coverage data for a JavaScript function.
pub type FunctionCoverage {
  FunctionCoverage(
    function_name: String,
    ranges: List(CoverageRange),
    is_block_coverage: Bool,
  )
}

@internal
pub fn encode__function_coverage(value__: FunctionCoverage) {
  json.object([
    #("functionName", json.string(value__.function_name)),
    #("ranges", json.array(value__.ranges, of: encode__coverage_range)),
    #("isBlockCoverage", json.bool(value__.is_block_coverage)),
  ])
}

@internal
pub fn decode__function_coverage(value__: dynamic.Dynamic) {
  use function_name <- result.try(dynamic.field("functionName", dynamic.string)(
    value__,
  ))
  use ranges <- result.try(dynamic.field(
    "ranges",
    dynamic.list(decode__coverage_range),
  )(value__))
  use is_block_coverage <- result.try(dynamic.field(
    "isBlockCoverage",
    dynamic.bool,
  )(value__))

  Ok(FunctionCoverage(
    function_name: function_name,
    ranges: ranges,
    is_block_coverage: is_block_coverage,
  ))
}

/// Coverage data for a JavaScript script.
pub type ScriptCoverage {
  ScriptCoverage(
    script_id: runtime.ScriptId,
    url: String,
    functions: List(FunctionCoverage),
  )
}

@internal
pub fn encode__script_coverage(value__: ScriptCoverage) {
  json.object([
    #("scriptId", runtime.encode__script_id(value__.script_id)),
    #("url", json.string(value__.url)),
    #("functions", json.array(value__.functions, of: encode__function_coverage)),
  ])
}

@internal
pub fn decode__script_coverage(value__: dynamic.Dynamic) {
  use script_id <- result.try(dynamic.field(
    "scriptId",
    runtime.decode__script_id,
  )(value__))
  use url <- result.try(dynamic.field("url", dynamic.string)(value__))
  use functions <- result.try(dynamic.field(
    "functions",
    dynamic.list(decode__function_coverage),
  )(value__))

  Ok(ScriptCoverage(script_id: script_id, url: url, functions: functions))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_best_effort_coverage`
pub type GetBestEffortCoverageResponse {
  GetBestEffortCoverageResponse(result: List(ScriptCoverage))
}

@internal
pub fn decode__get_best_effort_coverage_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field(
    "result",
    dynamic.list(decode__script_coverage),
  )(value__))

  Ok(GetBestEffortCoverageResponse(result: result))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `start_precise_coverage`
pub type StartPreciseCoverageResponse {
  StartPreciseCoverageResponse(timestamp: Float)
}

@internal
pub fn decode__start_precise_coverage_response(value__: dynamic.Dynamic) {
  use timestamp <- result.try(dynamic.field("timestamp", dynamic.float)(value__))

  Ok(StartPreciseCoverageResponse(timestamp: timestamp))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `stop`
pub type StopResponse {
  StopResponse(profile: Profile)
}

@internal
pub fn decode__stop_response(value__: dynamic.Dynamic) {
  use profile <- result.try(dynamic.field("profile", decode__profile)(value__))

  Ok(StopResponse(profile: profile))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `take_precise_coverage`
pub type TakePreciseCoverageResponse {
  TakePreciseCoverageResponse(result: List(ScriptCoverage), timestamp: Float)
}

@internal
pub fn decode__take_precise_coverage_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field(
    "result",
    dynamic.list(decode__script_coverage),
  )(value__))
  use timestamp <- result.try(dynamic.field("timestamp", dynamic.float)(value__))

  Ok(TakePreciseCoverageResponse(result: result, timestamp: timestamp))
}

pub fn disable() {
  todo
  // TODO generate command body
}

pub fn enable() {
  todo
  // TODO generate command body
}

pub fn get_best_effort_coverage() {
  todo
  // TODO generate command body
}

pub fn set_sampling_interval(interval: Int) {
  todo
  // TODO generate command body
}

pub fn start() {
  todo
  // TODO generate command body
}

pub fn start_precise_coverage(
  call_count: option.Option(Bool),
  detailed: option.Option(Bool),
  allow_triggered_updates: option.Option(Bool),
) {
  todo
  // TODO generate command body
}

pub fn stop() {
  todo
  // TODO generate command body
}

pub fn stop_precise_coverage() {
  todo
  // TODO generate command body
}

pub fn take_precise_coverage() {
  todo
  // TODO generate command body
}
