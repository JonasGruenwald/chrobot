//// > âš™ï¸  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Profiler Domain  
////
//// This protocol domain has no description.  
////
//// [ðŸ“–   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Profiler/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import chrobot/internal/utils
import chrome
import gleam/dynamic
import gleam/json
import gleam/option
import gleam/result
import protocol/runtime

/// Profile node. Holds callsite information, execution statistics and child nodes.
pub type ProfileNode {
  ProfileNode(
    /// Unique id of the node.  
    id: Int,
    /// Function location.  
    call_frame: runtime.CallFrame,
    /// Number of samples where this node was on top of the call stack.  
    hit_count: option.Option(Int),
    /// Child node ids.  
    children: option.Option(List(Int)),
    /// The reason of being not optimized. The function may be deoptimized or marked as don't
    /// optimize.  
    deopt_reason: option.Option(String),
    /// An array of source position ticks.  
    position_ticks: option.Option(List(PositionTickInfo)),
  )
}

@internal
pub fn encode__profile_node(value__: ProfileNode) {
  json.object(
    [
      #("id", json.int(value__.id)),
      #("callFrame", runtime.encode__call_frame(value__.call_frame)),
    ]
    |> utils.add_optional(value__.hit_count, fn(inner_value__) {
      #("hitCount", json.int(inner_value__))
    })
    |> utils.add_optional(value__.children, fn(inner_value__) {
      #("children", json.array(inner_value__, of: json.int))
    })
    |> utils.add_optional(value__.deopt_reason, fn(inner_value__) {
      #("deoptReason", json.string(inner_value__))
    })
    |> utils.add_optional(value__.position_ticks, fn(inner_value__) {
      #(
        "positionTicks",
        json.array(inner_value__, of: encode__position_tick_info),
      )
    }),
  )
}

@internal
pub fn decode__profile_node(value__: dynamic.Dynamic) {
  use id <- result.try(dynamic.field("id", dynamic.int)(value__))
  use call_frame <- result.try(dynamic.field(
    "callFrame",
    runtime.decode__call_frame,
  )(value__))
  use hit_count <- result.try(dynamic.optional_field("hitCount", dynamic.int)(
    value__,
  ))
  use children <- result.try(dynamic.optional_field(
    "children",
    dynamic.list(dynamic.int),
  )(value__))
  use deopt_reason <- result.try(dynamic.optional_field(
    "deoptReason",
    dynamic.string,
  )(value__))
  use position_ticks <- result.try(dynamic.optional_field(
    "positionTicks",
    dynamic.list(decode__position_tick_info),
  )(value__))

  Ok(ProfileNode(
    id: id,
    call_frame: call_frame,
    hit_count: hit_count,
    children: children,
    deopt_reason: deopt_reason,
    position_ticks: position_ticks,
  ))
}

/// Profile.
pub type Profile {
  Profile(
    /// The list of profile nodes. First item is the root node.  
    nodes: List(ProfileNode),
    /// Profiling start timestamp in microseconds.  
    start_time: Float,
    /// Profiling end timestamp in microseconds.  
    end_time: Float,
    /// Ids of samples top nodes.  
    samples: option.Option(List(Int)),
    /// Time intervals between adjacent samples in microseconds. The first delta is relative to the
    /// profile startTime.  
    time_deltas: option.Option(List(Int)),
  )
}

@internal
pub fn encode__profile(value__: Profile) {
  json.object(
    [
      #("nodes", json.array(value__.nodes, of: encode__profile_node)),
      #("startTime", json.float(value__.start_time)),
      #("endTime", json.float(value__.end_time)),
    ]
    |> utils.add_optional(value__.samples, fn(inner_value__) {
      #("samples", json.array(inner_value__, of: json.int))
    })
    |> utils.add_optional(value__.time_deltas, fn(inner_value__) {
      #("timeDeltas", json.array(inner_value__, of: json.int))
    }),
  )
}

@internal
pub fn decode__profile(value__: dynamic.Dynamic) {
  use nodes <- result.try(dynamic.field(
    "nodes",
    dynamic.list(decode__profile_node),
  )(value__))
  use start_time <- result.try(dynamic.field("startTime", dynamic.float)(
    value__,
  ))
  use end_time <- result.try(dynamic.field("endTime", dynamic.float)(value__))
  use samples <- result.try(dynamic.optional_field(
    "samples",
    dynamic.list(dynamic.int),
  )(value__))
  use time_deltas <- result.try(dynamic.optional_field(
    "timeDeltas",
    dynamic.list(dynamic.int),
  )(value__))

  Ok(Profile(
    nodes: nodes,
    start_time: start_time,
    end_time: end_time,
    samples: samples,
    time_deltas: time_deltas,
  ))
}

/// Specifies a number of samples attributed to a certain source position.
pub type PositionTickInfo {
  PositionTickInfo(
    /// Source line number (1-based).  
    line: Int,
    /// Number of samples attributed to the source line.  
    ticks: Int,
  )
}

@internal
pub fn encode__position_tick_info(value__: PositionTickInfo) {
  json.object([
    #("line", json.int(value__.line)),
    #("ticks", json.int(value__.ticks)),
  ])
}

@internal
pub fn decode__position_tick_info(value__: dynamic.Dynamic) {
  use line <- result.try(dynamic.field("line", dynamic.int)(value__))
  use ticks <- result.try(dynamic.field("ticks", dynamic.int)(value__))

  Ok(PositionTickInfo(line: line, ticks: ticks))
}

/// Coverage data for a source range.
pub type CoverageRange {
  CoverageRange(
    /// JavaScript script source offset for the range start.  
    start_offset: Int,
    /// JavaScript script source offset for the range end.  
    end_offset: Int,
    /// Collected execution count of the source range.  
    count: Int,
  )
}

@internal
pub fn encode__coverage_range(value__: CoverageRange) {
  json.object([
    #("startOffset", json.int(value__.start_offset)),
    #("endOffset", json.int(value__.end_offset)),
    #("count", json.int(value__.count)),
  ])
}

@internal
pub fn decode__coverage_range(value__: dynamic.Dynamic) {
  use start_offset <- result.try(dynamic.field("startOffset", dynamic.int)(
    value__,
  ))
  use end_offset <- result.try(dynamic.field("endOffset", dynamic.int)(value__))
  use count <- result.try(dynamic.field("count", dynamic.int)(value__))

  Ok(CoverageRange(
    start_offset: start_offset,
    end_offset: end_offset,
    count: count,
  ))
}

/// Coverage data for a JavaScript function.
pub type FunctionCoverage {
  FunctionCoverage(
    /// JavaScript function name.  
    function_name: String,
    /// Source ranges inside the function with coverage data.  
    ranges: List(CoverageRange),
    /// Whether coverage data for this function has block granularity.  
    is_block_coverage: Bool,
  )
}

@internal
pub fn encode__function_coverage(value__: FunctionCoverage) {
  json.object([
    #("functionName", json.string(value__.function_name)),
    #("ranges", json.array(value__.ranges, of: encode__coverage_range)),
    #("isBlockCoverage", json.bool(value__.is_block_coverage)),
  ])
}

@internal
pub fn decode__function_coverage(value__: dynamic.Dynamic) {
  use function_name <- result.try(dynamic.field("functionName", dynamic.string)(
    value__,
  ))
  use ranges <- result.try(dynamic.field(
    "ranges",
    dynamic.list(decode__coverage_range),
  )(value__))
  use is_block_coverage <- result.try(dynamic.field(
    "isBlockCoverage",
    dynamic.bool,
  )(value__))

  Ok(FunctionCoverage(
    function_name: function_name,
    ranges: ranges,
    is_block_coverage: is_block_coverage,
  ))
}

/// Coverage data for a JavaScript script.
pub type ScriptCoverage {
  ScriptCoverage(
    /// JavaScript script id.  
    script_id: runtime.ScriptId,
    /// JavaScript script name or url.  
    url: String,
    /// Functions contained in the script that has coverage data.  
    functions: List(FunctionCoverage),
  )
}

@internal
pub fn encode__script_coverage(value__: ScriptCoverage) {
  json.object([
    #("scriptId", runtime.encode__script_id(value__.script_id)),
    #("url", json.string(value__.url)),
    #("functions", json.array(value__.functions, of: encode__function_coverage)),
  ])
}

@internal
pub fn decode__script_coverage(value__: dynamic.Dynamic) {
  use script_id <- result.try(dynamic.field(
    "scriptId",
    runtime.decode__script_id,
  )(value__))
  use url <- result.try(dynamic.field("url", dynamic.string)(value__))
  use functions <- result.try(dynamic.field(
    "functions",
    dynamic.list(decode__function_coverage),
  )(value__))

  Ok(ScriptCoverage(script_id: script_id, url: url, functions: functions))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_best_effort_coverage`
pub type GetBestEffortCoverageResponse {
  GetBestEffortCoverageResponse(
    /// Coverage data for the current isolate.  
    result: List(ScriptCoverage),
  )
}

@internal
pub fn decode__get_best_effort_coverage_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field(
    "result",
    dynamic.list(decode__script_coverage),
  )(value__))

  Ok(GetBestEffortCoverageResponse(result: result))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `start_precise_coverage`
pub type StartPreciseCoverageResponse {
  StartPreciseCoverageResponse(
    /// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.  
    timestamp: Float,
  )
}

@internal
pub fn decode__start_precise_coverage_response(value__: dynamic.Dynamic) {
  use timestamp <- result.try(dynamic.field("timestamp", dynamic.float)(value__))

  Ok(StartPreciseCoverageResponse(timestamp: timestamp))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `stop`
pub type StopResponse {
  StopResponse(
    /// Recorded profile.  
    profile: Profile,
  )
}

@internal
pub fn decode__stop_response(value__: dynamic.Dynamic) {
  use profile <- result.try(dynamic.field("profile", decode__profile)(value__))

  Ok(StopResponse(profile: profile))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `take_precise_coverage`
pub type TakePreciseCoverageResponse {
  TakePreciseCoverageResponse(
    /// Coverage data for the current isolate.  
    result: List(ScriptCoverage),
    /// Monotonically increasing time (in seconds) when the coverage update was taken in the backend.  
    timestamp: Float,
  )
}

@internal
pub fn decode__take_precise_coverage_response(value__: dynamic.Dynamic) {
  use result <- result.try(dynamic.field(
    "result",
    dynamic.list(decode__script_coverage),
  )(value__))
  use timestamp <- result.try(dynamic.field("timestamp", dynamic.float)(value__))

  Ok(TakePreciseCoverageResponse(result: result, timestamp: timestamp))
}

/// This generated protocol command has no description
/// 
pub fn disable(callback__) {
  callback__("Profiler.disable", option.None)
}

/// This generated protocol command has no description
/// 
pub fn enable(callback__) {
  callback__("Profiler.enable", option.None)
}

/// Collect coverage data for the current isolate. The coverage data may be incomplete due to
/// garbage collection.
///  - `result` : Coverage data for the current isolate.
/// 
pub fn get_best_effort_coverage(callback__) {
  use result__ <- result.try(callback__(
    "Profiler.getBestEffortCoverage",
    option.None,
  ))

  decode__get_best_effort_coverage_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
/// 
/// Parameters:  
///  - `interval` : New sampling interval in microseconds.
/// 
/// Returns:  
/// 
pub fn set_sampling_interval(callback__, interval interval: Int) {
  callback__(
    "Profiler.setSamplingInterval",
    option.Some(json.object([#("interval", json.int(interval))])),
  )
}

/// This generated protocol command has no description
/// 
pub fn start(callback__) {
  callback__("Profiler.start", option.None)
}

/// Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
/// coverage may be incomplete. Enabling prevents running optimized code and resets execution
/// counters.
/// 
/// Parameters:  
///  - `call_count` : Collect accurate call counts beyond simple 'covered' or 'not covered'.
///  - `detailed` : Collect block-based coverage.
///  - `allow_triggered_updates` : Allow the backend to send updates on its own initiative
/// 
/// Returns:  
///  - `timestamp` : Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
/// 
pub fn start_precise_coverage(
  callback__,
  call_count call_count: option.Option(Bool),
  detailed detailed: option.Option(Bool),
  allow_triggered_updates allow_triggered_updates: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Profiler.startPreciseCoverage",
    option.Some(json.object(
      []
      |> utils.add_optional(call_count, fn(inner_value__) {
        #("callCount", json.bool(inner_value__))
      })
      |> utils.add_optional(detailed, fn(inner_value__) {
        #("detailed", json.bool(inner_value__))
      })
      |> utils.add_optional(allow_triggered_updates, fn(inner_value__) {
        #("allowTriggeredUpdates", json.bool(inner_value__))
      }),
    )),
  ))

  decode__start_precise_coverage_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// This generated protocol command has no description
///  - `profile` : Recorded profile.
/// 
pub fn stop(callback__) {
  use result__ <- result.try(callback__("Profiler.stop", option.None))

  decode__stop_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Disable precise code coverage. Disabling releases unnecessary execution count records and allows
/// executing optimized code.
/// 
pub fn stop_precise_coverage(callback__) {
  callback__("Profiler.stopPreciseCoverage", option.None)
}

/// Collect coverage data for the current isolate, and resets execution counters. Precise code
/// coverage needs to have started.
///  - `result` : Coverage data for the current isolate.
///  - `timestamp` : Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
/// 
pub fn take_precise_coverage(callback__) {
  use result__ <- result.try(callback__(
    "Profiler.takePreciseCoverage",
    option.None,
  ))

  decode__take_precise_coverage_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}
