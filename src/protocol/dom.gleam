//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## DOM Domain  
////
//// This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
//// that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
//// the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
//// nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
//// and never sends the same node twice. It is client's responsibility to collect information about
//// the nodes that were sent to the client. Note that `iframe` owner elements will return
//// corresponding document elements as their child nodes.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/DOM/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import chrobot/internal/utils
import chrome
import gleam/dynamic
import gleam/json
import gleam/option
import gleam/result
import protocol/runtime

/// Unique DOM node identifier.
pub type NodeId {
  NodeId(Int)
}

@internal
pub fn encode__node_id(value__: NodeId) {
  case value__ {
    NodeId(inner_value__) -> json.int(inner_value__)
  }
}

@internal
pub fn decode__node_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(NodeId, dynamic.int)
}

/// Unique DOM node identifier used to reference a node that may not have been pushed to the
/// front-end.
pub type BackendNodeId {
  BackendNodeId(Int)
}

@internal
pub fn encode__backend_node_id(value__: BackendNodeId) {
  case value__ {
    BackendNodeId(inner_value__) -> json.int(inner_value__)
  }
}

@internal
pub fn decode__backend_node_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(BackendNodeId, dynamic.int)
}

/// Backend node with a friendly name.
pub type BackendNode {
  BackendNode(node_type: Int, node_name: String, backend_node_id: BackendNodeId)
}

@internal
pub fn encode__backend_node(value__: BackendNode) {
  json.object([
    #("nodeType", json.int(value__.node_type)),
    #("nodeName", json.string(value__.node_name)),
    #("backendNodeId", encode__backend_node_id(value__.backend_node_id)),
  ])
}

@internal
pub fn decode__backend_node(value__: dynamic.Dynamic) {
  use node_type <- result.try(dynamic.field("nodeType", dynamic.int)(value__))
  use node_name <- result.try(dynamic.field("nodeName", dynamic.string)(value__))
  use backend_node_id <- result.try(dynamic.field(
    "backendNodeId",
    decode__backend_node_id,
  )(value__))

  Ok(BackendNode(
    node_type: node_type,
    node_name: node_name,
    backend_node_id: backend_node_id,
  ))
}

/// Pseudo element type.
pub type PseudoType {
  PseudoTypeFirstLine
  PseudoTypeFirstLetter
  PseudoTypeBefore
  PseudoTypeAfter
  PseudoTypeMarker
  PseudoTypeBackdrop
  PseudoTypeSelection
  PseudoTypeTargetText
  PseudoTypeSpellingError
  PseudoTypeGrammarError
  PseudoTypeHighlight
  PseudoTypeFirstLineInherited
  PseudoTypeScrollMarker
  PseudoTypeScrollMarkers
  PseudoTypeScrollbar
  PseudoTypeScrollbarThumb
  PseudoTypeScrollbarButton
  PseudoTypeScrollbarTrack
  PseudoTypeScrollbarTrackPiece
  PseudoTypeScrollbarCorner
  PseudoTypeResizer
  PseudoTypeInputListButton
  PseudoTypeViewTransition
  PseudoTypeViewTransitionGroup
  PseudoTypeViewTransitionImagePair
  PseudoTypeViewTransitionOld
  PseudoTypeViewTransitionNew
}

@internal
pub fn encode__pseudo_type(value__: PseudoType) {
  case value__ {
    PseudoTypeFirstLine -> "first-line"
    PseudoTypeFirstLetter -> "first-letter"
    PseudoTypeBefore -> "before"
    PseudoTypeAfter -> "after"
    PseudoTypeMarker -> "marker"
    PseudoTypeBackdrop -> "backdrop"
    PseudoTypeSelection -> "selection"
    PseudoTypeTargetText -> "target-text"
    PseudoTypeSpellingError -> "spelling-error"
    PseudoTypeGrammarError -> "grammar-error"
    PseudoTypeHighlight -> "highlight"
    PseudoTypeFirstLineInherited -> "first-line-inherited"
    PseudoTypeScrollMarker -> "scroll-marker"
    PseudoTypeScrollMarkers -> "scroll-markers"
    PseudoTypeScrollbar -> "scrollbar"
    PseudoTypeScrollbarThumb -> "scrollbar-thumb"
    PseudoTypeScrollbarButton -> "scrollbar-button"
    PseudoTypeScrollbarTrack -> "scrollbar-track"
    PseudoTypeScrollbarTrackPiece -> "scrollbar-track-piece"
    PseudoTypeScrollbarCorner -> "scrollbar-corner"
    PseudoTypeResizer -> "resizer"
    PseudoTypeInputListButton -> "input-list-button"
    PseudoTypeViewTransition -> "view-transition"
    PseudoTypeViewTransitionGroup -> "view-transition-group"
    PseudoTypeViewTransitionImagePair -> "view-transition-image-pair"
    PseudoTypeViewTransitionOld -> "view-transition-old"
    PseudoTypeViewTransitionNew -> "view-transition-new"
  }
  |> json.string()
}

@internal
pub fn decode__pseudo_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("first-line") -> Ok(PseudoTypeFirstLine)
    Ok("first-letter") -> Ok(PseudoTypeFirstLetter)
    Ok("before") -> Ok(PseudoTypeBefore)
    Ok("after") -> Ok(PseudoTypeAfter)
    Ok("marker") -> Ok(PseudoTypeMarker)
    Ok("backdrop") -> Ok(PseudoTypeBackdrop)
    Ok("selection") -> Ok(PseudoTypeSelection)
    Ok("target-text") -> Ok(PseudoTypeTargetText)
    Ok("spelling-error") -> Ok(PseudoTypeSpellingError)
    Ok("grammar-error") -> Ok(PseudoTypeGrammarError)
    Ok("highlight") -> Ok(PseudoTypeHighlight)
    Ok("first-line-inherited") -> Ok(PseudoTypeFirstLineInherited)
    Ok("scroll-marker") -> Ok(PseudoTypeScrollMarker)
    Ok("scroll-markers") -> Ok(PseudoTypeScrollMarkers)
    Ok("scrollbar") -> Ok(PseudoTypeScrollbar)
    Ok("scrollbar-thumb") -> Ok(PseudoTypeScrollbarThumb)
    Ok("scrollbar-button") -> Ok(PseudoTypeScrollbarButton)
    Ok("scrollbar-track") -> Ok(PseudoTypeScrollbarTrack)
    Ok("scrollbar-track-piece") -> Ok(PseudoTypeScrollbarTrackPiece)
    Ok("scrollbar-corner") -> Ok(PseudoTypeScrollbarCorner)
    Ok("resizer") -> Ok(PseudoTypeResizer)
    Ok("input-list-button") -> Ok(PseudoTypeInputListButton)
    Ok("view-transition") -> Ok(PseudoTypeViewTransition)
    Ok("view-transition-group") -> Ok(PseudoTypeViewTransitionGroup)
    Ok("view-transition-image-pair") -> Ok(PseudoTypeViewTransitionImagePair)
    Ok("view-transition-old") -> Ok(PseudoTypeViewTransitionOld)
    Ok("view-transition-new") -> Ok(PseudoTypeViewTransitionNew)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Shadow root type.
pub type ShadowRootType {
  ShadowRootTypeUserAgent
  ShadowRootTypeOpen
  ShadowRootTypeClosed
}

@internal
pub fn encode__shadow_root_type(value__: ShadowRootType) {
  case value__ {
    ShadowRootTypeUserAgent -> "user-agent"
    ShadowRootTypeOpen -> "open"
    ShadowRootTypeClosed -> "closed"
  }
  |> json.string()
}

@internal
pub fn decode__shadow_root_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("user-agent") -> Ok(ShadowRootTypeUserAgent)
    Ok("open") -> Ok(ShadowRootTypeOpen)
    Ok("closed") -> Ok(ShadowRootTypeClosed)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Document compatibility mode.
pub type CompatibilityMode {
  CompatibilityModeQuirksMode
  CompatibilityModeLimitedQuirksMode
  CompatibilityModeNoQuirksMode
}

@internal
pub fn encode__compatibility_mode(value__: CompatibilityMode) {
  case value__ {
    CompatibilityModeQuirksMode -> "QuirksMode"
    CompatibilityModeLimitedQuirksMode -> "LimitedQuirksMode"
    CompatibilityModeNoQuirksMode -> "NoQuirksMode"
  }
  |> json.string()
}

@internal
pub fn decode__compatibility_mode(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("QuirksMode") -> Ok(CompatibilityModeQuirksMode)
    Ok("LimitedQuirksMode") -> Ok(CompatibilityModeLimitedQuirksMode)
    Ok("NoQuirksMode") -> Ok(CompatibilityModeNoQuirksMode)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// ContainerSelector physical axes
pub type PhysicalAxes {
  PhysicalAxesHorizontal
  PhysicalAxesVertical
  PhysicalAxesBoth
}

@internal
pub fn encode__physical_axes(value__: PhysicalAxes) {
  case value__ {
    PhysicalAxesHorizontal -> "Horizontal"
    PhysicalAxesVertical -> "Vertical"
    PhysicalAxesBoth -> "Both"
  }
  |> json.string()
}

@internal
pub fn decode__physical_axes(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("Horizontal") -> Ok(PhysicalAxesHorizontal)
    Ok("Vertical") -> Ok(PhysicalAxesVertical)
    Ok("Both") -> Ok(PhysicalAxesBoth)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// ContainerSelector logical axes
pub type LogicalAxes {
  LogicalAxesInline
  LogicalAxesBlock
  LogicalAxesBoth
}

@internal
pub fn encode__logical_axes(value__: LogicalAxes) {
  case value__ {
    LogicalAxesInline -> "Inline"
    LogicalAxesBlock -> "Block"
    LogicalAxesBoth -> "Both"
  }
  |> json.string()
}

@internal
pub fn decode__logical_axes(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("Inline") -> Ok(LogicalAxesInline)
    Ok("Block") -> Ok(LogicalAxesBlock)
    Ok("Both") -> Ok(LogicalAxesBoth)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Physical scroll orientation
pub type ScrollOrientation {
  ScrollOrientationHorizontal
  ScrollOrientationVertical
}

@internal
pub fn encode__scroll_orientation(value__: ScrollOrientation) {
  case value__ {
    ScrollOrientationHorizontal -> "horizontal"
    ScrollOrientationVertical -> "vertical"
  }
  |> json.string()
}

@internal
pub fn decode__scroll_orientation(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("horizontal") -> Ok(ScrollOrientationHorizontal)
    Ok("vertical") -> Ok(ScrollOrientationVertical)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
/// DOMNode is a base node mirror type.
pub type Node {
  Node(
    node_id: NodeId,
    parent_id: option.Option(NodeId),
    backend_node_id: BackendNodeId,
    node_type: Int,
    node_name: String,
    local_name: String,
    node_value: String,
    child_node_count: option.Option(Int),
    children: option.Option(List(Node)),
    attributes: option.Option(List(String)),
    document_url: option.Option(String),
    base_url: option.Option(String),
    public_id: option.Option(String),
    system_id: option.Option(String),
    internal_subset: option.Option(String),
    xml_version: option.Option(String),
    name: option.Option(String),
    value: option.Option(String),
    pseudo_type: option.Option(PseudoType),
    pseudo_identifier: option.Option(String),
    shadow_root_type: option.Option(ShadowRootType),
    frame_id: option.Option(String),
    content_document: option.Option(Node),
    shadow_roots: option.Option(List(Node)),
    template_content: option.Option(Node),
    pseudo_elements: option.Option(List(Node)),
    distributed_nodes: option.Option(List(BackendNode)),
    is_svg: option.Option(Bool),
    compatibility_mode: option.Option(CompatibilityMode),
    assigned_slot: option.Option(BackendNode),
  )
}

@internal
pub fn encode__node(value__: Node) {
  json.object(
    [
      #("nodeId", encode__node_id(value__.node_id)),
      #("backendNodeId", encode__backend_node_id(value__.backend_node_id)),
      #("nodeType", json.int(value__.node_type)),
      #("nodeName", json.string(value__.node_name)),
      #("localName", json.string(value__.local_name)),
      #("nodeValue", json.string(value__.node_value)),
    ]
    |> utils.add_optional(value__.parent_id, fn(inner_value__) {
      #("parentId", encode__node_id(inner_value__))
    })
    |> utils.add_optional(value__.child_node_count, fn(inner_value__) {
      #("childNodeCount", json.int(inner_value__))
    })
    |> utils.add_optional(value__.children, fn(inner_value__) {
      #("children", json.array(inner_value__, of: encode__node))
    })
    |> utils.add_optional(value__.attributes, fn(inner_value__) {
      #("attributes", json.array(inner_value__, of: json.string))
    })
    |> utils.add_optional(value__.document_url, fn(inner_value__) {
      #("documentURL", json.string(inner_value__))
    })
    |> utils.add_optional(value__.base_url, fn(inner_value__) {
      #("baseURL", json.string(inner_value__))
    })
    |> utils.add_optional(value__.public_id, fn(inner_value__) {
      #("publicId", json.string(inner_value__))
    })
    |> utils.add_optional(value__.system_id, fn(inner_value__) {
      #("systemId", json.string(inner_value__))
    })
    |> utils.add_optional(value__.internal_subset, fn(inner_value__) {
      #("internalSubset", json.string(inner_value__))
    })
    |> utils.add_optional(value__.xml_version, fn(inner_value__) {
      #("xmlVersion", json.string(inner_value__))
    })
    |> utils.add_optional(value__.name, fn(inner_value__) {
      #("name", json.string(inner_value__))
    })
    |> utils.add_optional(value__.value, fn(inner_value__) {
      #("value", json.string(inner_value__))
    })
    |> utils.add_optional(value__.pseudo_type, fn(inner_value__) {
      #("pseudoType", encode__pseudo_type(inner_value__))
    })
    |> utils.add_optional(value__.pseudo_identifier, fn(inner_value__) {
      #("pseudoIdentifier", json.string(inner_value__))
    })
    |> utils.add_optional(value__.shadow_root_type, fn(inner_value__) {
      #("shadowRootType", encode__shadow_root_type(inner_value__))
    })
    |> utils.add_optional(value__.frame_id, fn(inner_value__) {
      #("frameId", json.string(inner_value__))
    })
    |> utils.add_optional(value__.content_document, fn(inner_value__) {
      #("contentDocument", encode__node(inner_value__))
    })
    |> utils.add_optional(value__.shadow_roots, fn(inner_value__) {
      #("shadowRoots", json.array(inner_value__, of: encode__node))
    })
    |> utils.add_optional(value__.template_content, fn(inner_value__) {
      #("templateContent", encode__node(inner_value__))
    })
    |> utils.add_optional(value__.pseudo_elements, fn(inner_value__) {
      #("pseudoElements", json.array(inner_value__, of: encode__node))
    })
    |> utils.add_optional(value__.distributed_nodes, fn(inner_value__) {
      #("distributedNodes", json.array(inner_value__, of: encode__backend_node))
    })
    |> utils.add_optional(value__.is_svg, fn(inner_value__) {
      #("isSVG", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.compatibility_mode, fn(inner_value__) {
      #("compatibilityMode", encode__compatibility_mode(inner_value__))
    })
    |> utils.add_optional(value__.assigned_slot, fn(inner_value__) {
      #("assignedSlot", encode__backend_node(inner_value__))
    }),
  )
}

@internal
pub fn decode__node(value__: dynamic.Dynamic) {
  use node_id <- result.try(dynamic.field("nodeId", decode__node_id)(value__))
  use parent_id <- result.try(dynamic.optional_field(
    "parentId",
    decode__node_id,
  )(value__))
  use backend_node_id <- result.try(dynamic.field(
    "backendNodeId",
    decode__backend_node_id,
  )(value__))
  use node_type <- result.try(dynamic.field("nodeType", dynamic.int)(value__))
  use node_name <- result.try(dynamic.field("nodeName", dynamic.string)(value__))
  use local_name <- result.try(dynamic.field("localName", dynamic.string)(
    value__,
  ))
  use node_value <- result.try(dynamic.field("nodeValue", dynamic.string)(
    value__,
  ))
  use child_node_count <- result.try(dynamic.optional_field(
    "childNodeCount",
    dynamic.int,
  )(value__))
  use children <- result.try(dynamic.optional_field(
    "children",
    dynamic.list(decode__node),
  )(value__))
  use attributes <- result.try(dynamic.optional_field(
    "attributes",
    dynamic.list(dynamic.string),
  )(value__))
  use document_url <- result.try(dynamic.optional_field(
    "documentURL",
    dynamic.string,
  )(value__))
  use base_url <- result.try(dynamic.optional_field("baseURL", dynamic.string)(
    value__,
  ))
  use public_id <- result.try(dynamic.optional_field("publicId", dynamic.string)(
    value__,
  ))
  use system_id <- result.try(dynamic.optional_field("systemId", dynamic.string)(
    value__,
  ))
  use internal_subset <- result.try(dynamic.optional_field(
    "internalSubset",
    dynamic.string,
  )(value__))
  use xml_version <- result.try(dynamic.optional_field(
    "xmlVersion",
    dynamic.string,
  )(value__))
  use name <- result.try(dynamic.optional_field("name", dynamic.string)(value__))
  use value <- result.try(dynamic.optional_field("value", dynamic.string)(
    value__,
  ))
  use pseudo_type <- result.try(dynamic.optional_field(
    "pseudoType",
    decode__pseudo_type,
  )(value__))
  use pseudo_identifier <- result.try(dynamic.optional_field(
    "pseudoIdentifier",
    dynamic.string,
  )(value__))
  use shadow_root_type <- result.try(dynamic.optional_field(
    "shadowRootType",
    decode__shadow_root_type,
  )(value__))
  use frame_id <- result.try(dynamic.optional_field("frameId", dynamic.string)(
    value__,
  ))
  use content_document <- result.try(dynamic.optional_field(
    "contentDocument",
    decode__node,
  )(value__))
  use shadow_roots <- result.try(dynamic.optional_field(
    "shadowRoots",
    dynamic.list(decode__node),
  )(value__))
  use template_content <- result.try(dynamic.optional_field(
    "templateContent",
    decode__node,
  )(value__))
  use pseudo_elements <- result.try(dynamic.optional_field(
    "pseudoElements",
    dynamic.list(decode__node),
  )(value__))
  use distributed_nodes <- result.try(dynamic.optional_field(
    "distributedNodes",
    dynamic.list(decode__backend_node),
  )(value__))
  use is_svg <- result.try(dynamic.optional_field("isSVG", dynamic.bool)(
    value__,
  ))
  use compatibility_mode <- result.try(dynamic.optional_field(
    "compatibilityMode",
    decode__compatibility_mode,
  )(value__))
  use assigned_slot <- result.try(dynamic.optional_field(
    "assignedSlot",
    decode__backend_node,
  )(value__))

  Ok(Node(
    node_id: node_id,
    parent_id: parent_id,
    backend_node_id: backend_node_id,
    node_type: node_type,
    node_name: node_name,
    local_name: local_name,
    node_value: node_value,
    child_node_count: child_node_count,
    children: children,
    attributes: attributes,
    document_url: document_url,
    base_url: base_url,
    public_id: public_id,
    system_id: system_id,
    internal_subset: internal_subset,
    xml_version: xml_version,
    name: name,
    value: value,
    pseudo_type: pseudo_type,
    pseudo_identifier: pseudo_identifier,
    shadow_root_type: shadow_root_type,
    frame_id: frame_id,
    content_document: content_document,
    shadow_roots: shadow_roots,
    template_content: template_content,
    pseudo_elements: pseudo_elements,
    distributed_nodes: distributed_nodes,
    is_svg: is_svg,
    compatibility_mode: compatibility_mode,
    assigned_slot: assigned_slot,
  ))
}

/// A structure holding an RGBA color.
pub type RGBA {
  RGBA(r: Int, g: Int, b: Int, a: option.Option(Float))
}

@internal
pub fn encode__rgba(value__: RGBA) {
  json.object(
    [
      #("r", json.int(value__.r)),
      #("g", json.int(value__.g)),
      #("b", json.int(value__.b)),
    ]
    |> utils.add_optional(value__.a, fn(inner_value__) {
      #("a", json.float(inner_value__))
    }),
  )
}

@internal
pub fn decode__rgba(value__: dynamic.Dynamic) {
  use r <- result.try(dynamic.field("r", dynamic.int)(value__))
  use g <- result.try(dynamic.field("g", dynamic.int)(value__))
  use b <- result.try(dynamic.field("b", dynamic.int)(value__))
  use a <- result.try(dynamic.optional_field("a", dynamic.float)(value__))

  Ok(RGBA(r: r, g: g, b: b, a: a))
}

/// An array of quad vertices, x immediately followed by y for each point, points clock-wise.
pub type Quad {
  Quad(List(Float))
}

@internal
pub fn encode__quad(value__: Quad) {
  case value__ {
    Quad(inner_value__) -> json.array(inner_value__, of: json.float)
  }
}

@internal
pub fn decode__quad(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(Quad, dynamic.list(dynamic.float))
}

/// Box model.
pub type BoxModel {
  BoxModel(
    content: Quad,
    padding: Quad,
    border: Quad,
    margin: Quad,
    width: Int,
    height: Int,
    shape_outside: option.Option(ShapeOutsideInfo),
  )
}

@internal
pub fn encode__box_model(value__: BoxModel) {
  json.object(
    [
      #("content", encode__quad(value__.content)),
      #("padding", encode__quad(value__.padding)),
      #("border", encode__quad(value__.border)),
      #("margin", encode__quad(value__.margin)),
      #("width", json.int(value__.width)),
      #("height", json.int(value__.height)),
    ]
    |> utils.add_optional(value__.shape_outside, fn(inner_value__) {
      #("shapeOutside", encode__shape_outside_info(inner_value__))
    }),
  )
}

@internal
pub fn decode__box_model(value__: dynamic.Dynamic) {
  use content <- result.try(dynamic.field("content", decode__quad)(value__))
  use padding <- result.try(dynamic.field("padding", decode__quad)(value__))
  use border <- result.try(dynamic.field("border", decode__quad)(value__))
  use margin <- result.try(dynamic.field("margin", decode__quad)(value__))
  use width <- result.try(dynamic.field("width", dynamic.int)(value__))
  use height <- result.try(dynamic.field("height", dynamic.int)(value__))
  use shape_outside <- result.try(dynamic.optional_field(
    "shapeOutside",
    decode__shape_outside_info,
  )(value__))

  Ok(BoxModel(
    content: content,
    padding: padding,
    border: border,
    margin: margin,
    width: width,
    height: height,
    shape_outside: shape_outside,
  ))
}

/// CSS Shape Outside details.
pub type ShapeOutsideInfo {
  ShapeOutsideInfo(
    bounds: Quad,
    shape: List(dynamic.Dynamic),
    margin_shape: List(dynamic.Dynamic),
  )
}

@internal
pub fn encode__shape_outside_info(value__: ShapeOutsideInfo) {
  json.object([
    #("bounds", encode__quad(value__.bounds)),
    #(
      "shape",
      // dynamic values cannot be encoded!
      json.null(),
    ),
    #(
      "marginShape",
      // dynamic values cannot be encoded!
      json.null(),
    ),
  ])
}

@internal
pub fn decode__shape_outside_info(value__: dynamic.Dynamic) {
  use bounds <- result.try(dynamic.field("bounds", decode__quad)(value__))
  use shape <- result.try(dynamic.field("shape", dynamic.list(dynamic.dynamic))(
    value__,
  ))
  use margin_shape <- result.try(dynamic.field(
    "marginShape",
    dynamic.list(dynamic.dynamic),
  )(value__))

  Ok(ShapeOutsideInfo(bounds: bounds, shape: shape, margin_shape: margin_shape))
}

/// Rectangle.
pub type Rect {
  Rect(x: Float, y: Float, width: Float, height: Float)
}

@internal
pub fn encode__rect(value__: Rect) {
  json.object([
    #("x", json.float(value__.x)),
    #("y", json.float(value__.y)),
    #("width", json.float(value__.width)),
    #("height", json.float(value__.height)),
  ])
}

@internal
pub fn decode__rect(value__: dynamic.Dynamic) {
  use x <- result.try(dynamic.field("x", dynamic.float)(value__))
  use y <- result.try(dynamic.field("y", dynamic.float)(value__))
  use width <- result.try(dynamic.field("width", dynamic.float)(value__))
  use height <- result.try(dynamic.field("height", dynamic.float)(value__))

  Ok(Rect(x: x, y: y, width: width, height: height))
}

pub type CSSComputedStyleProperty {
  CSSComputedStyleProperty(name: String, value: String)
}

@internal
pub fn encode__css_computed_style_property(value__: CSSComputedStyleProperty) {
  json.object([
    #("name", json.string(value__.name)),
    #("value", json.string(value__.value)),
  ])
}

@internal
pub fn decode__css_computed_style_property(value__: dynamic.Dynamic) {
  use name <- result.try(dynamic.field("name", dynamic.string)(value__))
  use value <- result.try(dynamic.field("value", dynamic.string)(value__))

  Ok(CSSComputedStyleProperty(name: name, value: value))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `describe_node`
pub type DescribeNodeResponse {
  DescribeNodeResponse(node: Node)
}

@internal
pub fn decode__describe_node_response(value__: dynamic.Dynamic) {
  use node <- result.try(dynamic.field("node", decode__node)(value__))

  Ok(DescribeNodeResponse(node: node))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_attributes`
pub type GetAttributesResponse {
  GetAttributesResponse(attributes: List(String))
}

@internal
pub fn decode__get_attributes_response(value__: dynamic.Dynamic) {
  use attributes <- result.try(dynamic.field(
    "attributes",
    dynamic.list(dynamic.string),
  )(value__))

  Ok(GetAttributesResponse(attributes: attributes))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_box_model`
pub type GetBoxModelResponse {
  GetBoxModelResponse(model: BoxModel)
}

@internal
pub fn decode__get_box_model_response(value__: dynamic.Dynamic) {
  use model <- result.try(dynamic.field("model", decode__box_model)(value__))

  Ok(GetBoxModelResponse(model: model))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_document`
pub type GetDocumentResponse {
  GetDocumentResponse(root: Node)
}

@internal
pub fn decode__get_document_response(value__: dynamic.Dynamic) {
  use root <- result.try(dynamic.field("root", decode__node)(value__))

  Ok(GetDocumentResponse(root: root))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_node_for_location`
pub type GetNodeForLocationResponse {
  GetNodeForLocationResponse(
    backend_node_id: BackendNodeId,
    frame_id: String,
    node_id: option.Option(NodeId),
  )
}

@internal
pub fn decode__get_node_for_location_response(value__: dynamic.Dynamic) {
  use backend_node_id <- result.try(dynamic.field(
    "backendNodeId",
    decode__backend_node_id,
  )(value__))
  use frame_id <- result.try(dynamic.field("frameId", dynamic.string)(value__))
  use node_id <- result.try(dynamic.optional_field("nodeId", decode__node_id)(
    value__,
  ))

  Ok(GetNodeForLocationResponse(
    backend_node_id: backend_node_id,
    frame_id: frame_id,
    node_id: node_id,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_outer_html`
pub type GetOuterHtmlResponse {
  GetOuterHtmlResponse(outer_html: String)
}

@internal
pub fn decode__get_outer_html_response(value__: dynamic.Dynamic) {
  use outer_html <- result.try(dynamic.field("outerHTML", dynamic.string)(
    value__,
  ))

  Ok(GetOuterHtmlResponse(outer_html: outer_html))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `move_to`
pub type MoveToResponse {
  MoveToResponse(node_id: NodeId)
}

@internal
pub fn decode__move_to_response(value__: dynamic.Dynamic) {
  use node_id <- result.try(dynamic.field("nodeId", decode__node_id)(value__))

  Ok(MoveToResponse(node_id: node_id))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `query_selector`
pub type QuerySelectorResponse {
  QuerySelectorResponse(node_id: NodeId)
}

@internal
pub fn decode__query_selector_response(value__: dynamic.Dynamic) {
  use node_id <- result.try(dynamic.field("nodeId", decode__node_id)(value__))

  Ok(QuerySelectorResponse(node_id: node_id))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `query_selector_all`
pub type QuerySelectorAllResponse {
  QuerySelectorAllResponse(node_ids: List(NodeId))
}

@internal
pub fn decode__query_selector_all_response(value__: dynamic.Dynamic) {
  use node_ids <- result.try(dynamic.field(
    "nodeIds",
    dynamic.list(decode__node_id),
  )(value__))

  Ok(QuerySelectorAllResponse(node_ids: node_ids))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `request_node`
pub type RequestNodeResponse {
  RequestNodeResponse(node_id: NodeId)
}

@internal
pub fn decode__request_node_response(value__: dynamic.Dynamic) {
  use node_id <- result.try(dynamic.field("nodeId", decode__node_id)(value__))

  Ok(RequestNodeResponse(node_id: node_id))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `resolve_node`
pub type ResolveNodeResponse {
  ResolveNodeResponse(object: runtime.RemoteObject)
}

@internal
pub fn decode__resolve_node_response(value__: dynamic.Dynamic) {
  use object <- result.try(dynamic.field(
    "object",
    runtime.decode__remote_object,
  )(value__))

  Ok(ResolveNodeResponse(object: object))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_node_name`
pub type SetNodeNameResponse {
  SetNodeNameResponse(node_id: NodeId)
}

@internal
pub fn decode__set_node_name_response(value__: dynamic.Dynamic) {
  use node_id <- result.try(dynamic.field("nodeId", decode__node_id)(value__))

  Ok(SetNodeNameResponse(node_id: node_id))
}

/// Describes node given its id, does not require domain to be enabled. Does not start tracking any
/// objects, can be used for automation.
pub fn describe_node(
  browser_subject,
  node_id: option.Option(NodeId),
  backend_node_id: option.Option(BackendNodeId),
  object_id: option.Option(runtime.RemoteObjectId),
  depth: option.Option(Int),
  pierce: option.Option(Bool),
) {
  chrome.call(
    browser_subject,
    "DOM.describeNode",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      })
      |> utils.add_optional(depth, fn(inner_value__) {
        #("depth", json.int(inner_value__))
      })
      |> utils.add_optional(pierce, fn(inner_value__) {
        #("pierce", json.bool(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__describe_node_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Scrolls the specified rect of the given node into view if not already visible.
/// Note: exactly one between nodeId, backendNodeId and objectId should be passed
/// to identify the node.
pub fn scroll_into_view_if_needed(
  browser_subject,
  node_id: option.Option(NodeId),
  backend_node_id: option.Option(BackendNodeId),
  object_id: option.Option(runtime.RemoteObjectId),
  rect: option.Option(Rect),
) {
  let _ =
    chrome.call(
      browser_subject,
      "DOM.scrollIntoViewIfNeeded",
      option.Some(json.object(
        []
        |> utils.add_optional(node_id, fn(inner_value__) {
          #("nodeId", encode__node_id(inner_value__))
        })
        |> utils.add_optional(backend_node_id, fn(inner_value__) {
          #("backendNodeId", encode__backend_node_id(inner_value__))
        })
        |> utils.add_optional(object_id, fn(inner_value__) {
          #("objectId", runtime.encode__remote_object_id(inner_value__))
        })
        |> utils.add_optional(rect, fn(inner_value__) {
          #("rect", encode__rect(inner_value__))
        }),
      )),
      10_000,
    )
  Nil
}

/// Disables DOM agent for the given page.
pub fn disable(browser_subject) {
  let _ = chrome.call(browser_subject, "DOM.disable", option.None, 10_000)
  Nil
}

/// Enables DOM agent for the given page.
pub fn enable(browser_subject) {
  let _ = chrome.call(browser_subject, "DOM.enable", option.None, 10_000)
  Nil
}

/// Focuses the given element.
pub fn focus(
  browser_subject,
  node_id: option.Option(NodeId),
  backend_node_id: option.Option(BackendNodeId),
  object_id: option.Option(runtime.RemoteObjectId),
) {
  let _ =
    chrome.call(
      browser_subject,
      "DOM.focus",
      option.Some(json.object(
        []
        |> utils.add_optional(node_id, fn(inner_value__) {
          #("nodeId", encode__node_id(inner_value__))
        })
        |> utils.add_optional(backend_node_id, fn(inner_value__) {
          #("backendNodeId", encode__backend_node_id(inner_value__))
        })
        |> utils.add_optional(object_id, fn(inner_value__) {
          #("objectId", runtime.encode__remote_object_id(inner_value__))
        }),
      )),
      10_000,
    )
  Nil
}

/// Returns attributes for the specified node.
pub fn get_attributes(browser_subject, node_id: NodeId) {
  chrome.call(
    browser_subject,
    "DOM.getAttributes",
    option.Some(json.object([#("nodeId", encode__node_id(node_id))])),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__get_attributes_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Returns boxes for the given node.
pub fn get_box_model(
  browser_subject,
  node_id: option.Option(NodeId),
  backend_node_id: option.Option(BackendNodeId),
  object_id: option.Option(runtime.RemoteObjectId),
) {
  chrome.call(
    browser_subject,
    "DOM.getBoxModel",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__get_box_model_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Returns the root DOM node (and optionally the subtree) to the caller.
/// Implicitly enables the DOM domain events for the current target.
pub fn get_document(
  browser_subject,
  depth: option.Option(Int),
  pierce: option.Option(Bool),
) {
  chrome.call(
    browser_subject,
    "DOM.getDocument",
    option.Some(json.object(
      []
      |> utils.add_optional(depth, fn(inner_value__) {
        #("depth", json.int(inner_value__))
      })
      |> utils.add_optional(pierce, fn(inner_value__) {
        #("pierce", json.bool(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__get_document_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
/// either returned or not.
pub fn get_node_for_location(
  browser_subject,
  x: Int,
  y: Int,
  include_user_agent_shadow_dom: option.Option(Bool),
  ignore_pointer_events_none: option.Option(Bool),
) {
  chrome.call(
    browser_subject,
    "DOM.getNodeForLocation",
    option.Some(json.object(
      [#("x", json.int(x)), #("y", json.int(y))]
      |> utils.add_optional(include_user_agent_shadow_dom, fn(inner_value__) {
        #("includeUserAgentShadowDOM", json.bool(inner_value__))
      })
      |> utils.add_optional(ignore_pointer_events_none, fn(inner_value__) {
        #("ignorePointerEventsNone", json.bool(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__get_node_for_location_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Returns node's HTML markup.
pub fn get_outer_html(
  browser_subject,
  node_id: option.Option(NodeId),
  backend_node_id: option.Option(BackendNodeId),
  object_id: option.Option(runtime.RemoteObjectId),
) {
  chrome.call(
    browser_subject,
    "DOM.getOuterHTML",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__get_outer_html_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Hides any highlight.
pub fn hide_highlight(browser_subject) {
  let _ = chrome.call(browser_subject, "DOM.hideHighlight", option.None, 10_000)
  Nil
}

/// Highlights DOM node.
pub fn highlight_node(browser_subject) {
  let _ = chrome.call(browser_subject, "DOM.highlightNode", option.None, 10_000)
  Nil
}

/// Highlights given rectangle.
pub fn highlight_rect(browser_subject) {
  let _ = chrome.call(browser_subject, "DOM.highlightRect", option.None, 10_000)
  Nil
}

/// Moves node into the new container, places it before the given anchor.
pub fn move_to(
  browser_subject,
  node_id: NodeId,
  target_node_id: NodeId,
  insert_before_node_id: option.Option(NodeId),
) {
  chrome.call(
    browser_subject,
    "DOM.moveTo",
    option.Some(json.object(
      [
        #("nodeId", encode__node_id(node_id)),
        #("targetNodeId", encode__node_id(target_node_id)),
      ]
      |> utils.add_optional(insert_before_node_id, fn(inner_value__) {
        #("insertBeforeNodeId", encode__node_id(inner_value__))
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__move_to_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Executes `querySelector` on a given node.
pub fn query_selector(browser_subject, node_id: NodeId, selector: String) {
  chrome.call(
    browser_subject,
    "DOM.querySelector",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("selector", json.string(selector)),
      ]),
    ),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__query_selector_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Executes `querySelectorAll` on a given node.
pub fn query_selector_all(browser_subject, node_id: NodeId, selector: String) {
  chrome.call(
    browser_subject,
    "DOM.querySelectorAll",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("selector", json.string(selector)),
      ]),
    ),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__query_selector_all_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Removes attribute with given name from an element with given id.
pub fn remove_attribute(browser_subject, node_id: NodeId, name: String) {
  let _ =
    chrome.call(
      browser_subject,
      "DOM.removeAttribute",
      option.Some(
        json.object([
          #("nodeId", encode__node_id(node_id)),
          #("name", json.string(name)),
        ]),
      ),
      10_000,
    )
  Nil
}

/// Removes node with given id.
pub fn remove_node(browser_subject, node_id: NodeId) {
  let _ =
    chrome.call(
      browser_subject,
      "DOM.removeNode",
      option.Some(json.object([#("nodeId", encode__node_id(node_id))])),
      10_000,
    )
  Nil
}

/// Requests that children of the node with given id are returned to the caller in form of
/// `setChildNodes` events where not only immediate children are retrieved, but all children down to
/// the specified depth.
pub fn request_child_nodes(
  browser_subject,
  node_id: NodeId,
  depth: option.Option(Int),
  pierce: option.Option(Bool),
) {
  let _ =
    chrome.call(
      browser_subject,
      "DOM.requestChildNodes",
      option.Some(json.object(
        [#("nodeId", encode__node_id(node_id))]
        |> utils.add_optional(depth, fn(inner_value__) {
          #("depth", json.int(inner_value__))
        })
        |> utils.add_optional(pierce, fn(inner_value__) {
          #("pierce", json.bool(inner_value__))
        }),
      )),
      10_000,
    )
  Nil
}

/// Requests that the node is sent to the caller given the JavaScript node object reference. All
/// nodes that form the path from the node to the root are also sent to the client as a series of
/// `setChildNodes` notifications.
pub fn request_node(browser_subject, object_id: runtime.RemoteObjectId) {
  chrome.call(
    browser_subject,
    "DOM.requestNode",
    option.Some(
      json.object([#("objectId", runtime.encode__remote_object_id(object_id))]),
    ),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__request_node_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Resolves the JavaScript node object for a given NodeId or BackendNodeId.
pub fn resolve_node(
  browser_subject,
  node_id: option.Option(NodeId),
  backend_node_id: option.Option(BackendNodeId),
  object_group: option.Option(String),
  execution_context_id: option.Option(runtime.ExecutionContextId),
) {
  chrome.call(
    browser_subject,
    "DOM.resolveNode",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_group, fn(inner_value__) {
        #("objectGroup", json.string(inner_value__))
      })
      |> utils.add_optional(execution_context_id, fn(inner_value__) {
        #(
          "executionContextId",
          runtime.encode__execution_context_id(inner_value__),
        )
      }),
    )),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__resolve_node_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Sets attribute for an element with given id.
pub fn set_attribute_value(
  browser_subject,
  node_id: NodeId,
  name: String,
  value: String,
) {
  let _ =
    chrome.call(
      browser_subject,
      "DOM.setAttributeValue",
      option.Some(
        json.object([
          #("nodeId", encode__node_id(node_id)),
          #("name", json.string(name)),
          #("value", json.string(value)),
        ]),
      ),
      10_000,
    )
  Nil
}

/// Sets attributes on element with given id. This method is useful when user edits some existing
/// attribute value and types in several attribute name/value pairs.
pub fn set_attributes_as_text(
  browser_subject,
  node_id: NodeId,
  text: String,
  name: option.Option(String),
) {
  let _ =
    chrome.call(
      browser_subject,
      "DOM.setAttributesAsText",
      option.Some(json.object(
        [#("nodeId", encode__node_id(node_id)), #("text", json.string(text))]
        |> utils.add_optional(name, fn(inner_value__) {
          #("name", json.string(inner_value__))
        }),
      )),
      10_000,
    )
  Nil
}

/// Sets files for the given file input element.
pub fn set_file_input_files(
  browser_subject,
  files: List(String),
  node_id: option.Option(NodeId),
  backend_node_id: option.Option(BackendNodeId),
  object_id: option.Option(runtime.RemoteObjectId),
) {
  let _ =
    chrome.call(
      browser_subject,
      "DOM.setFileInputFiles",
      option.Some(json.object(
        [#("files", json.array(files, of: json.string))]
        |> utils.add_optional(node_id, fn(inner_value__) {
          #("nodeId", encode__node_id(inner_value__))
        })
        |> utils.add_optional(backend_node_id, fn(inner_value__) {
          #("backendNodeId", encode__backend_node_id(inner_value__))
        })
        |> utils.add_optional(object_id, fn(inner_value__) {
          #("objectId", runtime.encode__remote_object_id(inner_value__))
        }),
      )),
      10_000,
    )
  Nil
}

/// Sets node name for a node with given id.
pub fn set_node_name(browser_subject, node_id: NodeId, name: String) {
  chrome.call(
    browser_subject,
    "DOM.setNodeName",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("name", json.string(name)),
      ]),
    ),
    10_000,
  )
  |> result.try(fn(result__) {
    decode__set_node_name_response(result__)
    |> result.replace_error(chrome.ProtocolError)
  })
}

/// Sets node value for a node with given id.
pub fn set_node_value(browser_subject, node_id: NodeId, value: String) {
  let _ =
    chrome.call(
      browser_subject,
      "DOM.setNodeValue",
      option.Some(
        json.object([
          #("nodeId", encode__node_id(node_id)),
          #("value", json.string(value)),
        ]),
      ),
      10_000,
    )
  Nil
}

/// Sets node HTML markup, returns new node id.
pub fn set_outer_html(browser_subject, node_id: NodeId, outer_html: String) {
  let _ =
    chrome.call(
      browser_subject,
      "DOM.setOuterHTML",
      option.Some(
        json.object([
          #("nodeId", encode__node_id(node_id)),
          #("outerHTML", json.string(outer_html)),
        ]),
      ),
      10_000,
    )
  Nil
}
