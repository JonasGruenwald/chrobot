//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Input Domain  
////
//// This protocol domain has no description.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Input/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import gleam/dynamic
import gleam/json
import gleam/option
import gleam/result

pub type TouchPoint {
  TouchPoint(
    x: Float,
    y: Float,
    radius_x: option.Option(Float),
    radius_y: option.Option(Float),
    rotation_angle: option.Option(Float),
    force: option.Option(Float),
    tilt_x: option.Option(Float),
    tilt_y: option.Option(Float),
    id: option.Option(Float),
  )
}

@internal
pub fn encode__touch_point(value__: TouchPoint) {
  json.object([
    #("x", json.float(value__.x)),
    #("y", json.float(value__.y)),
    #("radiusX", {
      case value__.radius_x {
        option.Some(value__) -> json.float(value__)
        option.None -> json.null()
      }
    }),
    #("radiusY", {
      case value__.radius_y {
        option.Some(value__) -> json.float(value__)
        option.None -> json.null()
      }
    }),
    #("rotationAngle", {
      case value__.rotation_angle {
        option.Some(value__) -> json.float(value__)
        option.None -> json.null()
      }
    }),
    #("force", {
      case value__.force {
        option.Some(value__) -> json.float(value__)
        option.None -> json.null()
      }
    }),
    #("tiltX", {
      case value__.tilt_x {
        option.Some(value__) -> json.float(value__)
        option.None -> json.null()
      }
    }),
    #("tiltY", {
      case value__.tilt_y {
        option.Some(value__) -> json.float(value__)
        option.None -> json.null()
      }
    }),
    #("id", {
      case value__.id {
        option.Some(value__) -> json.float(value__)
        option.None -> json.null()
      }
    }),
  ])
}

@internal
pub fn decode__touch_point(value__: dynamic.Dynamic) {
  use x <- result.try(dynamic.field("x", dynamic.float)(value__))
  use y <- result.try(dynamic.field("y", dynamic.float)(value__))
  use radius_x <- result.try(dynamic.optional_field("radiusX", dynamic.float)(
    value__,
  ))
  use radius_y <- result.try(dynamic.optional_field("radiusY", dynamic.float)(
    value__,
  ))
  use rotation_angle <- result.try(dynamic.optional_field(
    "rotationAngle",
    dynamic.float,
  )(value__))
  use force <- result.try(dynamic.optional_field("force", dynamic.float)(
    value__,
  ))
  use tilt_x <- result.try(dynamic.optional_field("tiltX", dynamic.float)(
    value__,
  ))
  use tilt_y <- result.try(dynamic.optional_field("tiltY", dynamic.float)(
    value__,
  ))
  use id <- result.try(dynamic.optional_field("id", dynamic.float)(value__))

  Ok(TouchPoint(
    x: x,
    y: y,
    radius_x: radius_x,
    radius_y: radius_y,
    rotation_angle: rotation_angle,
    force: force,
    tilt_x: tilt_x,
    tilt_y: tilt_y,
    id: id,
  ))
}

pub type MouseButton {
  MouseButtonNone
  MouseButtonLeft
  MouseButtonMiddle
  MouseButtonRight
  MouseButtonBack
  MouseButtonForward
}

@internal
pub fn encode__mouse_button(value__: MouseButton) {
  case value__ {
    MouseButtonNone -> "none"
    MouseButtonLeft -> "left"
    MouseButtonMiddle -> "middle"
    MouseButtonRight -> "right"
    MouseButtonBack -> "back"
    MouseButtonForward -> "forward"
  }
  |> json.string()
}

@internal
pub fn decode__mouse_button(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("none") -> Ok(MouseButtonNone)
    Ok("left") -> Ok(MouseButtonLeft)
    Ok("middle") -> Ok(MouseButtonMiddle)
    Ok("right") -> Ok(MouseButtonRight)
    Ok("back") -> Ok(MouseButtonBack)
    Ok("forward") -> Ok(MouseButtonForward)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// UTC time in seconds, counted from January 1, 1970.
pub type TimeSinceEpoch {
  TimeSinceEpoch(Float)
}

@internal
pub fn encode__time_since_epoch(value__: TimeSinceEpoch) {
  case value__ {
    TimeSinceEpoch(inner_value__) -> json.float(inner_value__)
  }
}

@internal
pub fn decode__time_since_epoch(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(TimeSinceEpoch, dynamic.float)
}
