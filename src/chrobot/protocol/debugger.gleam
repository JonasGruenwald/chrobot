//// > âš™ï¸  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Debugger Domain  
////
//// Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
//// breakpoints, stepping through execution, exploring stack traces, etc.  
////
//// [ðŸ“–   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Debugger/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// |                     Run `codegen.sh` to regenerate.                     |
// ---------------------------------------------------------------------------

import chrobot/chrome
import chrobot/internal/utils
import chrobot/protocol/runtime
import gleam/dynamic/decode
import gleam/json
import gleam/option
import gleam/result

/// Breakpoint identifier.
pub type BreakpointId {
  BreakpointId(String)
}

@internal
pub fn encode__breakpoint_id(value__: BreakpointId) {
  case value__ {
    BreakpointId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__breakpoint_id() {
  {
    use value__ <- decode.then(decode.string)
    decode.success(BreakpointId(value__))
  }
}

/// Call frame identifier.
pub type CallFrameId {
  CallFrameId(String)
}

@internal
pub fn encode__call_frame_id(value__: CallFrameId) {
  case value__ {
    CallFrameId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__call_frame_id() {
  {
    use value__ <- decode.then(decode.string)
    decode.success(CallFrameId(value__))
  }
}

/// Location in the source code.
pub type Location {
  Location(
    /// Script identifier as reported in the `Debugger.scriptParsed`.  
    script_id: runtime.ScriptId,
    /// Line number in the script (0-based).  
    line_number: Int,
    /// Column number in the script (0-based).  
    column_number: option.Option(Int),
  )
}

@internal
pub fn encode__location(value__: Location) {
  json.object(
    [
      #("scriptId", runtime.encode__script_id(value__.script_id)),
      #("lineNumber", json.int(value__.line_number)),
    ]
    |> utils.add_optional(value__.column_number, fn(inner_value__) {
      #("columnNumber", json.int(inner_value__))
    }),
  )
}

@internal
pub fn decode__location() {
  {
    use script_id <- decode.field("scriptId", runtime.decode__script_id())
    use line_number <- decode.field("lineNumber", decode.int)
    use column_number <- decode.optional_field(
      "columnNumber",
      option.None,
      decode.optional(decode.int),
    )

    decode.success(Location(
      script_id: script_id,
      line_number: line_number,
      column_number: column_number,
    ))
  }
}

/// JavaScript call frame. Array of call frames form the call stack.
pub type CallFrame {
  CallFrame(
    /// Call frame identifier. This identifier is only valid while the virtual machine is paused.  
    call_frame_id: CallFrameId,
    /// Name of the JavaScript function called on this call frame.  
    function_name: String,
    /// Location in the source code.  
    function_location: option.Option(Location),
    /// Location in the source code.  
    location: Location,
    /// Scope chain for this call frame.  
    scope_chain: List(Scope),
    /// `this` object for this call frame.  
    this: runtime.RemoteObject,
    /// The value being returned, if the function is at return point.  
    return_value: option.Option(runtime.RemoteObject),
  )
}

@internal
pub fn encode__call_frame(value__: CallFrame) {
  json.object(
    [
      #("callFrameId", encode__call_frame_id(value__.call_frame_id)),
      #("functionName", json.string(value__.function_name)),
      #("location", encode__location(value__.location)),
      #("scopeChain", json.array(value__.scope_chain, of: encode__scope)),
      #("this", runtime.encode__remote_object(value__.this)),
    ]
    |> utils.add_optional(value__.function_location, fn(inner_value__) {
      #("functionLocation", encode__location(inner_value__))
    })
    |> utils.add_optional(value__.return_value, fn(inner_value__) {
      #("returnValue", runtime.encode__remote_object(inner_value__))
    }),
  )
}

@internal
pub fn decode__call_frame() {
  {
    use call_frame_id <- decode.field("callFrameId", decode__call_frame_id())
    use function_name <- decode.field("functionName", decode.string)
    use function_location <- decode.optional_field(
      "functionLocation",
      option.None,
      decode.optional(decode__location()),
    )
    use location <- decode.field("location", decode__location())
    use scope_chain <- decode.field("scopeChain", decode.list(decode__scope()))
    use this <- decode.field("this", runtime.decode__remote_object())
    use return_value <- decode.optional_field(
      "returnValue",
      option.None,
      decode.optional(runtime.decode__remote_object()),
    )

    decode.success(CallFrame(
      call_frame_id: call_frame_id,
      function_name: function_name,
      function_location: function_location,
      location: location,
      scope_chain: scope_chain,
      this: this,
      return_value: return_value,
    ))
  }
}

/// Scope description.
pub type Scope {
  Scope(
    /// Scope type.  
    type_: ScopeType,
    /// Object representing the scope. For `global` and `with` scopes it represents the actual
    /// object; for the rest of the scopes, it is artificial transient object enumerating scope
    /// variables as its properties.  
    object: runtime.RemoteObject,
    name: option.Option(String),
    /// Location in the source code where scope starts  
    start_location: option.Option(Location),
    /// Location in the source code where scope ends  
    end_location: option.Option(Location),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `type` of `Scope`
pub type ScopeType {
  ScopeTypeGlobal
  ScopeTypeLocal
  ScopeTypeWith
  ScopeTypeClosure
  ScopeTypeCatch
  ScopeTypeBlock
  ScopeTypeScript
  ScopeTypeEval
  ScopeTypeModule
  ScopeTypeWasmExpressionStack
}

@internal
pub fn encode__scope_type(value__: ScopeType) {
  case value__ {
    ScopeTypeGlobal -> "global"
    ScopeTypeLocal -> "local"
    ScopeTypeWith -> "with"
    ScopeTypeClosure -> "closure"
    ScopeTypeCatch -> "catch"
    ScopeTypeBlock -> "block"
    ScopeTypeScript -> "script"
    ScopeTypeEval -> "eval"
    ScopeTypeModule -> "module"
    ScopeTypeWasmExpressionStack -> "wasm-expression-stack"
  }
  |> json.string()
}

@internal
pub fn decode__scope_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "global" -> decode.success(ScopeTypeGlobal)
      "local" -> decode.success(ScopeTypeLocal)
      "with" -> decode.success(ScopeTypeWith)
      "closure" -> decode.success(ScopeTypeClosure)
      "catch" -> decode.success(ScopeTypeCatch)
      "block" -> decode.success(ScopeTypeBlock)
      "script" -> decode.success(ScopeTypeScript)
      "eval" -> decode.success(ScopeTypeEval)
      "module" -> decode.success(ScopeTypeModule)
      "wasm-expression-stack" -> decode.success(ScopeTypeWasmExpressionStack)
      _ -> decode.failure(ScopeTypeGlobal, "valid enum property")
    }
  }
}

@internal
pub fn encode__scope(value__: Scope) {
  json.object(
    [
      #("type", encode__scope_type(value__.type_)),
      #("object", runtime.encode__remote_object(value__.object)),
    ]
    |> utils.add_optional(value__.name, fn(inner_value__) {
      #("name", json.string(inner_value__))
    })
    |> utils.add_optional(value__.start_location, fn(inner_value__) {
      #("startLocation", encode__location(inner_value__))
    })
    |> utils.add_optional(value__.end_location, fn(inner_value__) {
      #("endLocation", encode__location(inner_value__))
    }),
  )
}

@internal
pub fn decode__scope() {
  {
    use type_ <- decode.field("type", decode__scope_type())
    use object <- decode.field("object", runtime.decode__remote_object())
    use name <- decode.optional_field(
      "name",
      option.None,
      decode.optional(decode.string),
    )
    use start_location <- decode.optional_field(
      "startLocation",
      option.None,
      decode.optional(decode__location()),
    )
    use end_location <- decode.optional_field(
      "endLocation",
      option.None,
      decode.optional(decode__location()),
    )

    decode.success(Scope(
      type_: type_,
      object: object,
      name: name,
      start_location: start_location,
      end_location: end_location,
    ))
  }
}

/// Search match for resource.
pub type SearchMatch {
  SearchMatch(
    /// Line number in resource content.  
    line_number: Float,
    /// Line with match content.  
    line_content: String,
  )
}

@internal
pub fn encode__search_match(value__: SearchMatch) {
  json.object([
    #("lineNumber", json.float(value__.line_number)),
    #("lineContent", json.string(value__.line_content)),
  ])
}

@internal
pub fn decode__search_match() {
  {
    use line_number <- decode.field("lineNumber", decode.float)
    use line_content <- decode.field("lineContent", decode.string)

    decode.success(SearchMatch(
      line_number: line_number,
      line_content: line_content,
    ))
  }
}

pub type BreakLocation {
  BreakLocation(
    /// Script identifier as reported in the `Debugger.scriptParsed`.  
    script_id: runtime.ScriptId,
    /// Line number in the script (0-based).  
    line_number: Int,
    /// Column number in the script (0-based).  
    column_number: option.Option(Int),
    type_: option.Option(BreakLocationType),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `type` of `BreakLocation`
pub type BreakLocationType {
  BreakLocationTypeDebuggerStatement
  BreakLocationTypeCall
  BreakLocationTypeReturn
}

@internal
pub fn encode__break_location_type(value__: BreakLocationType) {
  case value__ {
    BreakLocationTypeDebuggerStatement -> "debuggerStatement"
    BreakLocationTypeCall -> "call"
    BreakLocationTypeReturn -> "return"
  }
  |> json.string()
}

@internal
pub fn decode__break_location_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "debuggerStatement" -> decode.success(BreakLocationTypeDebuggerStatement)
      "call" -> decode.success(BreakLocationTypeCall)
      "return" -> decode.success(BreakLocationTypeReturn)
      _ ->
        decode.failure(
          BreakLocationTypeDebuggerStatement,
          "valid enum property",
        )
    }
  }
}

@internal
pub fn encode__break_location(value__: BreakLocation) {
  json.object(
    [
      #("scriptId", runtime.encode__script_id(value__.script_id)),
      #("lineNumber", json.int(value__.line_number)),
    ]
    |> utils.add_optional(value__.column_number, fn(inner_value__) {
      #("columnNumber", json.int(inner_value__))
    })
    |> utils.add_optional(value__.type_, fn(inner_value__) {
      #("type", encode__break_location_type(inner_value__))
    }),
  )
}

@internal
pub fn decode__break_location() {
  {
    use script_id <- decode.field("scriptId", runtime.decode__script_id())
    use line_number <- decode.field("lineNumber", decode.int)
    use column_number <- decode.optional_field(
      "columnNumber",
      option.None,
      decode.optional(decode.int),
    )
    use type_ <- decode.optional_field(
      "type",
      option.None,
      decode.optional(decode__break_location_type()),
    )

    decode.success(BreakLocation(
      script_id: script_id,
      line_number: line_number,
      column_number: column_number,
      type_: type_,
    ))
  }
}

/// Enum of possible script languages.
pub type ScriptLanguage {
  ScriptLanguageJavaScript
  ScriptLanguageWebAssembly
}

@internal
pub fn encode__script_language(value__: ScriptLanguage) {
  case value__ {
    ScriptLanguageJavaScript -> "JavaScript"
    ScriptLanguageWebAssembly -> "WebAssembly"
  }
  |> json.string()
}

@internal
pub fn decode__script_language() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "JavaScript" -> decode.success(ScriptLanguageJavaScript)
      "WebAssembly" -> decode.success(ScriptLanguageWebAssembly)
      _ -> decode.failure(ScriptLanguageJavaScript, "valid enum property")
    }
  }
}

/// Debug symbols available for a wasm script.
pub type DebugSymbols {
  DebugSymbols(
    /// Type of the debug symbols.  
    type_: DebugSymbolsType,
    /// URL of the external symbol source.  
    external_url: option.Option(String),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `type` of `DebugSymbols`
pub type DebugSymbolsType {
  DebugSymbolsTypeNone
  DebugSymbolsTypeSourceMap
  DebugSymbolsTypeEmbeddedDwarf
  DebugSymbolsTypeExternalDwarf
}

@internal
pub fn encode__debug_symbols_type(value__: DebugSymbolsType) {
  case value__ {
    DebugSymbolsTypeNone -> "None"
    DebugSymbolsTypeSourceMap -> "SourceMap"
    DebugSymbolsTypeEmbeddedDwarf -> "EmbeddedDWARF"
    DebugSymbolsTypeExternalDwarf -> "ExternalDWARF"
  }
  |> json.string()
}

@internal
pub fn decode__debug_symbols_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "None" -> decode.success(DebugSymbolsTypeNone)
      "SourceMap" -> decode.success(DebugSymbolsTypeSourceMap)
      "EmbeddedDWARF" -> decode.success(DebugSymbolsTypeEmbeddedDwarf)
      "ExternalDWARF" -> decode.success(DebugSymbolsTypeExternalDwarf)
      _ -> decode.failure(DebugSymbolsTypeNone, "valid enum property")
    }
  }
}

@internal
pub fn encode__debug_symbols(value__: DebugSymbols) {
  json.object(
    [
      #("type", encode__debug_symbols_type(value__.type_)),
    ]
    |> utils.add_optional(value__.external_url, fn(inner_value__) {
      #("externalURL", json.string(inner_value__))
    }),
  )
}

@internal
pub fn decode__debug_symbols() {
  {
    use type_ <- decode.field("type", decode__debug_symbols_type())
    use external_url <- decode.optional_field(
      "externalURL",
      option.None,
      decode.optional(decode.string),
    )

    decode.success(DebugSymbols(type_: type_, external_url: external_url))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `evaluate_on_call_frame`
pub type EvaluateOnCallFrameResponse {
  EvaluateOnCallFrameResponse(
    /// Object wrapper for the evaluation result.  
    result: runtime.RemoteObject,
    /// Exception details.  
    exception_details: option.Option(runtime.ExceptionDetails),
  )
}

@internal
pub fn decode__evaluate_on_call_frame_response() {
  {
    use result <- decode.field("result", runtime.decode__remote_object())
    use exception_details <- decode.optional_field(
      "exceptionDetails",
      option.None,
      decode.optional(runtime.decode__exception_details()),
    )

    decode.success(EvaluateOnCallFrameResponse(
      result: result,
      exception_details: exception_details,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_possible_breakpoints`
pub type GetPossibleBreakpointsResponse {
  GetPossibleBreakpointsResponse(
    /// List of the possible breakpoint locations.  
    locations: List(BreakLocation),
  )
}

@internal
pub fn decode__get_possible_breakpoints_response() {
  {
    use locations <- decode.field(
      "locations",
      decode.list(decode__break_location()),
    )

    decode.success(GetPossibleBreakpointsResponse(locations: locations))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_script_source`
pub type GetScriptSourceResponse {
  GetScriptSourceResponse(
    /// Script source (empty in case of Wasm bytecode).  
    script_source: String,
    /// Wasm bytecode. (Encoded as a base64 string when passed over JSON)  
    bytecode: option.Option(String),
  )
}

@internal
pub fn decode__get_script_source_response() {
  {
    use script_source <- decode.field("scriptSource", decode.string)
    use bytecode <- decode.optional_field(
      "bytecode",
      option.None,
      decode.optional(decode.string),
    )

    decode.success(GetScriptSourceResponse(
      script_source: script_source,
      bytecode: bytecode,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `search_in_content`
pub type SearchInContentResponse {
  SearchInContentResponse(
    /// List of search matches.  
    result: List(SearchMatch),
  )
}

@internal
pub fn decode__search_in_content_response() {
  {
    use result <- decode.field("result", decode.list(decode__search_match()))

    decode.success(SearchInContentResponse(result: result))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_breakpoint`
pub type SetBreakpointResponse {
  SetBreakpointResponse(
    /// Id of the created breakpoint for further reference.  
    breakpoint_id: BreakpointId,
    /// Location this breakpoint resolved into.  
    actual_location: Location,
  )
}

@internal
pub fn decode__set_breakpoint_response() {
  {
    use breakpoint_id <- decode.field("breakpointId", decode__breakpoint_id())
    use actual_location <- decode.field("actualLocation", decode__location())

    decode.success(SetBreakpointResponse(
      breakpoint_id: breakpoint_id,
      actual_location: actual_location,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_instrumentation_breakpoint`
pub type SetInstrumentationBreakpointResponse {
  SetInstrumentationBreakpointResponse(
    /// Id of the created breakpoint for further reference.  
    breakpoint_id: BreakpointId,
  )
}

@internal
pub fn decode__set_instrumentation_breakpoint_response() {
  {
    use breakpoint_id <- decode.field("breakpointId", decode__breakpoint_id())

    decode.success(SetInstrumentationBreakpointResponse(
      breakpoint_id: breakpoint_id,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_breakpoint_by_url`
pub type SetBreakpointByUrlResponse {
  SetBreakpointByUrlResponse(
    /// Id of the created breakpoint for further reference.  
    breakpoint_id: BreakpointId,
    /// List of the locations this breakpoint resolved into upon addition.  
    locations: List(Location),
  )
}

@internal
pub fn decode__set_breakpoint_by_url_response() {
  {
    use breakpoint_id <- decode.field("breakpointId", decode__breakpoint_id())
    use locations <- decode.field("locations", decode.list(decode__location()))

    decode.success(SetBreakpointByUrlResponse(
      breakpoint_id: breakpoint_id,
      locations: locations,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_script_source`
pub type SetScriptSourceResponse {
  SetScriptSourceResponse(
    /// Exception details if any. Only present when `status` is `CompileError`.  
    exception_details: option.Option(runtime.ExceptionDetails),
  )
}

@internal
pub fn decode__set_script_source_response() {
  {
    use exception_details <- decode.optional_field(
      "exceptionDetails",
      option.None,
      decode.optional(runtime.decode__exception_details()),
    )

    decode.success(SetScriptSourceResponse(exception_details: exception_details))
  }
}

/// Continues execution until specific location is reached.
/// 
/// Parameters:  
///  - `location` : Location to continue to.
///  - `target_call_frames`
/// 
/// Returns:  
/// 
pub fn continue_to_location(
  callback__,
  location location: Location,
  target_call_frames target_call_frames: option.Option(
    ContinueToLocationTargetCallFrames,
  ),
) {
  callback__(
    "Debugger.continueToLocation",
    option.Some(json.object(
      [
        #("location", encode__location(location)),
      ]
      |> utils.add_optional(target_call_frames, fn(inner_value__) {
        #(
          "targetCallFrames",
          encode__continue_to_location_target_call_frames(inner_value__),
        )
      }),
    )),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `targetCallFrames` of `continueToLocation`
pub type ContinueToLocationTargetCallFrames {
  ContinueToLocationTargetCallFramesAny
  ContinueToLocationTargetCallFramesCurrent
}

@internal
pub fn encode__continue_to_location_target_call_frames(
  value__: ContinueToLocationTargetCallFrames,
) {
  case value__ {
    ContinueToLocationTargetCallFramesAny -> "any"
    ContinueToLocationTargetCallFramesCurrent -> "current"
  }
  |> json.string()
}

@internal
pub fn decode__continue_to_location_target_call_frames() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "any" -> decode.success(ContinueToLocationTargetCallFramesAny)
      "current" -> decode.success(ContinueToLocationTargetCallFramesCurrent)
      _ ->
        decode.failure(
          ContinueToLocationTargetCallFramesAny,
          "valid enum property",
        )
    }
  }
}

/// Disables debugger for given page.
/// 
pub fn disable(callback__) {
  callback__("Debugger.disable", option.None)
}

/// Enables debugger for the given page. Clients should not assume that the debugging has been
/// enabled until the result for this command is received.
/// 
/// Parameters:  
/// 
/// Returns:  
/// 
pub fn enable(callback__) {
  callback__("Debugger.enable", option.None)
}

/// Evaluates expression on a given call frame.
/// 
/// Parameters:  
///  - `call_frame_id` : Call frame identifier to evaluate on.
///  - `expression` : Expression to evaluate.
///  - `object_group` : String object group name to put result into (allows rapid releasing resulting object handles
/// using `releaseObjectGroup`).
///  - `include_command_line_api` : Specifies whether command line API should be available to the evaluated expression, defaults
/// to false.
///  - `silent` : In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
///  - `return_by_value` : Whether the result is expected to be a JSON object that should be sent by value.
///  - `throw_on_side_effect` : Whether to throw an exception if side effect cannot be ruled out during evaluation.
/// 
/// Returns:  
///  - `result` : Object wrapper for the evaluation result.
///  - `exception_details` : Exception details.
/// 
pub fn evaluate_on_call_frame(
  callback__,
  call_frame_id call_frame_id: CallFrameId,
  expression expression: String,
  object_group object_group: option.Option(String),
  include_command_line_api include_command_line_api: option.Option(Bool),
  silent silent: option.Option(Bool),
  return_by_value return_by_value: option.Option(Bool),
  throw_on_side_effect throw_on_side_effect: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Debugger.evaluateOnCallFrame",
    option.Some(json.object(
      [
        #("callFrameId", encode__call_frame_id(call_frame_id)),
        #("expression", json.string(expression)),
      ]
      |> utils.add_optional(object_group, fn(inner_value__) {
        #("objectGroup", json.string(inner_value__))
      })
      |> utils.add_optional(include_command_line_api, fn(inner_value__) {
        #("includeCommandLineAPI", json.bool(inner_value__))
      })
      |> utils.add_optional(silent, fn(inner_value__) {
        #("silent", json.bool(inner_value__))
      })
      |> utils.add_optional(return_by_value, fn(inner_value__) {
        #("returnByValue", json.bool(inner_value__))
      })
      |> utils.add_optional(throw_on_side_effect, fn(inner_value__) {
        #("throwOnSideEffect", json.bool(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__evaluate_on_call_frame_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns possible locations for breakpoint. scriptId in start and end range locations should be
/// the same.
/// 
/// Parameters:  
///  - `start` : Start of range to search possible breakpoint locations in.
///  - `end` : End of range to search possible breakpoint locations in (excluding). When not specified, end
/// of scripts is used as end of range.
///  - `restrict_to_function` : Only consider locations which are in the same (non-nested) function as start.
/// 
/// Returns:  
///  - `locations` : List of the possible breakpoint locations.
/// 
pub fn get_possible_breakpoints(
  callback__,
  start start: Location,
  end end: option.Option(Location),
  restrict_to_function restrict_to_function: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Debugger.getPossibleBreakpoints",
    option.Some(json.object(
      [
        #("start", encode__location(start)),
      ]
      |> utils.add_optional(end, fn(inner_value__) {
        #("end", encode__location(inner_value__))
      })
      |> utils.add_optional(restrict_to_function, fn(inner_value__) {
        #("restrictToFunction", json.bool(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__get_possible_breakpoints_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns source for the script with given id.
/// 
/// Parameters:  
///  - `script_id` : Id of the script to get source for.
/// 
/// Returns:  
///  - `script_source` : Script source (empty in case of Wasm bytecode).
///  - `bytecode` : Wasm bytecode. (Encoded as a base64 string when passed over JSON)
/// 
pub fn get_script_source(callback__, script_id script_id: runtime.ScriptId) {
  use result__ <- result.try(callback__(
    "Debugger.getScriptSource",
    option.Some(
      json.object([
        #("scriptId", runtime.encode__script_id(script_id)),
      ]),
    ),
  ))

  decode.run(result__, decode__get_script_source_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Stops on the next JavaScript statement.
/// 
pub fn pause(callback__) {
  callback__("Debugger.pause", option.None)
}

/// Removes JavaScript breakpoint.
/// 
/// Parameters:  
///  - `breakpoint_id`
/// 
/// Returns:  
/// 
pub fn remove_breakpoint(callback__, breakpoint_id breakpoint_id: BreakpointId) {
  callback__(
    "Debugger.removeBreakpoint",
    option.Some(
      json.object([
        #("breakpointId", encode__breakpoint_id(breakpoint_id)),
      ]),
    ),
  )
}

/// Restarts particular call frame from the beginning. The old, deprecated
/// behavior of `restartFrame` is to stay paused and allow further CDP commands
/// after a restart was scheduled. This can cause problems with restarting, so
/// we now continue execution immediatly after it has been scheduled until we
/// reach the beginning of the restarted frame.
/// 
/// To stay back-wards compatible, `restartFrame` now expects a `mode`
/// parameter to be present. If the `mode` parameter is missing, `restartFrame`
/// errors out.
/// 
/// The various return values are deprecated and `callFrames` is always empty.
/// Use the call frames from the `Debugger#paused` events instead, that fires
/// once V8 pauses at the beginning of the restarted function.
/// 
/// Parameters:  
///  - `call_frame_id` : Call frame identifier to evaluate on.
/// 
/// Returns:  
/// 
pub fn restart_frame(callback__, call_frame_id call_frame_id: CallFrameId) {
  callback__(
    "Debugger.restartFrame",
    option.Some(
      json.object([
        #("callFrameId", encode__call_frame_id(call_frame_id)),
      ]),
    ),
  )
}

/// Resumes JavaScript execution.
/// 
/// Parameters:  
///  - `terminate_on_resume` : Set to true to terminate execution upon resuming execution. In contrast
/// to Runtime.terminateExecution, this will allows to execute further
/// JavaScript (i.e. via evaluation) until execution of the paused code
/// is actually resumed, at which point termination is triggered.
/// If execution is currently not paused, this parameter has no effect.
/// 
/// Returns:  
/// 
pub fn resume(
  callback__,
  terminate_on_resume terminate_on_resume: option.Option(Bool),
) {
  callback__(
    "Debugger.resume",
    option.Some(json.object(
      []
      |> utils.add_optional(terminate_on_resume, fn(inner_value__) {
        #("terminateOnResume", json.bool(inner_value__))
      }),
    )),
  )
}

/// Searches for given string in script content.
/// 
/// Parameters:  
///  - `script_id` : Id of the script to search in.
///  - `query` : String to search for.
///  - `case_sensitive` : If true, search is case sensitive.
///  - `is_regex` : If true, treats string parameter as regex.
/// 
/// Returns:  
///  - `result` : List of search matches.
/// 
pub fn search_in_content(
  callback__,
  script_id script_id: runtime.ScriptId,
  query query: String,
  case_sensitive case_sensitive: option.Option(Bool),
  is_regex is_regex: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Debugger.searchInContent",
    option.Some(json.object(
      [
        #("scriptId", runtime.encode__script_id(script_id)),
        #("query", json.string(query)),
      ]
      |> utils.add_optional(case_sensitive, fn(inner_value__) {
        #("caseSensitive", json.bool(inner_value__))
      })
      |> utils.add_optional(is_regex, fn(inner_value__) {
        #("isRegex", json.bool(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__search_in_content_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Enables or disables async call stacks tracking.
/// 
/// Parameters:  
///  - `max_depth` : Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
/// call stacks (default).
/// 
/// Returns:  
/// 
pub fn set_async_call_stack_depth(callback__, max_depth max_depth: Int) {
  callback__(
    "Debugger.setAsyncCallStackDepth",
    option.Some(
      json.object([
        #("maxDepth", json.int(max_depth)),
      ]),
    ),
  )
}

/// Sets JavaScript breakpoint at a given location.
/// 
/// Parameters:  
///  - `location` : Location to set breakpoint in.
///  - `condition` : Expression to use as a breakpoint condition. When specified, debugger will only stop on the
/// breakpoint if this expression evaluates to true.
/// 
/// Returns:  
///  - `breakpoint_id` : Id of the created breakpoint for further reference.
///  - `actual_location` : Location this breakpoint resolved into.
/// 
pub fn set_breakpoint(
  callback__,
  location location: Location,
  condition condition: option.Option(String),
) {
  use result__ <- result.try(callback__(
    "Debugger.setBreakpoint",
    option.Some(json.object(
      [
        #("location", encode__location(location)),
      ]
      |> utils.add_optional(condition, fn(inner_value__) {
        #("condition", json.string(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__set_breakpoint_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Sets instrumentation breakpoint.
/// 
/// Parameters:  
///  - `instrumentation` : Instrumentation name.
/// 
/// Returns:  
///  - `breakpoint_id` : Id of the created breakpoint for further reference.
/// 
pub fn set_instrumentation_breakpoint(
  callback__,
  instrumentation instrumentation: SetInstrumentationBreakpointInstrumentation,
) {
  use result__ <- result.try(callback__(
    "Debugger.setInstrumentationBreakpoint",
    option.Some(
      json.object([
        #(
          "instrumentation",
          encode__set_instrumentation_breakpoint_instrumentation(
            instrumentation,
          ),
        ),
      ]),
    ),
  ))

  decode.run(result__, decode__set_instrumentation_breakpoint_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `instrumentation` of `setInstrumentationBreakpoint`
pub type SetInstrumentationBreakpointInstrumentation {
  SetInstrumentationBreakpointInstrumentationBeforeScriptExecution
  SetInstrumentationBreakpointInstrumentationBeforeScriptWithSourceMapExecution
}

@internal
pub fn encode__set_instrumentation_breakpoint_instrumentation(
  value__: SetInstrumentationBreakpointInstrumentation,
) {
  case value__ {
    SetInstrumentationBreakpointInstrumentationBeforeScriptExecution ->
      "beforeScriptExecution"
    SetInstrumentationBreakpointInstrumentationBeforeScriptWithSourceMapExecution ->
      "beforeScriptWithSourceMapExecution"
  }
  |> json.string()
}

@internal
pub fn decode__set_instrumentation_breakpoint_instrumentation() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "beforeScriptExecution" ->
        decode.success(
          SetInstrumentationBreakpointInstrumentationBeforeScriptExecution,
        )
      "beforeScriptWithSourceMapExecution" ->
        decode.success(
          SetInstrumentationBreakpointInstrumentationBeforeScriptWithSourceMapExecution,
        )
      _ ->
        decode.failure(
          SetInstrumentationBreakpointInstrumentationBeforeScriptExecution,
          "valid enum property",
        )
    }
  }
}

/// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
/// command is issued, all existing parsed scripts will have breakpoints resolved and returned in
/// `locations` property. Further matching script parsing will result in subsequent
/// `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
/// 
/// Parameters:  
///  - `line_number` : Line number to set breakpoint at.
///  - `url` : URL of the resources to set breakpoint on.
///  - `url_regex` : Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or
/// `urlRegex` must be specified.
///  - `script_hash` : Script hash of the resources to set breakpoint on.
///  - `column_number` : Offset in the line to set breakpoint at.
///  - `condition` : Expression to use as a breakpoint condition. When specified, debugger will only stop on the
/// breakpoint if this expression evaluates to true.
/// 
/// Returns:  
///  - `breakpoint_id` : Id of the created breakpoint for further reference.
///  - `locations` : List of the locations this breakpoint resolved into upon addition.
/// 
pub fn set_breakpoint_by_url(
  callback__,
  line_number line_number: Int,
  url url: option.Option(String),
  url_regex url_regex: option.Option(String),
  script_hash script_hash: option.Option(String),
  column_number column_number: option.Option(Int),
  condition condition: option.Option(String),
) {
  use result__ <- result.try(callback__(
    "Debugger.setBreakpointByUrl",
    option.Some(json.object(
      [
        #("lineNumber", json.int(line_number)),
      ]
      |> utils.add_optional(url, fn(inner_value__) {
        #("url", json.string(inner_value__))
      })
      |> utils.add_optional(url_regex, fn(inner_value__) {
        #("urlRegex", json.string(inner_value__))
      })
      |> utils.add_optional(script_hash, fn(inner_value__) {
        #("scriptHash", json.string(inner_value__))
      })
      |> utils.add_optional(column_number, fn(inner_value__) {
        #("columnNumber", json.int(inner_value__))
      })
      |> utils.add_optional(condition, fn(inner_value__) {
        #("condition", json.string(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__set_breakpoint_by_url_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Activates / deactivates all breakpoints on the page.
/// 
/// Parameters:  
///  - `active` : New value for breakpoints active state.
/// 
/// Returns:  
/// 
pub fn set_breakpoints_active(callback__, active active: Bool) {
  callback__(
    "Debugger.setBreakpointsActive",
    option.Some(
      json.object([
        #("active", json.bool(active)),
      ]),
    ),
  )
}

/// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
/// or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
/// 
/// Parameters:  
///  - `state` : Pause on exceptions mode.
/// 
/// Returns:  
/// 
pub fn set_pause_on_exceptions(
  callback__,
  state state: SetPauseOnExceptionsState,
) {
  callback__(
    "Debugger.setPauseOnExceptions",
    option.Some(
      json.object([
        #("state", encode__set_pause_on_exceptions_state(state)),
      ]),
    ),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `state` of `setPauseOnExceptions`
pub type SetPauseOnExceptionsState {
  SetPauseOnExceptionsStateNone
  SetPauseOnExceptionsStateCaught
  SetPauseOnExceptionsStateUncaught
  SetPauseOnExceptionsStateAll
}

@internal
pub fn encode__set_pause_on_exceptions_state(value__: SetPauseOnExceptionsState) {
  case value__ {
    SetPauseOnExceptionsStateNone -> "none"
    SetPauseOnExceptionsStateCaught -> "caught"
    SetPauseOnExceptionsStateUncaught -> "uncaught"
    SetPauseOnExceptionsStateAll -> "all"
  }
  |> json.string()
}

@internal
pub fn decode__set_pause_on_exceptions_state() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "none" -> decode.success(SetPauseOnExceptionsStateNone)
      "caught" -> decode.success(SetPauseOnExceptionsStateCaught)
      "uncaught" -> decode.success(SetPauseOnExceptionsStateUncaught)
      "all" -> decode.success(SetPauseOnExceptionsStateAll)
      _ -> decode.failure(SetPauseOnExceptionsStateNone, "valid enum property")
    }
  }
}

/// Edits JavaScript source live.
/// 
/// In general, functions that are currently on the stack can not be edited with
/// a single exception: If the edited function is the top-most stack frame and
/// that is the only activation of that function on the stack. In this case
/// the live edit will be successful and a `Debugger.restartFrame` for the
/// top-most function is automatically triggered.
/// 
/// Parameters:  
///  - `script_id` : Id of the script to edit.
///  - `script_source` : New content of the script.
///  - `dry_run` : If true the change will not actually be applied. Dry run may be used to get result
/// description without actually modifying the code.
/// 
/// Returns:  
///  - `exception_details` : Exception details if any. Only present when `status` is `CompileError`.
/// 
pub fn set_script_source(
  callback__,
  script_id script_id: runtime.ScriptId,
  script_source script_source: String,
  dry_run dry_run: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Debugger.setScriptSource",
    option.Some(json.object(
      [
        #("scriptId", runtime.encode__script_id(script_id)),
        #("scriptSource", json.string(script_source)),
      ]
      |> utils.add_optional(dry_run, fn(inner_value__) {
        #("dryRun", json.bool(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__set_script_source_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
/// 
/// Parameters:  
///  - `skip` : New value for skip pauses state.
/// 
/// Returns:  
/// 
pub fn set_skip_all_pauses(callback__, skip skip: Bool) {
  callback__(
    "Debugger.setSkipAllPauses",
    option.Some(
      json.object([
        #("skip", json.bool(skip)),
      ]),
    ),
  )
}

/// Changes value of variable in a callframe. Object-based scopes are not supported and must be
/// mutated manually.
/// 
/// Parameters:  
///  - `scope_number` : 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'
/// scope types are allowed. Other scopes could be manipulated manually.
///  - `variable_name` : Variable name.
///  - `new_value` : New variable value.
///  - `call_frame_id` : Id of callframe that holds variable.
/// 
/// Returns:  
/// 
pub fn set_variable_value(
  callback__,
  scope_number scope_number: Int,
  variable_name variable_name: String,
  new_value new_value: runtime.CallArgument,
  call_frame_id call_frame_id: CallFrameId,
) {
  callback__(
    "Debugger.setVariableValue",
    option.Some(
      json.object([
        #("scopeNumber", json.int(scope_number)),
        #("variableName", json.string(variable_name)),
        #("newValue", runtime.encode__call_argument(new_value)),
        #("callFrameId", encode__call_frame_id(call_frame_id)),
      ]),
    ),
  )
}

/// Steps into the function call.
/// 
/// Parameters:  
/// 
/// Returns:  
/// 
pub fn step_into(callback__) {
  callback__("Debugger.stepInto", option.None)
}

/// Steps out of the function call.
/// 
pub fn step_out(callback__) {
  callback__("Debugger.stepOut", option.None)
}

/// Steps over the statement.
/// 
/// Parameters:  
/// 
/// Returns:  
/// 
pub fn step_over(callback__) {
  callback__("Debugger.stepOver", option.None)
}
