//// > âš™ï¸  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Security Domain  
////
//// Security  
////
//// [ðŸ“–   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Security/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// |                     Run `codegen.sh` to regenerate.                     |
// ---------------------------------------------------------------------------

import chrobot/internal/utils
import gleam/dynamic/decode
import gleam/json
import gleam/option

/// An internal certificate ID value.
pub type CertificateId {
  CertificateId(Int)
}

@internal
pub fn encode__certificate_id(value__: CertificateId) {
  case value__ {
    CertificateId(inner_value__) -> json.int(inner_value__)
  }
}

@internal
pub fn decode__certificate_id() {
  {
    use value__ <- decode.then(decode.int)
    decode.success(CertificateId(value__))
  }
}

/// A description of mixed content (HTTP resources on HTTPS pages), as defined by
/// https://www.w3.org/TR/mixed-content/#categories
pub type MixedContentType {
  MixedContentTypeBlockable
  MixedContentTypeOptionallyBlockable
  MixedContentTypeNone
}

@internal
pub fn encode__mixed_content_type(value__: MixedContentType) {
  case value__ {
    MixedContentTypeBlockable -> "blockable"
    MixedContentTypeOptionallyBlockable -> "optionally-blockable"
    MixedContentTypeNone -> "none"
  }
  |> json.string()
}

@internal
pub fn decode__mixed_content_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "blockable" -> decode.success(MixedContentTypeBlockable)
      "optionally-blockable" ->
        decode.success(MixedContentTypeOptionallyBlockable)
      "none" -> decode.success(MixedContentTypeNone)
      _ -> decode.failure(MixedContentTypeBlockable, "valid enum property")
    }
  }
}

/// The security level of a page or resource.
pub type SecurityState {
  SecurityStateUnknown
  SecurityStateNeutral
  SecurityStateInsecure
  SecurityStateSecure
  SecurityStateInfo
  SecurityStateInsecureBroken
}

@internal
pub fn encode__security_state(value__: SecurityState) {
  case value__ {
    SecurityStateUnknown -> "unknown"
    SecurityStateNeutral -> "neutral"
    SecurityStateInsecure -> "insecure"
    SecurityStateSecure -> "secure"
    SecurityStateInfo -> "info"
    SecurityStateInsecureBroken -> "insecure-broken"
  }
  |> json.string()
}

@internal
pub fn decode__security_state() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "unknown" -> decode.success(SecurityStateUnknown)
      "neutral" -> decode.success(SecurityStateNeutral)
      "insecure" -> decode.success(SecurityStateInsecure)
      "secure" -> decode.success(SecurityStateSecure)
      "info" -> decode.success(SecurityStateInfo)
      "insecure-broken" -> decode.success(SecurityStateInsecureBroken)
      _ -> decode.failure(SecurityStateUnknown, "valid enum property")
    }
  }
}

/// An explanation of an factor contributing to the security state.
pub type SecurityStateExplanation {
  SecurityStateExplanation(
    /// Security state representing the severity of the factor being explained.  
    security_state: SecurityState,
    /// Title describing the type of factor.  
    title: String,
    /// Short phrase describing the type of factor.  
    summary: String,
    /// Full text explanation of the factor.  
    description: String,
    /// The type of mixed content described by the explanation.  
    mixed_content_type: MixedContentType,
    /// Page certificate.  
    certificate: List(String),
    /// Recommendations to fix any issues.  
    recommendations: option.Option(List(String)),
  )
}

@internal
pub fn encode__security_state_explanation(value__: SecurityStateExplanation) {
  json.object(
    [
      #("securityState", encode__security_state(value__.security_state)),
      #("title", json.string(value__.title)),
      #("summary", json.string(value__.summary)),
      #("description", json.string(value__.description)),
      #(
        "mixedContentType",
        encode__mixed_content_type(value__.mixed_content_type),
      ),
      #("certificate", json.array(value__.certificate, of: json.string)),
    ]
    |> utils.add_optional(value__.recommendations, fn(inner_value__) {
      #("recommendations", json.array(inner_value__, of: json.string))
    }),
  )
}

@internal
pub fn decode__security_state_explanation() {
  {
    use security_state <- decode.field(
      "securityState",
      decode__security_state(),
    )
    use title <- decode.field("title", decode.string)
    use summary <- decode.field("summary", decode.string)
    use description <- decode.field("description", decode.string)
    use mixed_content_type <- decode.field(
      "mixedContentType",
      decode__mixed_content_type(),
    )
    use certificate <- decode.field("certificate", decode.list(decode.string))
    use recommendations <- decode.optional_field(
      "recommendations",
      option.None,
      decode.optional(decode.list(decode.string)),
    )

    decode.success(SecurityStateExplanation(
      security_state: security_state,
      title: title,
      summary: summary,
      description: description,
      mixed_content_type: mixed_content_type,
      certificate: certificate,
      recommendations: recommendations,
    ))
  }
}

/// The action to take when a certificate error occurs. continue will continue processing the
/// request and cancel will cancel the request.
pub type CertificateErrorAction {
  CertificateErrorActionContinue
  CertificateErrorActionCancel
}

@internal
pub fn encode__certificate_error_action(value__: CertificateErrorAction) {
  case value__ {
    CertificateErrorActionContinue -> "continue"
    CertificateErrorActionCancel -> "cancel"
  }
  |> json.string()
}

@internal
pub fn decode__certificate_error_action() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "continue" -> decode.success(CertificateErrorActionContinue)
      "cancel" -> decode.success(CertificateErrorActionCancel)
      _ -> decode.failure(CertificateErrorActionContinue, "valid enum property")
    }
  }
}

/// Disables tracking security state changes.
/// 
pub fn disable(callback__) {
  callback__("Security.disable", option.None)
}

/// Enables tracking security state changes.
/// 
pub fn enable(callback__) {
  callback__("Security.enable", option.None)
}

/// Enable/disable whether all certificate errors should be ignored.
/// 
/// Parameters:  
///  - `ignore` : If true, all certificate errors will be ignored.
/// 
/// Returns:  
/// 
pub fn set_ignore_certificate_errors(callback__, ignore ignore: Bool) {
  callback__(
    "Security.setIgnoreCertificateErrors",
    option.Some(
      json.object([
        #("ignore", json.bool(ignore)),
      ]),
    ),
  )
}
