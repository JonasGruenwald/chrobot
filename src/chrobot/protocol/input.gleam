//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Input Domain  
////
//// This protocol domain has no description.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Input/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// |                     Run `codegen.sh` to regenerate.                     |
// ---------------------------------------------------------------------------

import chrobot/internal/utils
import gleam/dynamic
import gleam/json
import gleam/option
import gleam/result

pub type TouchPoint {
  TouchPoint(
    /// X coordinate of the event relative to the main frame's viewport in CSS pixels.  
    x: Float,
    /// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
    /// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.  
    y: Float,
    /// X radius of the touch area (default: 1.0).  
    radius_x: option.Option(Float),
    /// Y radius of the touch area (default: 1.0).  
    radius_y: option.Option(Float),
    /// Rotation angle (default: 0.0).  
    rotation_angle: option.Option(Float),
    /// Force (default: 1.0).  
    force: option.Option(Float),
    /// The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)  
    tilt_x: option.Option(Float),
    /// The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).  
    tilt_y: option.Option(Float),
    /// Identifier used to track touch sources between events, must be unique within an event.  
    id: option.Option(Float),
  )
}

@internal
pub fn encode__touch_point(value__: TouchPoint) {
  json.object(
    [#("x", json.float(value__.x)), #("y", json.float(value__.y))]
    |> utils.add_optional(value__.radius_x, fn(inner_value__) {
      #("radiusX", json.float(inner_value__))
    })
    |> utils.add_optional(value__.radius_y, fn(inner_value__) {
      #("radiusY", json.float(inner_value__))
    })
    |> utils.add_optional(value__.rotation_angle, fn(inner_value__) {
      #("rotationAngle", json.float(inner_value__))
    })
    |> utils.add_optional(value__.force, fn(inner_value__) {
      #("force", json.float(inner_value__))
    })
    |> utils.add_optional(value__.tilt_x, fn(inner_value__) {
      #("tiltX", json.float(inner_value__))
    })
    |> utils.add_optional(value__.tilt_y, fn(inner_value__) {
      #("tiltY", json.float(inner_value__))
    })
    |> utils.add_optional(value__.id, fn(inner_value__) {
      #("id", json.float(inner_value__))
    }),
  )
}

@internal
pub fn decode__touch_point(value__: dynamic.Dynamic) {
  use x <- result.try(dynamic.field("x", dynamic.float)(value__))
  use y <- result.try(dynamic.field("y", dynamic.float)(value__))
  use radius_x <- result.try(dynamic.optional_field("radiusX", dynamic.float)(
    value__,
  ))
  use radius_y <- result.try(dynamic.optional_field("radiusY", dynamic.float)(
    value__,
  ))
  use rotation_angle <- result.try(dynamic.optional_field(
    "rotationAngle",
    dynamic.float,
  )(value__))
  use force <- result.try(dynamic.optional_field("force", dynamic.float)(
    value__,
  ))
  use tilt_x <- result.try(dynamic.optional_field("tiltX", dynamic.float)(
    value__,
  ))
  use tilt_y <- result.try(dynamic.optional_field("tiltY", dynamic.float)(
    value__,
  ))
  use id <- result.try(dynamic.optional_field("id", dynamic.float)(value__))

  Ok(TouchPoint(
    x: x,
    y: y,
    radius_x: radius_x,
    radius_y: radius_y,
    rotation_angle: rotation_angle,
    force: force,
    tilt_x: tilt_x,
    tilt_y: tilt_y,
    id: id,
  ))
}

pub type MouseButton {
  MouseButtonNone
  MouseButtonLeft
  MouseButtonMiddle
  MouseButtonRight
  MouseButtonBack
  MouseButtonForward
}

@internal
pub fn encode__mouse_button(value__: MouseButton) {
  case value__ {
    MouseButtonNone -> "none"
    MouseButtonLeft -> "left"
    MouseButtonMiddle -> "middle"
    MouseButtonRight -> "right"
    MouseButtonBack -> "back"
    MouseButtonForward -> "forward"
  }
  |> json.string()
}

@internal
pub fn decode__mouse_button(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("none") -> Ok(MouseButtonNone)
    Ok("left") -> Ok(MouseButtonLeft)
    Ok("middle") -> Ok(MouseButtonMiddle)
    Ok("right") -> Ok(MouseButtonRight)
    Ok("back") -> Ok(MouseButtonBack)
    Ok("forward") -> Ok(MouseButtonForward)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// UTC time in seconds, counted from January 1, 1970.
pub type TimeSinceEpoch {
  TimeSinceEpoch(Float)
}

@internal
pub fn encode__time_since_epoch(value__: TimeSinceEpoch) {
  case value__ {
    TimeSinceEpoch(inner_value__) -> json.float(inner_value__)
  }
}

@internal
pub fn decode__time_since_epoch(value__: dynamic.Dynamic) {
  value__ |> dynamic.decode1(TimeSinceEpoch, dynamic.float)
}

/// Dispatches a key event to the page.
/// 
/// Parameters:  
///  - `type_` : Type of the key event.
///  - `modifiers` : Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
///  - `timestamp` : Time at which the event occurred.
///  - `text` : Text as generated by processing a virtual key code with a keyboard layout. Not needed for
/// for `keyUp` and `rawKeyDown` events (default: "")
///  - `unmodified_text` : Text that would have been generated by the keyboard if no modifiers were pressed (except for
/// shift). Useful for shortcut (accelerator) key handling (default: "").
///  - `key_identifier` : Unique key identifier (e.g., 'U+0041') (default: "").
///  - `code` : Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
///  - `key` : Unique DOM defined string value describing the meaning of the key in the context of active
/// modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
///  - `windows_virtual_key_code` : Windows virtual key code (default: 0).
///  - `native_virtual_key_code` : Native virtual key code (default: 0).
///  - `auto_repeat` : Whether the event was generated from auto repeat (default: false).
///  - `is_keypad` : Whether the event was generated from the keypad (default: false).
///  - `is_system_key` : Whether the event was a system key event (default: false).
///  - `location` : Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
/// 0).
/// 
/// Returns:  
/// 
pub fn dispatch_key_event(
  callback__,
  type_ type_: DispatchKeyEventType,
  modifiers modifiers: option.Option(Int),
  timestamp timestamp: option.Option(TimeSinceEpoch),
  text text: option.Option(String),
  unmodified_text unmodified_text: option.Option(String),
  key_identifier key_identifier: option.Option(String),
  code code: option.Option(String),
  key key: option.Option(String),
  windows_virtual_key_code windows_virtual_key_code: option.Option(Int),
  native_virtual_key_code native_virtual_key_code: option.Option(Int),
  auto_repeat auto_repeat: option.Option(Bool),
  is_keypad is_keypad: option.Option(Bool),
  is_system_key is_system_key: option.Option(Bool),
  location location: option.Option(Int),
) {
  callback__(
    "Input.dispatchKeyEvent",
    option.Some(json.object(
      [#("type", encode__dispatch_key_event_type(type_))]
      |> utils.add_optional(modifiers, fn(inner_value__) {
        #("modifiers", json.int(inner_value__))
      })
      |> utils.add_optional(timestamp, fn(inner_value__) {
        #("timestamp", encode__time_since_epoch(inner_value__))
      })
      |> utils.add_optional(text, fn(inner_value__) {
        #("text", json.string(inner_value__))
      })
      |> utils.add_optional(unmodified_text, fn(inner_value__) {
        #("unmodifiedText", json.string(inner_value__))
      })
      |> utils.add_optional(key_identifier, fn(inner_value__) {
        #("keyIdentifier", json.string(inner_value__))
      })
      |> utils.add_optional(code, fn(inner_value__) {
        #("code", json.string(inner_value__))
      })
      |> utils.add_optional(key, fn(inner_value__) {
        #("key", json.string(inner_value__))
      })
      |> utils.add_optional(windows_virtual_key_code, fn(inner_value__) {
        #("windowsVirtualKeyCode", json.int(inner_value__))
      })
      |> utils.add_optional(native_virtual_key_code, fn(inner_value__) {
        #("nativeVirtualKeyCode", json.int(inner_value__))
      })
      |> utils.add_optional(auto_repeat, fn(inner_value__) {
        #("autoRepeat", json.bool(inner_value__))
      })
      |> utils.add_optional(is_keypad, fn(inner_value__) {
        #("isKeypad", json.bool(inner_value__))
      })
      |> utils.add_optional(is_system_key, fn(inner_value__) {
        #("isSystemKey", json.bool(inner_value__))
      })
      |> utils.add_optional(location, fn(inner_value__) {
        #("location", json.int(inner_value__))
      }),
    )),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `dispatchKeyEvent`
pub type DispatchKeyEventType {
  DispatchKeyEventTypeKeyDown
  DispatchKeyEventTypeKeyUp
  DispatchKeyEventTypeRawKeyDown
  DispatchKeyEventTypeChar
}

@internal
pub fn encode__dispatch_key_event_type(value__: DispatchKeyEventType) {
  case value__ {
    DispatchKeyEventTypeKeyDown -> "keyDown"
    DispatchKeyEventTypeKeyUp -> "keyUp"
    DispatchKeyEventTypeRawKeyDown -> "rawKeyDown"
    DispatchKeyEventTypeChar -> "char"
  }
  |> json.string()
}

@internal
pub fn decode__dispatch_key_event_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("keyDown") -> Ok(DispatchKeyEventTypeKeyDown)
    Ok("keyUp") -> Ok(DispatchKeyEventTypeKeyUp)
    Ok("rawKeyDown") -> Ok(DispatchKeyEventTypeRawKeyDown)
    Ok("char") -> Ok(DispatchKeyEventTypeChar)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Dispatches a mouse event to the page.
/// 
/// Parameters:  
///  - `type_` : Type of the mouse event.
///  - `x` : X coordinate of the event relative to the main frame's viewport in CSS pixels.
///  - `y` : Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
/// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
///  - `modifiers` : Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
///  - `timestamp` : Time at which the event occurred.
///  - `button` : Mouse button (default: "none").
///  - `buttons` : A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
/// Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
///  - `click_count` : Number of times the mouse button was clicked (default: 0).
///  - `tilt_x` : The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
///  - `tilt_y` : The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
///  - `delta_x` : X delta in CSS pixels for mouse wheel event (default: 0).
///  - `delta_y` : Y delta in CSS pixels for mouse wheel event (default: 0).
///  - `pointer_type` : Pointer type (default: "mouse").
/// 
/// Returns:  
/// 
pub fn dispatch_mouse_event(
  callback__,
  type_ type_: DispatchMouseEventType,
  x x: Float,
  y y: Float,
  modifiers modifiers: option.Option(Int),
  timestamp timestamp: option.Option(TimeSinceEpoch),
  button button: option.Option(MouseButton),
  buttons buttons: option.Option(Int),
  click_count click_count: option.Option(Int),
  tilt_x tilt_x: option.Option(Float),
  tilt_y tilt_y: option.Option(Float),
  delta_x delta_x: option.Option(Float),
  delta_y delta_y: option.Option(Float),
  pointer_type pointer_type: option.Option(DispatchMouseEventPointerType),
) {
  callback__(
    "Input.dispatchMouseEvent",
    option.Some(json.object(
      [
        #("type", encode__dispatch_mouse_event_type(type_)),
        #("x", json.float(x)),
        #("y", json.float(y)),
      ]
      |> utils.add_optional(modifiers, fn(inner_value__) {
        #("modifiers", json.int(inner_value__))
      })
      |> utils.add_optional(timestamp, fn(inner_value__) {
        #("timestamp", encode__time_since_epoch(inner_value__))
      })
      |> utils.add_optional(button, fn(inner_value__) {
        #("button", encode__mouse_button(inner_value__))
      })
      |> utils.add_optional(buttons, fn(inner_value__) {
        #("buttons", json.int(inner_value__))
      })
      |> utils.add_optional(click_count, fn(inner_value__) {
        #("clickCount", json.int(inner_value__))
      })
      |> utils.add_optional(tilt_x, fn(inner_value__) {
        #("tiltX", json.float(inner_value__))
      })
      |> utils.add_optional(tilt_y, fn(inner_value__) {
        #("tiltY", json.float(inner_value__))
      })
      |> utils.add_optional(delta_x, fn(inner_value__) {
        #("deltaX", json.float(inner_value__))
      })
      |> utils.add_optional(delta_y, fn(inner_value__) {
        #("deltaY", json.float(inner_value__))
      })
      |> utils.add_optional(pointer_type, fn(inner_value__) {
        #(
          "pointerType",
          encode__dispatch_mouse_event_pointer_type(inner_value__),
        )
      }),
    )),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `dispatchMouseEvent`
pub type DispatchMouseEventType {
  DispatchMouseEventTypeMousePressed
  DispatchMouseEventTypeMouseReleased
  DispatchMouseEventTypeMouseMoved
  DispatchMouseEventTypeMouseWheel
}

@internal
pub fn encode__dispatch_mouse_event_type(value__: DispatchMouseEventType) {
  case value__ {
    DispatchMouseEventTypeMousePressed -> "mousePressed"
    DispatchMouseEventTypeMouseReleased -> "mouseReleased"
    DispatchMouseEventTypeMouseMoved -> "mouseMoved"
    DispatchMouseEventTypeMouseWheel -> "mouseWheel"
  }
  |> json.string()
}

@internal
pub fn decode__dispatch_mouse_event_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("mousePressed") -> Ok(DispatchMouseEventTypeMousePressed)
    Ok("mouseReleased") -> Ok(DispatchMouseEventTypeMouseReleased)
    Ok("mouseMoved") -> Ok(DispatchMouseEventTypeMouseMoved)
    Ok("mouseWheel") -> Ok(DispatchMouseEventTypeMouseWheel)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `pointerType` of `dispatchMouseEvent`
pub type DispatchMouseEventPointerType {
  DispatchMouseEventPointerTypeMouse
  DispatchMouseEventPointerTypePen
}

@internal
pub fn encode__dispatch_mouse_event_pointer_type(
  value__: DispatchMouseEventPointerType,
) {
  case value__ {
    DispatchMouseEventPointerTypeMouse -> "mouse"
    DispatchMouseEventPointerTypePen -> "pen"
  }
  |> json.string()
}

@internal
pub fn decode__dispatch_mouse_event_pointer_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("mouse") -> Ok(DispatchMouseEventPointerTypeMouse)
    Ok("pen") -> Ok(DispatchMouseEventPointerTypePen)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Dispatches a touch event to the page.
/// 
/// Parameters:  
///  - `type_` : Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
/// TouchStart and TouchMove must contains at least one.
///  - `touch_points` : Active touch points on the touch device. One event per any changed point (compared to
/// previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
/// one by one.
///  - `modifiers` : Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
///  - `timestamp` : Time at which the event occurred.
/// 
/// Returns:  
/// 
pub fn dispatch_touch_event(
  callback__,
  type_ type_: DispatchTouchEventType,
  touch_points touch_points: List(TouchPoint),
  modifiers modifiers: option.Option(Int),
  timestamp timestamp: option.Option(TimeSinceEpoch),
) {
  callback__(
    "Input.dispatchTouchEvent",
    option.Some(json.object(
      [
        #("type", encode__dispatch_touch_event_type(type_)),
        #("touchPoints", json.array(touch_points, of: encode__touch_point)),
      ]
      |> utils.add_optional(modifiers, fn(inner_value__) {
        #("modifiers", json.int(inner_value__))
      })
      |> utils.add_optional(timestamp, fn(inner_value__) {
        #("timestamp", encode__time_since_epoch(inner_value__))
      }),
    )),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `dispatchTouchEvent`
pub type DispatchTouchEventType {
  DispatchTouchEventTypeTouchStart
  DispatchTouchEventTypeTouchEnd
  DispatchTouchEventTypeTouchMove
  DispatchTouchEventTypeTouchCancel
}

@internal
pub fn encode__dispatch_touch_event_type(value__: DispatchTouchEventType) {
  case value__ {
    DispatchTouchEventTypeTouchStart -> "touchStart"
    DispatchTouchEventTypeTouchEnd -> "touchEnd"
    DispatchTouchEventTypeTouchMove -> "touchMove"
    DispatchTouchEventTypeTouchCancel -> "touchCancel"
  }
  |> json.string()
}

@internal
pub fn decode__dispatch_touch_event_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("touchStart") -> Ok(DispatchTouchEventTypeTouchStart)
    Ok("touchEnd") -> Ok(DispatchTouchEventTypeTouchEnd)
    Ok("touchMove") -> Ok(DispatchTouchEventTypeTouchMove)
    Ok("touchCancel") -> Ok(DispatchTouchEventTypeTouchCancel)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Cancels any active dragging in the page.
/// 
pub fn cancel_dragging(callback__) {
  callback__("Input.cancelDragging", option.None)
}

/// Ignores input events (useful while auditing page).
/// 
/// Parameters:  
///  - `ignore` : Ignores input events processing when set to true.
/// 
/// Returns:  
/// 
pub fn set_ignore_input_events(callback__, ignore ignore: Bool) {
  callback__(
    "Input.setIgnoreInputEvents",
    option.Some(json.object([#("ignore", json.bool(ignore))])),
  )
}
