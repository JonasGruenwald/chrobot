//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## DOM Domain  
////
//// This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
//// that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
//// the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
//// nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
//// and never sends the same node twice. It is client's responsibility to collect information about
//// the nodes that were sent to the client. Note that `iframe` owner elements will return
//// corresponding document elements as their child nodes.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/DOM/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// | Run ` gleam run -m scripts/generate_protocol_bindings.sh` to regenerate.|  
// ---------------------------------------------------------------------------

import chrobot/chrome
import chrobot/internal/utils
import chrobot/protocol/runtime
import gleam/dynamic
import gleam/json
import gleam/option
import gleam/result

/// Unique DOM node identifier.
pub type NodeId {
  NodeId(Int)
}

@internal
pub fn encode__node_id(value__: NodeId) {
  case value__ {
    NodeId(inner_value__) -> json.int(inner_value__)
  }
}

@internal
pub fn decode__node_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(NodeId, dynamic.int)
}

/// Unique DOM node identifier used to reference a node that may not have been pushed to the
/// front-end.
pub type BackendNodeId {
  BackendNodeId(Int)
}

@internal
pub fn encode__backend_node_id(value__: BackendNodeId) {
  case value__ {
    BackendNodeId(inner_value__) -> json.int(inner_value__)
  }
}

@internal
pub fn decode__backend_node_id(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(BackendNodeId, dynamic.int)
}

/// Backend node with a friendly name.
pub type BackendNode {
  BackendNode(
    /// `Node`'s nodeType.  
    node_type: Int,
    /// `Node`'s nodeName.  
    node_name: String,
    backend_node_id: BackendNodeId,
  )
}

@internal
pub fn encode__backend_node(value__: BackendNode) {
  json.object([
    #("nodeType", json.int(value__.node_type)),
    #("nodeName", json.string(value__.node_name)),
    #("backendNodeId", encode__backend_node_id(value__.backend_node_id)),
  ])
}

@internal
pub fn decode__backend_node(value__: dynamic.Dynamic) {
  use node_type <- result.try(dynamic.field("nodeType", dynamic.int)(value__))
  use node_name <- result.try(dynamic.field("nodeName", dynamic.string)(value__))
  use backend_node_id <- result.try(dynamic.field(
    "backendNodeId",
    decode__backend_node_id,
  )(value__))

  Ok(BackendNode(
    node_type: node_type,
    node_name: node_name,
    backend_node_id: backend_node_id,
  ))
}

/// Pseudo element type.
pub type PseudoType {
  PseudoTypeFirstLine
  PseudoTypeFirstLetter
  PseudoTypeBefore
  PseudoTypeAfter
  PseudoTypeMarker
  PseudoTypeBackdrop
  PseudoTypeSelection
  PseudoTypeTargetText
  PseudoTypeSpellingError
  PseudoTypeGrammarError
  PseudoTypeHighlight
  PseudoTypeFirstLineInherited
  PseudoTypeScrollMarker
  PseudoTypeScrollMarkers
  PseudoTypeScrollbar
  PseudoTypeScrollbarThumb
  PseudoTypeScrollbarButton
  PseudoTypeScrollbarTrack
  PseudoTypeScrollbarTrackPiece
  PseudoTypeScrollbarCorner
  PseudoTypeResizer
  PseudoTypeInputListButton
  PseudoTypeViewTransition
  PseudoTypeViewTransitionGroup
  PseudoTypeViewTransitionImagePair
  PseudoTypeViewTransitionOld
  PseudoTypeViewTransitionNew
}

@internal
pub fn encode__pseudo_type(value__: PseudoType) {
  case value__ {
    PseudoTypeFirstLine -> "first-line"
    PseudoTypeFirstLetter -> "first-letter"
    PseudoTypeBefore -> "before"
    PseudoTypeAfter -> "after"
    PseudoTypeMarker -> "marker"
    PseudoTypeBackdrop -> "backdrop"
    PseudoTypeSelection -> "selection"
    PseudoTypeTargetText -> "target-text"
    PseudoTypeSpellingError -> "spelling-error"
    PseudoTypeGrammarError -> "grammar-error"
    PseudoTypeHighlight -> "highlight"
    PseudoTypeFirstLineInherited -> "first-line-inherited"
    PseudoTypeScrollMarker -> "scroll-marker"
    PseudoTypeScrollMarkers -> "scroll-markers"
    PseudoTypeScrollbar -> "scrollbar"
    PseudoTypeScrollbarThumb -> "scrollbar-thumb"
    PseudoTypeScrollbarButton -> "scrollbar-button"
    PseudoTypeScrollbarTrack -> "scrollbar-track"
    PseudoTypeScrollbarTrackPiece -> "scrollbar-track-piece"
    PseudoTypeScrollbarCorner -> "scrollbar-corner"
    PseudoTypeResizer -> "resizer"
    PseudoTypeInputListButton -> "input-list-button"
    PseudoTypeViewTransition -> "view-transition"
    PseudoTypeViewTransitionGroup -> "view-transition-group"
    PseudoTypeViewTransitionImagePair -> "view-transition-image-pair"
    PseudoTypeViewTransitionOld -> "view-transition-old"
    PseudoTypeViewTransitionNew -> "view-transition-new"
  }
  |> json.string()
}

@internal
pub fn decode__pseudo_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("first-line") -> Ok(PseudoTypeFirstLine)
    Ok("first-letter") -> Ok(PseudoTypeFirstLetter)
    Ok("before") -> Ok(PseudoTypeBefore)
    Ok("after") -> Ok(PseudoTypeAfter)
    Ok("marker") -> Ok(PseudoTypeMarker)
    Ok("backdrop") -> Ok(PseudoTypeBackdrop)
    Ok("selection") -> Ok(PseudoTypeSelection)
    Ok("target-text") -> Ok(PseudoTypeTargetText)
    Ok("spelling-error") -> Ok(PseudoTypeSpellingError)
    Ok("grammar-error") -> Ok(PseudoTypeGrammarError)
    Ok("highlight") -> Ok(PseudoTypeHighlight)
    Ok("first-line-inherited") -> Ok(PseudoTypeFirstLineInherited)
    Ok("scroll-marker") -> Ok(PseudoTypeScrollMarker)
    Ok("scroll-markers") -> Ok(PseudoTypeScrollMarkers)
    Ok("scrollbar") -> Ok(PseudoTypeScrollbar)
    Ok("scrollbar-thumb") -> Ok(PseudoTypeScrollbarThumb)
    Ok("scrollbar-button") -> Ok(PseudoTypeScrollbarButton)
    Ok("scrollbar-track") -> Ok(PseudoTypeScrollbarTrack)
    Ok("scrollbar-track-piece") -> Ok(PseudoTypeScrollbarTrackPiece)
    Ok("scrollbar-corner") -> Ok(PseudoTypeScrollbarCorner)
    Ok("resizer") -> Ok(PseudoTypeResizer)
    Ok("input-list-button") -> Ok(PseudoTypeInputListButton)
    Ok("view-transition") -> Ok(PseudoTypeViewTransition)
    Ok("view-transition-group") -> Ok(PseudoTypeViewTransitionGroup)
    Ok("view-transition-image-pair") -> Ok(PseudoTypeViewTransitionImagePair)
    Ok("view-transition-old") -> Ok(PseudoTypeViewTransitionOld)
    Ok("view-transition-new") -> Ok(PseudoTypeViewTransitionNew)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Shadow root type.
pub type ShadowRootType {
  ShadowRootTypeUserAgent
  ShadowRootTypeOpen
  ShadowRootTypeClosed
}

@internal
pub fn encode__shadow_root_type(value__: ShadowRootType) {
  case value__ {
    ShadowRootTypeUserAgent -> "user-agent"
    ShadowRootTypeOpen -> "open"
    ShadowRootTypeClosed -> "closed"
  }
  |> json.string()
}

@internal
pub fn decode__shadow_root_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("user-agent") -> Ok(ShadowRootTypeUserAgent)
    Ok("open") -> Ok(ShadowRootTypeOpen)
    Ok("closed") -> Ok(ShadowRootTypeClosed)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Document compatibility mode.
pub type CompatibilityMode {
  CompatibilityModeQuirksMode
  CompatibilityModeLimitedQuirksMode
  CompatibilityModeNoQuirksMode
}

@internal
pub fn encode__compatibility_mode(value__: CompatibilityMode) {
  case value__ {
    CompatibilityModeQuirksMode -> "QuirksMode"
    CompatibilityModeLimitedQuirksMode -> "LimitedQuirksMode"
    CompatibilityModeNoQuirksMode -> "NoQuirksMode"
  }
  |> json.string()
}

@internal
pub fn decode__compatibility_mode(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("QuirksMode") -> Ok(CompatibilityModeQuirksMode)
    Ok("LimitedQuirksMode") -> Ok(CompatibilityModeLimitedQuirksMode)
    Ok("NoQuirksMode") -> Ok(CompatibilityModeNoQuirksMode)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// ContainerSelector physical axes
pub type PhysicalAxes {
  PhysicalAxesHorizontal
  PhysicalAxesVertical
  PhysicalAxesBoth
}

@internal
pub fn encode__physical_axes(value__: PhysicalAxes) {
  case value__ {
    PhysicalAxesHorizontal -> "Horizontal"
    PhysicalAxesVertical -> "Vertical"
    PhysicalAxesBoth -> "Both"
  }
  |> json.string()
}

@internal
pub fn decode__physical_axes(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("Horizontal") -> Ok(PhysicalAxesHorizontal)
    Ok("Vertical") -> Ok(PhysicalAxesVertical)
    Ok("Both") -> Ok(PhysicalAxesBoth)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// ContainerSelector logical axes
pub type LogicalAxes {
  LogicalAxesInline
  LogicalAxesBlock
  LogicalAxesBoth
}

@internal
pub fn encode__logical_axes(value__: LogicalAxes) {
  case value__ {
    LogicalAxesInline -> "Inline"
    LogicalAxesBlock -> "Block"
    LogicalAxesBoth -> "Both"
  }
  |> json.string()
}

@internal
pub fn decode__logical_axes(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("Inline") -> Ok(LogicalAxesInline)
    Ok("Block") -> Ok(LogicalAxesBlock)
    Ok("Both") -> Ok(LogicalAxesBoth)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Physical scroll orientation
pub type ScrollOrientation {
  ScrollOrientationHorizontal
  ScrollOrientationVertical
}

@internal
pub fn encode__scroll_orientation(value__: ScrollOrientation) {
  case value__ {
    ScrollOrientationHorizontal -> "horizontal"
    ScrollOrientationVertical -> "vertical"
  }
  |> json.string()
}

@internal
pub fn decode__scroll_orientation(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("horizontal") -> Ok(ScrollOrientationHorizontal)
    Ok("vertical") -> Ok(ScrollOrientationVertical)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
/// DOMNode is a base node mirror type.
pub type Node {
  Node(
    /// Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
    /// will only push node with given `id` once. It is aware of all requested nodes and will only
    /// fire DOM events for nodes known to the client.  
    node_id: NodeId,
    /// The id of the parent node if any.  
    parent_id: option.Option(NodeId),
    /// The BackendNodeId for this node.  
    backend_node_id: BackendNodeId,
    /// `Node`'s nodeType.  
    node_type: Int,
    /// `Node`'s nodeName.  
    node_name: String,
    /// `Node`'s localName.  
    local_name: String,
    /// `Node`'s nodeValue.  
    node_value: String,
    /// Child count for `Container` nodes.  
    child_node_count: option.Option(Int),
    /// Child nodes of this node when requested with children.  
    children: option.Option(List(Node)),
    /// Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.  
    attributes: option.Option(List(String)),
    /// Document URL that `Document` or `FrameOwner` node points to.  
    document_url: option.Option(String),
    /// Base URL that `Document` or `FrameOwner` node uses for URL completion.  
    base_url: option.Option(String),
    /// `DocumentType`'s publicId.  
    public_id: option.Option(String),
    /// `DocumentType`'s systemId.  
    system_id: option.Option(String),
    /// `DocumentType`'s internalSubset.  
    internal_subset: option.Option(String),
    /// `Document`'s XML version in case of XML documents.  
    xml_version: option.Option(String),
    /// `Attr`'s name.  
    name: option.Option(String),
    /// `Attr`'s value.  
    value: option.Option(String),
    /// Pseudo element type for this node.  
    pseudo_type: option.Option(PseudoType),
    /// Pseudo element identifier for this node. Only present if there is a
    /// valid pseudoType.  
    pseudo_identifier: option.Option(String),
    /// Shadow root type.  
    shadow_root_type: option.Option(ShadowRootType),
    /// Frame ID for frame owner elements.  
    frame_id: option.Option(String),
    /// Content document for frame owner elements.  
    content_document: option.Option(Node),
    /// Shadow root list for given element host.  
    shadow_roots: option.Option(List(Node)),
    /// Content document fragment for template elements.  
    template_content: option.Option(Node),
    /// Pseudo elements associated with this node.  
    pseudo_elements: option.Option(List(Node)),
    /// Distributed nodes for given insertion point.  
    distributed_nodes: option.Option(List(BackendNode)),
    /// Whether the node is SVG.  
    is_svg: option.Option(Bool),
    compatibility_mode: option.Option(CompatibilityMode),
    assigned_slot: option.Option(BackendNode),
  )
}

@internal
pub fn encode__node(value__: Node) {
  json.object(
    [
      #("nodeId", encode__node_id(value__.node_id)),
      #("backendNodeId", encode__backend_node_id(value__.backend_node_id)),
      #("nodeType", json.int(value__.node_type)),
      #("nodeName", json.string(value__.node_name)),
      #("localName", json.string(value__.local_name)),
      #("nodeValue", json.string(value__.node_value)),
    ]
    |> utils.add_optional(value__.parent_id, fn(inner_value__) {
      #("parentId", encode__node_id(inner_value__))
    })
    |> utils.add_optional(value__.child_node_count, fn(inner_value__) {
      #("childNodeCount", json.int(inner_value__))
    })
    |> utils.add_optional(value__.children, fn(inner_value__) {
      #("children", json.array(inner_value__, of: encode__node))
    })
    |> utils.add_optional(value__.attributes, fn(inner_value__) {
      #("attributes", json.array(inner_value__, of: json.string))
    })
    |> utils.add_optional(value__.document_url, fn(inner_value__) {
      #("documentURL", json.string(inner_value__))
    })
    |> utils.add_optional(value__.base_url, fn(inner_value__) {
      #("baseURL", json.string(inner_value__))
    })
    |> utils.add_optional(value__.public_id, fn(inner_value__) {
      #("publicId", json.string(inner_value__))
    })
    |> utils.add_optional(value__.system_id, fn(inner_value__) {
      #("systemId", json.string(inner_value__))
    })
    |> utils.add_optional(value__.internal_subset, fn(inner_value__) {
      #("internalSubset", json.string(inner_value__))
    })
    |> utils.add_optional(value__.xml_version, fn(inner_value__) {
      #("xmlVersion", json.string(inner_value__))
    })
    |> utils.add_optional(value__.name, fn(inner_value__) {
      #("name", json.string(inner_value__))
    })
    |> utils.add_optional(value__.value, fn(inner_value__) {
      #("value", json.string(inner_value__))
    })
    |> utils.add_optional(value__.pseudo_type, fn(inner_value__) {
      #("pseudoType", encode__pseudo_type(inner_value__))
    })
    |> utils.add_optional(value__.pseudo_identifier, fn(inner_value__) {
      #("pseudoIdentifier", json.string(inner_value__))
    })
    |> utils.add_optional(value__.shadow_root_type, fn(inner_value__) {
      #("shadowRootType", encode__shadow_root_type(inner_value__))
    })
    |> utils.add_optional(value__.frame_id, fn(inner_value__) {
      #("frameId", json.string(inner_value__))
    })
    |> utils.add_optional(value__.content_document, fn(inner_value__) {
      #("contentDocument", encode__node(inner_value__))
    })
    |> utils.add_optional(value__.shadow_roots, fn(inner_value__) {
      #("shadowRoots", json.array(inner_value__, of: encode__node))
    })
    |> utils.add_optional(value__.template_content, fn(inner_value__) {
      #("templateContent", encode__node(inner_value__))
    })
    |> utils.add_optional(value__.pseudo_elements, fn(inner_value__) {
      #("pseudoElements", json.array(inner_value__, of: encode__node))
    })
    |> utils.add_optional(value__.distributed_nodes, fn(inner_value__) {
      #("distributedNodes", json.array(inner_value__, of: encode__backend_node))
    })
    |> utils.add_optional(value__.is_svg, fn(inner_value__) {
      #("isSVG", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.compatibility_mode, fn(inner_value__) {
      #("compatibilityMode", encode__compatibility_mode(inner_value__))
    })
    |> utils.add_optional(value__.assigned_slot, fn(inner_value__) {
      #("assignedSlot", encode__backend_node(inner_value__))
    }),
  )
}

@internal
pub fn decode__node(value__: dynamic.Dynamic) {
  use node_id <- result.try(dynamic.field("nodeId", decode__node_id)(value__))
  use parent_id <- result.try(dynamic.optional_field(
    "parentId",
    decode__node_id,
  )(value__))
  use backend_node_id <- result.try(dynamic.field(
    "backendNodeId",
    decode__backend_node_id,
  )(value__))
  use node_type <- result.try(dynamic.field("nodeType", dynamic.int)(value__))
  use node_name <- result.try(dynamic.field("nodeName", dynamic.string)(value__))
  use local_name <- result.try(dynamic.field("localName", dynamic.string)(
    value__,
  ))
  use node_value <- result.try(dynamic.field("nodeValue", dynamic.string)(
    value__,
  ))
  use child_node_count <- result.try(dynamic.optional_field(
    "childNodeCount",
    dynamic.int,
  )(value__))
  use children <- result.try(dynamic.optional_field(
    "children",
    dynamic.list(decode__node),
  )(value__))
  use attributes <- result.try(dynamic.optional_field(
    "attributes",
    dynamic.list(dynamic.string),
  )(value__))
  use document_url <- result.try(dynamic.optional_field(
    "documentURL",
    dynamic.string,
  )(value__))
  use base_url <- result.try(dynamic.optional_field("baseURL", dynamic.string)(
    value__,
  ))
  use public_id <- result.try(dynamic.optional_field("publicId", dynamic.string)(
    value__,
  ))
  use system_id <- result.try(dynamic.optional_field("systemId", dynamic.string)(
    value__,
  ))
  use internal_subset <- result.try(dynamic.optional_field(
    "internalSubset",
    dynamic.string,
  )(value__))
  use xml_version <- result.try(dynamic.optional_field(
    "xmlVersion",
    dynamic.string,
  )(value__))
  use name <- result.try(dynamic.optional_field("name", dynamic.string)(value__))
  use value <- result.try(dynamic.optional_field("value", dynamic.string)(
    value__,
  ))
  use pseudo_type <- result.try(dynamic.optional_field(
    "pseudoType",
    decode__pseudo_type,
  )(value__))
  use pseudo_identifier <- result.try(dynamic.optional_field(
    "pseudoIdentifier",
    dynamic.string,
  )(value__))
  use shadow_root_type <- result.try(dynamic.optional_field(
    "shadowRootType",
    decode__shadow_root_type,
  )(value__))
  use frame_id <- result.try(dynamic.optional_field("frameId", dynamic.string)(
    value__,
  ))
  use content_document <- result.try(dynamic.optional_field(
    "contentDocument",
    decode__node,
  )(value__))
  use shadow_roots <- result.try(dynamic.optional_field(
    "shadowRoots",
    dynamic.list(decode__node),
  )(value__))
  use template_content <- result.try(dynamic.optional_field(
    "templateContent",
    decode__node,
  )(value__))
  use pseudo_elements <- result.try(dynamic.optional_field(
    "pseudoElements",
    dynamic.list(decode__node),
  )(value__))
  use distributed_nodes <- result.try(dynamic.optional_field(
    "distributedNodes",
    dynamic.list(decode__backend_node),
  )(value__))
  use is_svg <- result.try(dynamic.optional_field("isSVG", dynamic.bool)(
    value__,
  ))
  use compatibility_mode <- result.try(dynamic.optional_field(
    "compatibilityMode",
    decode__compatibility_mode,
  )(value__))
  use assigned_slot <- result.try(dynamic.optional_field(
    "assignedSlot",
    decode__backend_node,
  )(value__))

  Ok(Node(
    node_id: node_id,
    parent_id: parent_id,
    backend_node_id: backend_node_id,
    node_type: node_type,
    node_name: node_name,
    local_name: local_name,
    node_value: node_value,
    child_node_count: child_node_count,
    children: children,
    attributes: attributes,
    document_url: document_url,
    base_url: base_url,
    public_id: public_id,
    system_id: system_id,
    internal_subset: internal_subset,
    xml_version: xml_version,
    name: name,
    value: value,
    pseudo_type: pseudo_type,
    pseudo_identifier: pseudo_identifier,
    shadow_root_type: shadow_root_type,
    frame_id: frame_id,
    content_document: content_document,
    shadow_roots: shadow_roots,
    template_content: template_content,
    pseudo_elements: pseudo_elements,
    distributed_nodes: distributed_nodes,
    is_svg: is_svg,
    compatibility_mode: compatibility_mode,
    assigned_slot: assigned_slot,
  ))
}

/// A structure holding an RGBA color.
pub type RGBA {
  RGBA(
    /// The red component, in the [0-255] range.  
    r: Int,
    /// The green component, in the [0-255] range.  
    g: Int,
    /// The blue component, in the [0-255] range.  
    b: Int,
    /// The alpha component, in the [0-1] range (default: 1).  
    a: option.Option(Float),
  )
}

@internal
pub fn encode__rgba(value__: RGBA) {
  json.object(
    [
      #("r", json.int(value__.r)),
      #("g", json.int(value__.g)),
      #("b", json.int(value__.b)),
    ]
    |> utils.add_optional(value__.a, fn(inner_value__) {
      #("a", json.float(inner_value__))
    }),
  )
}

@internal
pub fn decode__rgba(value__: dynamic.Dynamic) {
  use r <- result.try(dynamic.field("r", dynamic.int)(value__))
  use g <- result.try(dynamic.field("g", dynamic.int)(value__))
  use b <- result.try(dynamic.field("b", dynamic.int)(value__))
  use a <- result.try(dynamic.optional_field("a", dynamic.float)(value__))

  Ok(RGBA(r: r, g: g, b: b, a: a))
}

/// An array of quad vertices, x immediately followed by y for each point, points clock-wise.
pub type Quad {
  Quad(List(Float))
}

@internal
pub fn encode__quad(value__: Quad) {
  case value__ {
    Quad(inner_value__) -> json.array(inner_value__, of: json.float)
  }
}

@internal
pub fn decode__quad(value__: dynamic.Dynamic) {
  value__
  |> dynamic.decode1(Quad, dynamic.list(dynamic.float))
}

/// Box model.
pub type BoxModel {
  BoxModel(
    /// Content box  
    content: Quad,
    /// Padding box  
    padding: Quad,
    /// Border box  
    border: Quad,
    /// Margin box  
    margin: Quad,
    /// Node width  
    width: Int,
    /// Node height  
    height: Int,
    /// Shape outside coordinates  
    shape_outside: option.Option(ShapeOutsideInfo),
  )
}

@internal
pub fn encode__box_model(value__: BoxModel) {
  json.object(
    [
      #("content", encode__quad(value__.content)),
      #("padding", encode__quad(value__.padding)),
      #("border", encode__quad(value__.border)),
      #("margin", encode__quad(value__.margin)),
      #("width", json.int(value__.width)),
      #("height", json.int(value__.height)),
    ]
    |> utils.add_optional(value__.shape_outside, fn(inner_value__) {
      #("shapeOutside", encode__shape_outside_info(inner_value__))
    }),
  )
}

@internal
pub fn decode__box_model(value__: dynamic.Dynamic) {
  use content <- result.try(dynamic.field("content", decode__quad)(value__))
  use padding <- result.try(dynamic.field("padding", decode__quad)(value__))
  use border <- result.try(dynamic.field("border", decode__quad)(value__))
  use margin <- result.try(dynamic.field("margin", decode__quad)(value__))
  use width <- result.try(dynamic.field("width", dynamic.int)(value__))
  use height <- result.try(dynamic.field("height", dynamic.int)(value__))
  use shape_outside <- result.try(dynamic.optional_field(
    "shapeOutside",
    decode__shape_outside_info,
  )(value__))

  Ok(BoxModel(
    content: content,
    padding: padding,
    border: border,
    margin: margin,
    width: width,
    height: height,
    shape_outside: shape_outside,
  ))
}

/// CSS Shape Outside details.
pub type ShapeOutsideInfo {
  ShapeOutsideInfo(
    /// Shape bounds  
    bounds: Quad,
    /// Shape coordinate details  
    shape: List(dynamic.Dynamic),
    /// Margin shape bounds  
    margin_shape: List(dynamic.Dynamic),
  )
}

@internal
pub fn encode__shape_outside_info(value__: ShapeOutsideInfo) {
  json.object([
    #("bounds", encode__quad(value__.bounds)),
    #(
      "shape",
      // dynamic values cannot be encoded!
      json.null(),
    ),
    #(
      "marginShape",
      // dynamic values cannot be encoded!
      json.null(),
    ),
  ])
}

@internal
pub fn decode__shape_outside_info(value__: dynamic.Dynamic) {
  use bounds <- result.try(dynamic.field("bounds", decode__quad)(value__))
  use shape <- result.try(dynamic.field("shape", dynamic.list(dynamic.dynamic))(
    value__,
  ))
  use margin_shape <- result.try(dynamic.field(
    "marginShape",
    dynamic.list(dynamic.dynamic),
  )(value__))

  Ok(ShapeOutsideInfo(bounds: bounds, shape: shape, margin_shape: margin_shape))
}

/// Rectangle.
pub type Rect {
  Rect(
    /// X coordinate  
    x: Float,
    /// Y coordinate  
    y: Float,
    /// Rectangle width  
    width: Float,
    /// Rectangle height  
    height: Float,
  )
}

@internal
pub fn encode__rect(value__: Rect) {
  json.object([
    #("x", json.float(value__.x)),
    #("y", json.float(value__.y)),
    #("width", json.float(value__.width)),
    #("height", json.float(value__.height)),
  ])
}

@internal
pub fn decode__rect(value__: dynamic.Dynamic) {
  use x <- result.try(dynamic.field("x", dynamic.float)(value__))
  use y <- result.try(dynamic.field("y", dynamic.float)(value__))
  use width <- result.try(dynamic.field("width", dynamic.float)(value__))
  use height <- result.try(dynamic.field("height", dynamic.float)(value__))

  Ok(Rect(x: x, y: y, width: width, height: height))
}

pub type CSSComputedStyleProperty {
  CSSComputedStyleProperty(
    /// Computed style property name.  
    name: String,
    /// Computed style property value.  
    value: String,
  )
}

@internal
pub fn encode__css_computed_style_property(value__: CSSComputedStyleProperty) {
  json.object([
    #("name", json.string(value__.name)),
    #("value", json.string(value__.value)),
  ])
}

@internal
pub fn decode__css_computed_style_property(value__: dynamic.Dynamic) {
  use name <- result.try(dynamic.field("name", dynamic.string)(value__))
  use value <- result.try(dynamic.field("value", dynamic.string)(value__))

  Ok(CSSComputedStyleProperty(name: name, value: value))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `describe_node`
pub type DescribeNodeResponse {
  DescribeNodeResponse(
    /// Node description.  
    node: Node,
  )
}

@internal
pub fn decode__describe_node_response(value__: dynamic.Dynamic) {
  use node <- result.try(dynamic.field("node", decode__node)(value__))

  Ok(DescribeNodeResponse(node: node))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_attributes`
pub type GetAttributesResponse {
  GetAttributesResponse(
    /// An interleaved array of node attribute names and values.  
    attributes: List(String),
  )
}

@internal
pub fn decode__get_attributes_response(value__: dynamic.Dynamic) {
  use attributes <- result.try(dynamic.field(
    "attributes",
    dynamic.list(dynamic.string),
  )(value__))

  Ok(GetAttributesResponse(attributes: attributes))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_box_model`
pub type GetBoxModelResponse {
  GetBoxModelResponse(
    /// Box model for the node.  
    model: BoxModel,
  )
}

@internal
pub fn decode__get_box_model_response(value__: dynamic.Dynamic) {
  use model <- result.try(dynamic.field("model", decode__box_model)(value__))

  Ok(GetBoxModelResponse(model: model))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_document`
pub type GetDocumentResponse {
  GetDocumentResponse(
    /// Resulting node.  
    root: Node,
  )
}

@internal
pub fn decode__get_document_response(value__: dynamic.Dynamic) {
  use root <- result.try(dynamic.field("root", decode__node)(value__))

  Ok(GetDocumentResponse(root: root))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_node_for_location`
pub type GetNodeForLocationResponse {
  GetNodeForLocationResponse(
    /// Resulting node.  
    backend_node_id: BackendNodeId,
    /// Frame this node belongs to.  
    frame_id: String,
    /// Id of the node at given coordinates, only when enabled and requested document.  
    node_id: option.Option(NodeId),
  )
}

@internal
pub fn decode__get_node_for_location_response(value__: dynamic.Dynamic) {
  use backend_node_id <- result.try(dynamic.field(
    "backendNodeId",
    decode__backend_node_id,
  )(value__))
  use frame_id <- result.try(dynamic.field("frameId", dynamic.string)(value__))
  use node_id <- result.try(dynamic.optional_field("nodeId", decode__node_id)(
    value__,
  ))

  Ok(GetNodeForLocationResponse(
    backend_node_id: backend_node_id,
    frame_id: frame_id,
    node_id: node_id,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_outer_html`
pub type GetOuterHtmlResponse {
  GetOuterHtmlResponse(
    /// Outer HTML markup.  
    outer_html: String,
  )
}

@internal
pub fn decode__get_outer_html_response(value__: dynamic.Dynamic) {
  use outer_html <- result.try(dynamic.field("outerHTML", dynamic.string)(
    value__,
  ))

  Ok(GetOuterHtmlResponse(outer_html: outer_html))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `move_to`
pub type MoveToResponse {
  MoveToResponse(
    /// New id of the moved node.  
    node_id: NodeId,
  )
}

@internal
pub fn decode__move_to_response(value__: dynamic.Dynamic) {
  use node_id <- result.try(dynamic.field("nodeId", decode__node_id)(value__))

  Ok(MoveToResponse(node_id: node_id))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `query_selector`
pub type QuerySelectorResponse {
  QuerySelectorResponse(
    /// Query selector result.  
    node_id: NodeId,
  )
}

@internal
pub fn decode__query_selector_response(value__: dynamic.Dynamic) {
  use node_id <- result.try(dynamic.field("nodeId", decode__node_id)(value__))

  Ok(QuerySelectorResponse(node_id: node_id))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `query_selector_all`
pub type QuerySelectorAllResponse {
  QuerySelectorAllResponse(
    /// Query selector result.  
    node_ids: List(NodeId),
  )
}

@internal
pub fn decode__query_selector_all_response(value__: dynamic.Dynamic) {
  use node_ids <- result.try(dynamic.field(
    "nodeIds",
    dynamic.list(decode__node_id),
  )(value__))

  Ok(QuerySelectorAllResponse(node_ids: node_ids))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `request_node`
pub type RequestNodeResponse {
  RequestNodeResponse(
    /// Node id for given object.  
    node_id: NodeId,
  )
}

@internal
pub fn decode__request_node_response(value__: dynamic.Dynamic) {
  use node_id <- result.try(dynamic.field("nodeId", decode__node_id)(value__))

  Ok(RequestNodeResponse(node_id: node_id))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `resolve_node`
pub type ResolveNodeResponse {
  ResolveNodeResponse(
    /// JavaScript object wrapper for given node.  
    object: runtime.RemoteObject,
  )
}

@internal
pub fn decode__resolve_node_response(value__: dynamic.Dynamic) {
  use object <- result.try(dynamic.field(
    "object",
    runtime.decode__remote_object,
  )(value__))

  Ok(ResolveNodeResponse(object: object))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_node_name`
pub type SetNodeNameResponse {
  SetNodeNameResponse(
    /// New node's id.  
    node_id: NodeId,
  )
}

@internal
pub fn decode__set_node_name_response(value__: dynamic.Dynamic) {
  use node_id <- result.try(dynamic.field("nodeId", decode__node_id)(value__))

  Ok(SetNodeNameResponse(node_id: node_id))
}

/// Describes node given its id, does not require domain to be enabled. Does not start tracking any
/// objects, can be used for automation.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
///  - `depth` : The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
///  - `pierce` : Whether or not iframes and shadow roots should be traversed when returning the subtree
/// (default is false).
/// 
/// Returns:  
///  - `node` : Node description.
/// 
pub fn describe_node(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
  depth depth: option.Option(Int),
  pierce pierce: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "DOM.describeNode",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      })
      |> utils.add_optional(depth, fn(inner_value__) {
        #("depth", json.int(inner_value__))
      })
      |> utils.add_optional(pierce, fn(inner_value__) {
        #("pierce", json.bool(inner_value__))
      }),
    )),
  ))

  decode__describe_node_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Scrolls the specified rect of the given node into view if not already visible.
/// Note: exactly one between nodeId, backendNodeId and objectId should be passed
/// to identify the node.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
///  - `rect` : The rect to be scrolled into view, relative to the node's border box, in CSS pixels.
/// When omitted, center of the node will be used, similar to Element.scrollIntoView.
/// 
/// Returns:  
/// 
pub fn scroll_into_view_if_needed(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
  rect rect: option.Option(Rect),
) {
  callback__(
    "DOM.scrollIntoViewIfNeeded",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      })
      |> utils.add_optional(rect, fn(inner_value__) {
        #("rect", encode__rect(inner_value__))
      }),
    )),
  )
}

/// Disables DOM agent for the given page.
/// 
pub fn disable(callback__) {
  callback__("DOM.disable", option.None)
}

/// Enables DOM agent for the given page.
/// 
/// Parameters:  
/// 
/// Returns:  
/// 
pub fn enable(callback__) {
  callback__("DOM.enable", option.None)
}

/// Focuses the given element.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
/// 
/// Returns:  
/// 
pub fn focus(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
) {
  callback__(
    "DOM.focus",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      }),
    )),
  )
}

/// Returns attributes for the specified node.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to retrieve attributes for.
/// 
/// Returns:  
///  - `attributes` : An interleaved array of node attribute names and values.
/// 
pub fn get_attributes(callback__, node_id node_id: NodeId) {
  use result__ <- result.try(callback__(
    "DOM.getAttributes",
    option.Some(json.object([#("nodeId", encode__node_id(node_id))])),
  ))

  decode__get_attributes_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns boxes for the given node.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
/// 
/// Returns:  
///  - `model` : Box model for the node.
/// 
pub fn get_box_model(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
) {
  use result__ <- result.try(callback__(
    "DOM.getBoxModel",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      }),
    )),
  ))

  decode__get_box_model_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns the root DOM node (and optionally the subtree) to the caller.
/// Implicitly enables the DOM domain events for the current target.
/// 
/// Parameters:  
///  - `depth` : The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
///  - `pierce` : Whether or not iframes and shadow roots should be traversed when returning the subtree
/// (default is false).
/// 
/// Returns:  
///  - `root` : Resulting node.
/// 
pub fn get_document(
  callback__,
  depth depth: option.Option(Int),
  pierce pierce: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "DOM.getDocument",
    option.Some(json.object(
      []
      |> utils.add_optional(depth, fn(inner_value__) {
        #("depth", json.int(inner_value__))
      })
      |> utils.add_optional(pierce, fn(inner_value__) {
        #("pierce", json.bool(inner_value__))
      }),
    )),
  ))

  decode__get_document_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
/// either returned or not.
/// 
/// Parameters:  
///  - `x` : X coordinate.
///  - `y` : Y coordinate.
///  - `include_user_agent_shadow_dom` : False to skip to the nearest non-UA shadow root ancestor (default: false).
///  - `ignore_pointer_events_none` : Whether to ignore pointer-events: none on elements and hit test them.
/// 
/// Returns:  
///  - `backend_node_id` : Resulting node.
///  - `frame_id` : Frame this node belongs to.
///  - `node_id` : Id of the node at given coordinates, only when enabled and requested document.
/// 
pub fn get_node_for_location(
  callback__,
  x x: Int,
  y y: Int,
  include_user_agent_shadow_dom include_user_agent_shadow_dom: option.Option(
    Bool,
  ),
  ignore_pointer_events_none ignore_pointer_events_none: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "DOM.getNodeForLocation",
    option.Some(json.object(
      [#("x", json.int(x)), #("y", json.int(y))]
      |> utils.add_optional(include_user_agent_shadow_dom, fn(inner_value__) {
        #("includeUserAgentShadowDOM", json.bool(inner_value__))
      })
      |> utils.add_optional(ignore_pointer_events_none, fn(inner_value__) {
        #("ignorePointerEventsNone", json.bool(inner_value__))
      }),
    )),
  ))

  decode__get_node_for_location_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns node's HTML markup.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
/// 
/// Returns:  
///  - `outer_html` : Outer HTML markup.
/// 
pub fn get_outer_html(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
) {
  use result__ <- result.try(callback__(
    "DOM.getOuterHTML",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      }),
    )),
  ))

  decode__get_outer_html_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Hides any highlight.
/// 
pub fn hide_highlight(callback__) {
  callback__("DOM.hideHighlight", option.None)
}

/// Highlights DOM node.
/// 
pub fn highlight_node(callback__) {
  callback__("DOM.highlightNode", option.None)
}

/// Highlights given rectangle.
/// 
pub fn highlight_rect(callback__) {
  callback__("DOM.highlightRect", option.None)
}

/// Moves node into the new container, places it before the given anchor.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to move.
///  - `target_node_id` : Id of the element to drop the moved node into.
///  - `insert_before_node_id` : Drop node before this one (if absent, the moved node becomes the last child of
/// `targetNodeId`).
/// 
/// Returns:  
///  - `node_id` : New id of the moved node.
/// 
pub fn move_to(
  callback__,
  node_id node_id: NodeId,
  target_node_id target_node_id: NodeId,
  insert_before_node_id insert_before_node_id: option.Option(NodeId),
) {
  use result__ <- result.try(callback__(
    "DOM.moveTo",
    option.Some(json.object(
      [
        #("nodeId", encode__node_id(node_id)),
        #("targetNodeId", encode__node_id(target_node_id)),
      ]
      |> utils.add_optional(insert_before_node_id, fn(inner_value__) {
        #("insertBeforeNodeId", encode__node_id(inner_value__))
      }),
    )),
  ))

  decode__move_to_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Executes `querySelector` on a given node.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to query upon.
///  - `selector` : Selector string.
/// 
/// Returns:  
///  - `node_id` : Query selector result.
/// 
pub fn query_selector(
  callback__,
  node_id node_id: NodeId,
  selector selector: String,
) {
  use result__ <- result.try(callback__(
    "DOM.querySelector",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("selector", json.string(selector)),
      ]),
    ),
  ))

  decode__query_selector_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Executes `querySelectorAll` on a given node.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to query upon.
///  - `selector` : Selector string.
/// 
/// Returns:  
///  - `node_ids` : Query selector result.
/// 
pub fn query_selector_all(
  callback__,
  node_id node_id: NodeId,
  selector selector: String,
) {
  use result__ <- result.try(callback__(
    "DOM.querySelectorAll",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("selector", json.string(selector)),
      ]),
    ),
  ))

  decode__query_selector_all_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Removes attribute with given name from an element with given id.
/// 
/// Parameters:  
///  - `node_id` : Id of the element to remove attribute from.
///  - `name` : Name of the attribute to remove.
/// 
/// Returns:  
/// 
pub fn remove_attribute(callback__, node_id node_id: NodeId, name name: String) {
  callback__(
    "DOM.removeAttribute",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("name", json.string(name)),
      ]),
    ),
  )
}

/// Removes node with given id.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to remove.
/// 
/// Returns:  
/// 
pub fn remove_node(callback__, node_id node_id: NodeId) {
  callback__(
    "DOM.removeNode",
    option.Some(json.object([#("nodeId", encode__node_id(node_id))])),
  )
}

/// Requests that children of the node with given id are returned to the caller in form of
/// `setChildNodes` events where not only immediate children are retrieved, but all children down to
/// the specified depth.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to get children for.
///  - `depth` : The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
///  - `pierce` : Whether or not iframes and shadow roots should be traversed when returning the sub-tree
/// (default is false).
/// 
/// Returns:  
/// 
pub fn request_child_nodes(
  callback__,
  node_id node_id: NodeId,
  depth depth: option.Option(Int),
  pierce pierce: option.Option(Bool),
) {
  callback__(
    "DOM.requestChildNodes",
    option.Some(json.object(
      [#("nodeId", encode__node_id(node_id))]
      |> utils.add_optional(depth, fn(inner_value__) {
        #("depth", json.int(inner_value__))
      })
      |> utils.add_optional(pierce, fn(inner_value__) {
        #("pierce", json.bool(inner_value__))
      }),
    )),
  )
}

/// Requests that the node is sent to the caller given the JavaScript node object reference. All
/// nodes that form the path from the node to the root are also sent to the client as a series of
/// `setChildNodes` notifications.
/// 
/// Parameters:  
///  - `object_id` : JavaScript object id to convert into node.
/// 
/// Returns:  
///  - `node_id` : Node id for given object.
/// 
pub fn request_node(callback__, object_id object_id: runtime.RemoteObjectId) {
  use result__ <- result.try(callback__(
    "DOM.requestNode",
    option.Some(
      json.object([#("objectId", runtime.encode__remote_object_id(object_id))]),
    ),
  ))

  decode__request_node_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Resolves the JavaScript node object for a given NodeId or BackendNodeId.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to resolve.
///  - `backend_node_id` : Backend identifier of the node to resolve.
///  - `object_group` : Symbolic group name that can be used to release multiple objects.
///  - `execution_context_id` : Execution context in which to resolve the node.
/// 
/// Returns:  
///  - `object` : JavaScript object wrapper for given node.
/// 
pub fn resolve_node(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_group object_group: option.Option(String),
  execution_context_id execution_context_id: option.Option(
    runtime.ExecutionContextId,
  ),
) {
  use result__ <- result.try(callback__(
    "DOM.resolveNode",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_group, fn(inner_value__) {
        #("objectGroup", json.string(inner_value__))
      })
      |> utils.add_optional(execution_context_id, fn(inner_value__) {
        #(
          "executionContextId",
          runtime.encode__execution_context_id(inner_value__),
        )
      }),
    )),
  ))

  decode__resolve_node_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Sets attribute for an element with given id.
/// 
/// Parameters:  
///  - `node_id` : Id of the element to set attribute for.
///  - `name` : Attribute name.
///  - `value` : Attribute value.
/// 
/// Returns:  
/// 
pub fn set_attribute_value(
  callback__,
  node_id node_id: NodeId,
  name name: String,
  value value: String,
) {
  callback__(
    "DOM.setAttributeValue",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("name", json.string(name)),
        #("value", json.string(value)),
      ]),
    ),
  )
}

/// Sets attributes on element with given id. This method is useful when user edits some existing
/// attribute value and types in several attribute name/value pairs.
/// 
/// Parameters:  
///  - `node_id` : Id of the element to set attributes for.
///  - `text` : Text with a number of attributes. Will parse this text using HTML parser.
///  - `name` : Attribute name to replace with new attributes derived from text in case text parsed
/// successfully.
/// 
/// Returns:  
/// 
pub fn set_attributes_as_text(
  callback__,
  node_id node_id: NodeId,
  text text: String,
  name name: option.Option(String),
) {
  callback__(
    "DOM.setAttributesAsText",
    option.Some(json.object(
      [#("nodeId", encode__node_id(node_id)), #("text", json.string(text))]
      |> utils.add_optional(name, fn(inner_value__) {
        #("name", json.string(inner_value__))
      }),
    )),
  )
}

/// Sets files for the given file input element.
/// 
/// Parameters:  
///  - `files` : Array of file paths to set.
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
/// 
/// Returns:  
/// 
pub fn set_file_input_files(
  callback__,
  files files: List(String),
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
) {
  callback__(
    "DOM.setFileInputFiles",
    option.Some(json.object(
      [#("files", json.array(files, of: json.string))]
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      }),
    )),
  )
}

/// Sets node name for a node with given id.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to set name for.
///  - `name` : New node's name.
/// 
/// Returns:  
///  - `node_id` : New node's id.
/// 
pub fn set_node_name(callback__, node_id node_id: NodeId, name name: String) {
  use result__ <- result.try(callback__(
    "DOM.setNodeName",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("name", json.string(name)),
      ]),
    ),
  ))

  decode__set_node_name_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Sets node value for a node with given id.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to set value for.
///  - `value` : New node's value.
/// 
/// Returns:  
/// 
pub fn set_node_value(callback__, node_id node_id: NodeId, value value: String) {
  callback__(
    "DOM.setNodeValue",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("value", json.string(value)),
      ]),
    ),
  )
}

/// Sets node HTML markup, returns new node id.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to set markup for.
///  - `outer_html` : Outer HTML markup to set.
/// 
/// Returns:  
/// 
pub fn set_outer_html(
  callback__,
  node_id node_id: NodeId,
  outer_html outer_html: String,
) {
  callback__(
    "DOM.setOuterHTML",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("outerHTML", json.string(outer_html)),
      ]),
    ),
  )
}
