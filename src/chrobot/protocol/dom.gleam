//// > âš™ï¸  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## DOM Domain  
////
//// This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
//// that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
//// the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
//// nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
//// and never sends the same node twice. It is client's responsibility to collect information about
//// the nodes that were sent to the client. Note that `iframe` owner elements will return
//// corresponding document elements as their child nodes.  
////
//// [ðŸ“–   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/DOM/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// |                     Run `codegen.sh` to regenerate.                     |
// ---------------------------------------------------------------------------

import chrobot/chrome
import chrobot/internal/utils
import chrobot/protocol/runtime
import gleam/dynamic
import gleam/dynamic/decode
import gleam/json
import gleam/option
import gleam/result

/// Unique DOM node identifier.
pub type NodeId {
  NodeId(Int)
}

@internal
pub fn encode__node_id(value__: NodeId) {
  case value__ {
    NodeId(inner_value__) -> json.int(inner_value__)
  }
}

@internal
pub fn decode__node_id() {
  {
    use value__ <- decode.then(decode.int)
    decode.success(NodeId(value__))
  }
}

/// Unique DOM node identifier used to reference a node that may not have been pushed to the
/// front-end.
pub type BackendNodeId {
  BackendNodeId(Int)
}

@internal
pub fn encode__backend_node_id(value__: BackendNodeId) {
  case value__ {
    BackendNodeId(inner_value__) -> json.int(inner_value__)
  }
}

@internal
pub fn decode__backend_node_id() {
  {
    use value__ <- decode.then(decode.int)
    decode.success(BackendNodeId(value__))
  }
}

/// Backend node with a friendly name.
pub type BackendNode {
  BackendNode(
    /// `Node`'s nodeType.  
    node_type: Int,
    /// `Node`'s nodeName.  
    node_name: String,
    backend_node_id: BackendNodeId,
  )
}

@internal
pub fn encode__backend_node(value__: BackendNode) {
  json.object([
    #("nodeType", json.int(value__.node_type)),
    #("nodeName", json.string(value__.node_name)),
    #("backendNodeId", encode__backend_node_id(value__.backend_node_id)),
  ])
}

@internal
pub fn decode__backend_node() {
  {
    use node_type <- decode.field("nodeType", decode.int)
    use node_name <- decode.field("nodeName", decode.string)
    use backend_node_id <- decode.field(
      "backendNodeId",
      decode__backend_node_id(),
    )

    decode.success(BackendNode(
      node_type: node_type,
      node_name: node_name,
      backend_node_id: backend_node_id,
    ))
  }
}

/// Pseudo element type.
pub type PseudoType {
  PseudoTypeFirstLine
  PseudoTypeFirstLetter
  PseudoTypeBefore
  PseudoTypeAfter
  PseudoTypeMarker
  PseudoTypeBackdrop
  PseudoTypeSelection
  PseudoTypeTargetText
  PseudoTypeSpellingError
  PseudoTypeGrammarError
  PseudoTypeHighlight
  PseudoTypeFirstLineInherited
  PseudoTypeScrollMarker
  PseudoTypeScrollMarkers
  PseudoTypeScrollbar
  PseudoTypeScrollbarThumb
  PseudoTypeScrollbarButton
  PseudoTypeScrollbarTrack
  PseudoTypeScrollbarTrackPiece
  PseudoTypeScrollbarCorner
  PseudoTypeResizer
  PseudoTypeInputListButton
  PseudoTypeViewTransition
  PseudoTypeViewTransitionGroup
  PseudoTypeViewTransitionImagePair
  PseudoTypeViewTransitionOld
  PseudoTypeViewTransitionNew
}

@internal
pub fn encode__pseudo_type(value__: PseudoType) {
  case value__ {
    PseudoTypeFirstLine -> "first-line"
    PseudoTypeFirstLetter -> "first-letter"
    PseudoTypeBefore -> "before"
    PseudoTypeAfter -> "after"
    PseudoTypeMarker -> "marker"
    PseudoTypeBackdrop -> "backdrop"
    PseudoTypeSelection -> "selection"
    PseudoTypeTargetText -> "target-text"
    PseudoTypeSpellingError -> "spelling-error"
    PseudoTypeGrammarError -> "grammar-error"
    PseudoTypeHighlight -> "highlight"
    PseudoTypeFirstLineInherited -> "first-line-inherited"
    PseudoTypeScrollMarker -> "scroll-marker"
    PseudoTypeScrollMarkers -> "scroll-markers"
    PseudoTypeScrollbar -> "scrollbar"
    PseudoTypeScrollbarThumb -> "scrollbar-thumb"
    PseudoTypeScrollbarButton -> "scrollbar-button"
    PseudoTypeScrollbarTrack -> "scrollbar-track"
    PseudoTypeScrollbarTrackPiece -> "scrollbar-track-piece"
    PseudoTypeScrollbarCorner -> "scrollbar-corner"
    PseudoTypeResizer -> "resizer"
    PseudoTypeInputListButton -> "input-list-button"
    PseudoTypeViewTransition -> "view-transition"
    PseudoTypeViewTransitionGroup -> "view-transition-group"
    PseudoTypeViewTransitionImagePair -> "view-transition-image-pair"
    PseudoTypeViewTransitionOld -> "view-transition-old"
    PseudoTypeViewTransitionNew -> "view-transition-new"
  }
  |> json.string()
}

@internal
pub fn decode__pseudo_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "first-line" -> decode.success(PseudoTypeFirstLine)
      "first-letter" -> decode.success(PseudoTypeFirstLetter)
      "before" -> decode.success(PseudoTypeBefore)
      "after" -> decode.success(PseudoTypeAfter)
      "marker" -> decode.success(PseudoTypeMarker)
      "backdrop" -> decode.success(PseudoTypeBackdrop)
      "selection" -> decode.success(PseudoTypeSelection)
      "target-text" -> decode.success(PseudoTypeTargetText)
      "spelling-error" -> decode.success(PseudoTypeSpellingError)
      "grammar-error" -> decode.success(PseudoTypeGrammarError)
      "highlight" -> decode.success(PseudoTypeHighlight)
      "first-line-inherited" -> decode.success(PseudoTypeFirstLineInherited)
      "scroll-marker" -> decode.success(PseudoTypeScrollMarker)
      "scroll-markers" -> decode.success(PseudoTypeScrollMarkers)
      "scrollbar" -> decode.success(PseudoTypeScrollbar)
      "scrollbar-thumb" -> decode.success(PseudoTypeScrollbarThumb)
      "scrollbar-button" -> decode.success(PseudoTypeScrollbarButton)
      "scrollbar-track" -> decode.success(PseudoTypeScrollbarTrack)
      "scrollbar-track-piece" -> decode.success(PseudoTypeScrollbarTrackPiece)
      "scrollbar-corner" -> decode.success(PseudoTypeScrollbarCorner)
      "resizer" -> decode.success(PseudoTypeResizer)
      "input-list-button" -> decode.success(PseudoTypeInputListButton)
      "view-transition" -> decode.success(PseudoTypeViewTransition)
      "view-transition-group" -> decode.success(PseudoTypeViewTransitionGroup)
      "view-transition-image-pair" ->
        decode.success(PseudoTypeViewTransitionImagePair)
      "view-transition-old" -> decode.success(PseudoTypeViewTransitionOld)
      "view-transition-new" -> decode.success(PseudoTypeViewTransitionNew)
      _ -> decode.failure(PseudoTypeFirstLine, "valid enum property")
    }
  }
}

/// Shadow root type.
pub type ShadowRootType {
  ShadowRootTypeUserAgent
  ShadowRootTypeOpen
  ShadowRootTypeClosed
}

@internal
pub fn encode__shadow_root_type(value__: ShadowRootType) {
  case value__ {
    ShadowRootTypeUserAgent -> "user-agent"
    ShadowRootTypeOpen -> "open"
    ShadowRootTypeClosed -> "closed"
  }
  |> json.string()
}

@internal
pub fn decode__shadow_root_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "user-agent" -> decode.success(ShadowRootTypeUserAgent)
      "open" -> decode.success(ShadowRootTypeOpen)
      "closed" -> decode.success(ShadowRootTypeClosed)
      _ -> decode.failure(ShadowRootTypeUserAgent, "valid enum property")
    }
  }
}

/// Document compatibility mode.
pub type CompatibilityMode {
  CompatibilityModeQuirksMode
  CompatibilityModeLimitedQuirksMode
  CompatibilityModeNoQuirksMode
}

@internal
pub fn encode__compatibility_mode(value__: CompatibilityMode) {
  case value__ {
    CompatibilityModeQuirksMode -> "QuirksMode"
    CompatibilityModeLimitedQuirksMode -> "LimitedQuirksMode"
    CompatibilityModeNoQuirksMode -> "NoQuirksMode"
  }
  |> json.string()
}

@internal
pub fn decode__compatibility_mode() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "QuirksMode" -> decode.success(CompatibilityModeQuirksMode)
      "LimitedQuirksMode" -> decode.success(CompatibilityModeLimitedQuirksMode)
      "NoQuirksMode" -> decode.success(CompatibilityModeNoQuirksMode)
      _ -> decode.failure(CompatibilityModeQuirksMode, "valid enum property")
    }
  }
}

/// ContainerSelector physical axes
pub type PhysicalAxes {
  PhysicalAxesHorizontal
  PhysicalAxesVertical
  PhysicalAxesBoth
}

@internal
pub fn encode__physical_axes(value__: PhysicalAxes) {
  case value__ {
    PhysicalAxesHorizontal -> "Horizontal"
    PhysicalAxesVertical -> "Vertical"
    PhysicalAxesBoth -> "Both"
  }
  |> json.string()
}

@internal
pub fn decode__physical_axes() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "Horizontal" -> decode.success(PhysicalAxesHorizontal)
      "Vertical" -> decode.success(PhysicalAxesVertical)
      "Both" -> decode.success(PhysicalAxesBoth)
      _ -> decode.failure(PhysicalAxesHorizontal, "valid enum property")
    }
  }
}

/// ContainerSelector logical axes
pub type LogicalAxes {
  LogicalAxesInline
  LogicalAxesBlock
  LogicalAxesBoth
}

@internal
pub fn encode__logical_axes(value__: LogicalAxes) {
  case value__ {
    LogicalAxesInline -> "Inline"
    LogicalAxesBlock -> "Block"
    LogicalAxesBoth -> "Both"
  }
  |> json.string()
}

@internal
pub fn decode__logical_axes() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "Inline" -> decode.success(LogicalAxesInline)
      "Block" -> decode.success(LogicalAxesBlock)
      "Both" -> decode.success(LogicalAxesBoth)
      _ -> decode.failure(LogicalAxesInline, "valid enum property")
    }
  }
}

/// Physical scroll orientation
pub type ScrollOrientation {
  ScrollOrientationHorizontal
  ScrollOrientationVertical
}

@internal
pub fn encode__scroll_orientation(value__: ScrollOrientation) {
  case value__ {
    ScrollOrientationHorizontal -> "horizontal"
    ScrollOrientationVertical -> "vertical"
  }
  |> json.string()
}

@internal
pub fn decode__scroll_orientation() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "horizontal" -> decode.success(ScrollOrientationHorizontal)
      "vertical" -> decode.success(ScrollOrientationVertical)
      _ -> decode.failure(ScrollOrientationHorizontal, "valid enum property")
    }
  }
}

/// DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
/// DOMNode is a base node mirror type.
pub type Node {
  Node(
    /// Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
    /// will only push node with given `id` once. It is aware of all requested nodes and will only
    /// fire DOM events for nodes known to the client.  
    node_id: NodeId,
    /// The id of the parent node if any.  
    parent_id: option.Option(NodeId),
    /// The BackendNodeId for this node.  
    backend_node_id: BackendNodeId,
    /// `Node`'s nodeType.  
    node_type: Int,
    /// `Node`'s nodeName.  
    node_name: String,
    /// `Node`'s localName.  
    local_name: String,
    /// `Node`'s nodeValue.  
    node_value: String,
    /// Child count for `Container` nodes.  
    child_node_count: option.Option(Int),
    /// Child nodes of this node when requested with children.  
    children: option.Option(List(Node)),
    /// Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.  
    attributes: option.Option(List(String)),
    /// Document URL that `Document` or `FrameOwner` node points to.  
    document_url: option.Option(String),
    /// Base URL that `Document` or `FrameOwner` node uses for URL completion.  
    base_url: option.Option(String),
    /// `DocumentType`'s publicId.  
    public_id: option.Option(String),
    /// `DocumentType`'s systemId.  
    system_id: option.Option(String),
    /// `DocumentType`'s internalSubset.  
    internal_subset: option.Option(String),
    /// `Document`'s XML version in case of XML documents.  
    xml_version: option.Option(String),
    /// `Attr`'s name.  
    name: option.Option(String),
    /// `Attr`'s value.  
    value: option.Option(String),
    /// Pseudo element type for this node.  
    pseudo_type: option.Option(PseudoType),
    /// Pseudo element identifier for this node. Only present if there is a
    /// valid pseudoType.  
    pseudo_identifier: option.Option(String),
    /// Shadow root type.  
    shadow_root_type: option.Option(ShadowRootType),
    /// Frame ID for frame owner elements.  
    frame_id: option.Option(String),
    /// Content document for frame owner elements.  
    content_document: option.Option(Node),
    /// Shadow root list for given element host.  
    shadow_roots: option.Option(List(Node)),
    /// Content document fragment for template elements.  
    template_content: option.Option(Node),
    /// Pseudo elements associated with this node.  
    pseudo_elements: option.Option(List(Node)),
    /// Distributed nodes for given insertion point.  
    distributed_nodes: option.Option(List(BackendNode)),
    /// Whether the node is SVG.  
    is_svg: option.Option(Bool),
    compatibility_mode: option.Option(CompatibilityMode),
    assigned_slot: option.Option(BackendNode),
  )
}

@internal
pub fn encode__node(value__: Node) {
  json.object(
    [
      #("nodeId", encode__node_id(value__.node_id)),
      #("backendNodeId", encode__backend_node_id(value__.backend_node_id)),
      #("nodeType", json.int(value__.node_type)),
      #("nodeName", json.string(value__.node_name)),
      #("localName", json.string(value__.local_name)),
      #("nodeValue", json.string(value__.node_value)),
    ]
    |> utils.add_optional(value__.parent_id, fn(inner_value__) {
      #("parentId", encode__node_id(inner_value__))
    })
    |> utils.add_optional(value__.child_node_count, fn(inner_value__) {
      #("childNodeCount", json.int(inner_value__))
    })
    |> utils.add_optional(value__.children, fn(inner_value__) {
      #("children", json.array(inner_value__, of: encode__node))
    })
    |> utils.add_optional(value__.attributes, fn(inner_value__) {
      #("attributes", json.array(inner_value__, of: json.string))
    })
    |> utils.add_optional(value__.document_url, fn(inner_value__) {
      #("documentURL", json.string(inner_value__))
    })
    |> utils.add_optional(value__.base_url, fn(inner_value__) {
      #("baseURL", json.string(inner_value__))
    })
    |> utils.add_optional(value__.public_id, fn(inner_value__) {
      #("publicId", json.string(inner_value__))
    })
    |> utils.add_optional(value__.system_id, fn(inner_value__) {
      #("systemId", json.string(inner_value__))
    })
    |> utils.add_optional(value__.internal_subset, fn(inner_value__) {
      #("internalSubset", json.string(inner_value__))
    })
    |> utils.add_optional(value__.xml_version, fn(inner_value__) {
      #("xmlVersion", json.string(inner_value__))
    })
    |> utils.add_optional(value__.name, fn(inner_value__) {
      #("name", json.string(inner_value__))
    })
    |> utils.add_optional(value__.value, fn(inner_value__) {
      #("value", json.string(inner_value__))
    })
    |> utils.add_optional(value__.pseudo_type, fn(inner_value__) {
      #("pseudoType", encode__pseudo_type(inner_value__))
    })
    |> utils.add_optional(value__.pseudo_identifier, fn(inner_value__) {
      #("pseudoIdentifier", json.string(inner_value__))
    })
    |> utils.add_optional(value__.shadow_root_type, fn(inner_value__) {
      #("shadowRootType", encode__shadow_root_type(inner_value__))
    })
    |> utils.add_optional(value__.frame_id, fn(inner_value__) {
      #("frameId", json.string(inner_value__))
    })
    |> utils.add_optional(value__.content_document, fn(inner_value__) {
      #("contentDocument", encode__node(inner_value__))
    })
    |> utils.add_optional(value__.shadow_roots, fn(inner_value__) {
      #("shadowRoots", json.array(inner_value__, of: encode__node))
    })
    |> utils.add_optional(value__.template_content, fn(inner_value__) {
      #("templateContent", encode__node(inner_value__))
    })
    |> utils.add_optional(value__.pseudo_elements, fn(inner_value__) {
      #("pseudoElements", json.array(inner_value__, of: encode__node))
    })
    |> utils.add_optional(value__.distributed_nodes, fn(inner_value__) {
      #("distributedNodes", json.array(inner_value__, of: encode__backend_node))
    })
    |> utils.add_optional(value__.is_svg, fn(inner_value__) {
      #("isSVG", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.compatibility_mode, fn(inner_value__) {
      #("compatibilityMode", encode__compatibility_mode(inner_value__))
    })
    |> utils.add_optional(value__.assigned_slot, fn(inner_value__) {
      #("assignedSlot", encode__backend_node(inner_value__))
    }),
  )
}

@internal
pub fn decode__node() {
  {
    use node_id <- decode.field("nodeId", decode__node_id())
    use parent_id <- decode.optional_field(
      "parentId",
      option.None,
      decode.optional(decode__node_id()),
    )
    use backend_node_id <- decode.field(
      "backendNodeId",
      decode__backend_node_id(),
    )
    use node_type <- decode.field("nodeType", decode.int)
    use node_name <- decode.field("nodeName", decode.string)
    use local_name <- decode.field("localName", decode.string)
    use node_value <- decode.field("nodeValue", decode.string)
    use child_node_count <- decode.optional_field(
      "childNodeCount",
      option.None,
      decode.optional(decode.int),
    )
    use children <- decode.optional_field(
      "children",
      option.None,
      decode.optional(decode.list(decode__node())),
    )
    use attributes <- decode.optional_field(
      "attributes",
      option.None,
      decode.optional(decode.list(decode.string)),
    )
    use document_url <- decode.optional_field(
      "documentURL",
      option.None,
      decode.optional(decode.string),
    )
    use base_url <- decode.optional_field(
      "baseURL",
      option.None,
      decode.optional(decode.string),
    )
    use public_id <- decode.optional_field(
      "publicId",
      option.None,
      decode.optional(decode.string),
    )
    use system_id <- decode.optional_field(
      "systemId",
      option.None,
      decode.optional(decode.string),
    )
    use internal_subset <- decode.optional_field(
      "internalSubset",
      option.None,
      decode.optional(decode.string),
    )
    use xml_version <- decode.optional_field(
      "xmlVersion",
      option.None,
      decode.optional(decode.string),
    )
    use name <- decode.optional_field(
      "name",
      option.None,
      decode.optional(decode.string),
    )
    use value <- decode.optional_field(
      "value",
      option.None,
      decode.optional(decode.string),
    )
    use pseudo_type <- decode.optional_field(
      "pseudoType",
      option.None,
      decode.optional(decode__pseudo_type()),
    )
    use pseudo_identifier <- decode.optional_field(
      "pseudoIdentifier",
      option.None,
      decode.optional(decode.string),
    )
    use shadow_root_type <- decode.optional_field(
      "shadowRootType",
      option.None,
      decode.optional(decode__shadow_root_type()),
    )
    use frame_id <- decode.optional_field(
      "frameId",
      option.None,
      decode.optional(decode.string),
    )
    use content_document <- decode.optional_field(
      "contentDocument",
      option.None,
      decode.optional(decode__node()),
    )
    use shadow_roots <- decode.optional_field(
      "shadowRoots",
      option.None,
      decode.optional(decode.list(decode__node())),
    )
    use template_content <- decode.optional_field(
      "templateContent",
      option.None,
      decode.optional(decode__node()),
    )
    use pseudo_elements <- decode.optional_field(
      "pseudoElements",
      option.None,
      decode.optional(decode.list(decode__node())),
    )
    use distributed_nodes <- decode.optional_field(
      "distributedNodes",
      option.None,
      decode.optional(decode.list(decode__backend_node())),
    )
    use is_svg <- decode.optional_field(
      "isSVG",
      option.None,
      decode.optional(decode.bool),
    )
    use compatibility_mode <- decode.optional_field(
      "compatibilityMode",
      option.None,
      decode.optional(decode__compatibility_mode()),
    )
    use assigned_slot <- decode.optional_field(
      "assignedSlot",
      option.None,
      decode.optional(decode__backend_node()),
    )

    decode.success(Node(
      node_id: node_id,
      parent_id: parent_id,
      backend_node_id: backend_node_id,
      node_type: node_type,
      node_name: node_name,
      local_name: local_name,
      node_value: node_value,
      child_node_count: child_node_count,
      children: children,
      attributes: attributes,
      document_url: document_url,
      base_url: base_url,
      public_id: public_id,
      system_id: system_id,
      internal_subset: internal_subset,
      xml_version: xml_version,
      name: name,
      value: value,
      pseudo_type: pseudo_type,
      pseudo_identifier: pseudo_identifier,
      shadow_root_type: shadow_root_type,
      frame_id: frame_id,
      content_document: content_document,
      shadow_roots: shadow_roots,
      template_content: template_content,
      pseudo_elements: pseudo_elements,
      distributed_nodes: distributed_nodes,
      is_svg: is_svg,
      compatibility_mode: compatibility_mode,
      assigned_slot: assigned_slot,
    ))
  }
}

/// A structure holding an RGBA color.
pub type RGBA {
  RGBA(
    /// The red component, in the [0-255] range.  
    r: Int,
    /// The green component, in the [0-255] range.  
    g: Int,
    /// The blue component, in the [0-255] range.  
    b: Int,
    /// The alpha component, in the [0-1] range (default: 1).  
    a: option.Option(Float),
  )
}

@internal
pub fn encode__rgba(value__: RGBA) {
  json.object(
    [
      #("r", json.int(value__.r)),
      #("g", json.int(value__.g)),
      #("b", json.int(value__.b)),
    ]
    |> utils.add_optional(value__.a, fn(inner_value__) {
      #("a", json.float(inner_value__))
    }),
  )
}

@internal
pub fn decode__rgba() {
  {
    use r <- decode.field("r", decode.int)
    use g <- decode.field("g", decode.int)
    use b <- decode.field("b", decode.int)
    use a <- decode.optional_field(
      "a",
      option.None,
      decode.optional(decode.float),
    )

    decode.success(RGBA(r: r, g: g, b: b, a: a))
  }
}

/// An array of quad vertices, x immediately followed by y for each point, points clock-wise.
pub type Quad {
  Quad(List(Float))
}

@internal
pub fn encode__quad(value__: Quad) {
  case value__ {
    Quad(inner_value__) -> json.array(inner_value__, of: json.float)
  }
}

@internal
pub fn decode__quad() {
  {
    use value__ <- decode.then(decode.list(decode.float))
    decode.success(Quad(value__))
  }
}

/// Box model.
pub type BoxModel {
  BoxModel(
    /// Content box  
    content: Quad,
    /// Padding box  
    padding: Quad,
    /// Border box  
    border: Quad,
    /// Margin box  
    margin: Quad,
    /// Node width  
    width: Int,
    /// Node height  
    height: Int,
    /// Shape outside coordinates  
    shape_outside: option.Option(ShapeOutsideInfo),
  )
}

@internal
pub fn encode__box_model(value__: BoxModel) {
  json.object(
    [
      #("content", encode__quad(value__.content)),
      #("padding", encode__quad(value__.padding)),
      #("border", encode__quad(value__.border)),
      #("margin", encode__quad(value__.margin)),
      #("width", json.int(value__.width)),
      #("height", json.int(value__.height)),
    ]
    |> utils.add_optional(value__.shape_outside, fn(inner_value__) {
      #("shapeOutside", encode__shape_outside_info(inner_value__))
    }),
  )
}

@internal
pub fn decode__box_model() {
  {
    use content <- decode.field("content", decode__quad())
    use padding <- decode.field("padding", decode__quad())
    use border <- decode.field("border", decode__quad())
    use margin <- decode.field("margin", decode__quad())
    use width <- decode.field("width", decode.int)
    use height <- decode.field("height", decode.int)
    use shape_outside <- decode.optional_field(
      "shapeOutside",
      option.None,
      decode.optional(decode__shape_outside_info()),
    )

    decode.success(BoxModel(
      content: content,
      padding: padding,
      border: border,
      margin: margin,
      width: width,
      height: height,
      shape_outside: shape_outside,
    ))
  }
}

/// CSS Shape Outside details.
pub type ShapeOutsideInfo {
  ShapeOutsideInfo(
    /// Shape bounds  
    bounds: Quad,
    /// Shape coordinate details  
    shape: List(dynamic.Dynamic),
    /// Margin shape bounds  
    margin_shape: List(dynamic.Dynamic),
  )
}

@internal
pub fn encode__shape_outside_info(value__: ShapeOutsideInfo) {
  json.object([
    #("bounds", encode__quad(value__.bounds)),
    #(
      "shape",
      // dynamic values cannot be encoded!
      json.null(),
    ),
    #(
      "marginShape",
      // dynamic values cannot be encoded!
      json.null(),
    ),
  ])
}

@internal
pub fn decode__shape_outside_info() {
  {
    use bounds <- decode.field("bounds", decode__quad())
    use shape <- decode.field("shape", decode.list(decode.dynamic))
    use margin_shape <- decode.field("marginShape", decode.list(decode.dynamic))

    decode.success(ShapeOutsideInfo(
      bounds: bounds,
      shape: shape,
      margin_shape: margin_shape,
    ))
  }
}

/// Rectangle.
pub type Rect {
  Rect(
    /// X coordinate  
    x: Float,
    /// Y coordinate  
    y: Float,
    /// Rectangle width  
    width: Float,
    /// Rectangle height  
    height: Float,
  )
}

@internal
pub fn encode__rect(value__: Rect) {
  json.object([
    #("x", json.float(value__.x)),
    #("y", json.float(value__.y)),
    #("width", json.float(value__.width)),
    #("height", json.float(value__.height)),
  ])
}

@internal
pub fn decode__rect() {
  {
    use x <- decode.field("x", decode.float)
    use y <- decode.field("y", decode.float)
    use width <- decode.field("width", decode.float)
    use height <- decode.field("height", decode.float)

    decode.success(Rect(x: x, y: y, width: width, height: height))
  }
}

pub type CSSComputedStyleProperty {
  CSSComputedStyleProperty(
    /// Computed style property name.  
    name: String,
    /// Computed style property value.  
    value: String,
  )
}

@internal
pub fn encode__css_computed_style_property(value__: CSSComputedStyleProperty) {
  json.object([
    #("name", json.string(value__.name)),
    #("value", json.string(value__.value)),
  ])
}

@internal
pub fn decode__css_computed_style_property() {
  {
    use name <- decode.field("name", decode.string)
    use value <- decode.field("value", decode.string)

    decode.success(CSSComputedStyleProperty(name: name, value: value))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `describe_node`
pub type DescribeNodeResponse {
  DescribeNodeResponse(
    /// Node description.  
    node: Node,
  )
}

@internal
pub fn decode__describe_node_response() {
  {
    use node <- decode.field("node", decode__node())

    decode.success(DescribeNodeResponse(node: node))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_attributes`
pub type GetAttributesResponse {
  GetAttributesResponse(
    /// An interleaved array of node attribute names and values.  
    attributes: List(String),
  )
}

@internal
pub fn decode__get_attributes_response() {
  {
    use attributes <- decode.field("attributes", decode.list(decode.string))

    decode.success(GetAttributesResponse(attributes: attributes))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_box_model`
pub type GetBoxModelResponse {
  GetBoxModelResponse(
    /// Box model for the node.  
    model: BoxModel,
  )
}

@internal
pub fn decode__get_box_model_response() {
  {
    use model <- decode.field("model", decode__box_model())

    decode.success(GetBoxModelResponse(model: model))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_document`
pub type GetDocumentResponse {
  GetDocumentResponse(
    /// Resulting node.  
    root: Node,
  )
}

@internal
pub fn decode__get_document_response() {
  {
    use root <- decode.field("root", decode__node())

    decode.success(GetDocumentResponse(root: root))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_node_for_location`
pub type GetNodeForLocationResponse {
  GetNodeForLocationResponse(
    /// Resulting node.  
    backend_node_id: BackendNodeId,
    /// Frame this node belongs to.  
    frame_id: String,
    /// Id of the node at given coordinates, only when enabled and requested document.  
    node_id: option.Option(NodeId),
  )
}

@internal
pub fn decode__get_node_for_location_response() {
  {
    use backend_node_id <- decode.field(
      "backendNodeId",
      decode__backend_node_id(),
    )
    use frame_id <- decode.field("frameId", decode.string)
    use node_id <- decode.optional_field(
      "nodeId",
      option.None,
      decode.optional(decode__node_id()),
    )

    decode.success(GetNodeForLocationResponse(
      backend_node_id: backend_node_id,
      frame_id: frame_id,
      node_id: node_id,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_outer_html`
pub type GetOuterHtmlResponse {
  GetOuterHtmlResponse(
    /// Outer HTML markup.  
    outer_html: String,
  )
}

@internal
pub fn decode__get_outer_html_response() {
  {
    use outer_html <- decode.field("outerHTML", decode.string)

    decode.success(GetOuterHtmlResponse(outer_html: outer_html))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `move_to`
pub type MoveToResponse {
  MoveToResponse(
    /// New id of the moved node.  
    node_id: NodeId,
  )
}

@internal
pub fn decode__move_to_response() {
  {
    use node_id <- decode.field("nodeId", decode__node_id())

    decode.success(MoveToResponse(node_id: node_id))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `query_selector`
pub type QuerySelectorResponse {
  QuerySelectorResponse(
    /// Query selector result.  
    node_id: NodeId,
  )
}

@internal
pub fn decode__query_selector_response() {
  {
    use node_id <- decode.field("nodeId", decode__node_id())

    decode.success(QuerySelectorResponse(node_id: node_id))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `query_selector_all`
pub type QuerySelectorAllResponse {
  QuerySelectorAllResponse(
    /// Query selector result.  
    node_ids: List(NodeId),
  )
}

@internal
pub fn decode__query_selector_all_response() {
  {
    use node_ids <- decode.field("nodeIds", decode.list(decode__node_id()))

    decode.success(QuerySelectorAllResponse(node_ids: node_ids))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `request_node`
pub type RequestNodeResponse {
  RequestNodeResponse(
    /// Node id for given object.  
    node_id: NodeId,
  )
}

@internal
pub fn decode__request_node_response() {
  {
    use node_id <- decode.field("nodeId", decode__node_id())

    decode.success(RequestNodeResponse(node_id: node_id))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `resolve_node`
pub type ResolveNodeResponse {
  ResolveNodeResponse(
    /// JavaScript object wrapper for given node.  
    object: runtime.RemoteObject,
  )
}

@internal
pub fn decode__resolve_node_response() {
  {
    use object <- decode.field("object", runtime.decode__remote_object())

    decode.success(ResolveNodeResponse(object: object))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `set_node_name`
pub type SetNodeNameResponse {
  SetNodeNameResponse(
    /// New node's id.  
    node_id: NodeId,
  )
}

@internal
pub fn decode__set_node_name_response() {
  {
    use node_id <- decode.field("nodeId", decode__node_id())

    decode.success(SetNodeNameResponse(node_id: node_id))
  }
}

/// Describes node given its id, does not require domain to be enabled. Does not start tracking any
/// objects, can be used for automation.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
///  - `depth` : The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
///  - `pierce` : Whether or not iframes and shadow roots should be traversed when returning the subtree
/// (default is false).
/// 
/// Returns:  
///  - `node` : Node description.
/// 
pub fn describe_node(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
  depth depth: option.Option(Int),
  pierce pierce: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "DOM.describeNode",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      })
      |> utils.add_optional(depth, fn(inner_value__) {
        #("depth", json.int(inner_value__))
      })
      |> utils.add_optional(pierce, fn(inner_value__) {
        #("pierce", json.bool(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__describe_node_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Scrolls the specified rect of the given node into view if not already visible.
/// Note: exactly one between nodeId, backendNodeId and objectId should be passed
/// to identify the node.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
///  - `rect` : The rect to be scrolled into view, relative to the node's border box, in CSS pixels.
/// When omitted, center of the node will be used, similar to Element.scrollIntoView.
/// 
/// Returns:  
/// 
pub fn scroll_into_view_if_needed(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
  rect rect: option.Option(Rect),
) {
  callback__(
    "DOM.scrollIntoViewIfNeeded",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      })
      |> utils.add_optional(rect, fn(inner_value__) {
        #("rect", encode__rect(inner_value__))
      }),
    )),
  )
}

/// Disables DOM agent for the given page.
/// 
pub fn disable(callback__) {
  callback__("DOM.disable", option.None)
}

/// Enables DOM agent for the given page.
/// 
/// Parameters:  
/// 
/// Returns:  
/// 
pub fn enable(callback__) {
  callback__("DOM.enable", option.None)
}

/// Focuses the given element.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
/// 
/// Returns:  
/// 
pub fn focus(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
) {
  callback__(
    "DOM.focus",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      }),
    )),
  )
}

/// Returns attributes for the specified node.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to retrieve attributes for.
/// 
/// Returns:  
///  - `attributes` : An interleaved array of node attribute names and values.
/// 
pub fn get_attributes(callback__, node_id node_id: NodeId) {
  use result__ <- result.try(callback__(
    "DOM.getAttributes",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
      ]),
    ),
  ))

  decode.run(result__, decode__get_attributes_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns boxes for the given node.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
/// 
/// Returns:  
///  - `model` : Box model for the node.
/// 
pub fn get_box_model(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
) {
  use result__ <- result.try(callback__(
    "DOM.getBoxModel",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__get_box_model_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns the root DOM node (and optionally the subtree) to the caller.
/// Implicitly enables the DOM domain events for the current target.
/// 
/// Parameters:  
///  - `depth` : The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
///  - `pierce` : Whether or not iframes and shadow roots should be traversed when returning the subtree
/// (default is false).
/// 
/// Returns:  
///  - `root` : Resulting node.
/// 
pub fn get_document(
  callback__,
  depth depth: option.Option(Int),
  pierce pierce: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "DOM.getDocument",
    option.Some(json.object(
      []
      |> utils.add_optional(depth, fn(inner_value__) {
        #("depth", json.int(inner_value__))
      })
      |> utils.add_optional(pierce, fn(inner_value__) {
        #("pierce", json.bool(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__get_document_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
/// either returned or not.
/// 
/// Parameters:  
///  - `x` : X coordinate.
///  - `y` : Y coordinate.
///  - `include_user_agent_shadow_dom` : False to skip to the nearest non-UA shadow root ancestor (default: false).
///  - `ignore_pointer_events_none` : Whether to ignore pointer-events: none on elements and hit test them.
/// 
/// Returns:  
///  - `backend_node_id` : Resulting node.
///  - `frame_id` : Frame this node belongs to.
///  - `node_id` : Id of the node at given coordinates, only when enabled and requested document.
/// 
pub fn get_node_for_location(
  callback__,
  x x: Int,
  y y: Int,
  include_user_agent_shadow_dom include_user_agent_shadow_dom: option.Option(
    Bool,
  ),
  ignore_pointer_events_none ignore_pointer_events_none: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "DOM.getNodeForLocation",
    option.Some(json.object(
      [
        #("x", json.int(x)),
        #("y", json.int(y)),
      ]
      |> utils.add_optional(include_user_agent_shadow_dom, fn(inner_value__) {
        #("includeUserAgentShadowDOM", json.bool(inner_value__))
      })
      |> utils.add_optional(ignore_pointer_events_none, fn(inner_value__) {
        #("ignorePointerEventsNone", json.bool(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__get_node_for_location_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns node's HTML markup.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
/// 
/// Returns:  
///  - `outer_html` : Outer HTML markup.
/// 
pub fn get_outer_html(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
) {
  use result__ <- result.try(callback__(
    "DOM.getOuterHTML",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__get_outer_html_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Hides any highlight.
/// 
pub fn hide_highlight(callback__) {
  callback__("DOM.hideHighlight", option.None)
}

/// Highlights DOM node.
/// 
pub fn highlight_node(callback__) {
  callback__("DOM.highlightNode", option.None)
}

/// Highlights given rectangle.
/// 
pub fn highlight_rect(callback__) {
  callback__("DOM.highlightRect", option.None)
}

/// Moves node into the new container, places it before the given anchor.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to move.
///  - `target_node_id` : Id of the element to drop the moved node into.
///  - `insert_before_node_id` : Drop node before this one (if absent, the moved node becomes the last child of
/// `targetNodeId`).
/// 
/// Returns:  
///  - `node_id` : New id of the moved node.
/// 
pub fn move_to(
  callback__,
  node_id node_id: NodeId,
  target_node_id target_node_id: NodeId,
  insert_before_node_id insert_before_node_id: option.Option(NodeId),
) {
  use result__ <- result.try(callback__(
    "DOM.moveTo",
    option.Some(json.object(
      [
        #("nodeId", encode__node_id(node_id)),
        #("targetNodeId", encode__node_id(target_node_id)),
      ]
      |> utils.add_optional(insert_before_node_id, fn(inner_value__) {
        #("insertBeforeNodeId", encode__node_id(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__move_to_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Executes `querySelector` on a given node.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to query upon.
///  - `selector` : Selector string.
/// 
/// Returns:  
///  - `node_id` : Query selector result.
/// 
pub fn query_selector(
  callback__,
  node_id node_id: NodeId,
  selector selector: String,
) {
  use result__ <- result.try(callback__(
    "DOM.querySelector",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("selector", json.string(selector)),
      ]),
    ),
  ))

  decode.run(result__, decode__query_selector_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Executes `querySelectorAll` on a given node.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to query upon.
///  - `selector` : Selector string.
/// 
/// Returns:  
///  - `node_ids` : Query selector result.
/// 
pub fn query_selector_all(
  callback__,
  node_id node_id: NodeId,
  selector selector: String,
) {
  use result__ <- result.try(callback__(
    "DOM.querySelectorAll",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("selector", json.string(selector)),
      ]),
    ),
  ))

  decode.run(result__, decode__query_selector_all_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Removes attribute with given name from an element with given id.
/// 
/// Parameters:  
///  - `node_id` : Id of the element to remove attribute from.
///  - `name` : Name of the attribute to remove.
/// 
/// Returns:  
/// 
pub fn remove_attribute(callback__, node_id node_id: NodeId, name name: String) {
  callback__(
    "DOM.removeAttribute",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("name", json.string(name)),
      ]),
    ),
  )
}

/// Removes node with given id.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to remove.
/// 
/// Returns:  
/// 
pub fn remove_node(callback__, node_id node_id: NodeId) {
  callback__(
    "DOM.removeNode",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
      ]),
    ),
  )
}

/// Requests that children of the node with given id are returned to the caller in form of
/// `setChildNodes` events where not only immediate children are retrieved, but all children down to
/// the specified depth.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to get children for.
///  - `depth` : The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
///  - `pierce` : Whether or not iframes and shadow roots should be traversed when returning the sub-tree
/// (default is false).
/// 
/// Returns:  
/// 
pub fn request_child_nodes(
  callback__,
  node_id node_id: NodeId,
  depth depth: option.Option(Int),
  pierce pierce: option.Option(Bool),
) {
  callback__(
    "DOM.requestChildNodes",
    option.Some(json.object(
      [
        #("nodeId", encode__node_id(node_id)),
      ]
      |> utils.add_optional(depth, fn(inner_value__) {
        #("depth", json.int(inner_value__))
      })
      |> utils.add_optional(pierce, fn(inner_value__) {
        #("pierce", json.bool(inner_value__))
      }),
    )),
  )
}

/// Requests that the node is sent to the caller given the JavaScript node object reference. All
/// nodes that form the path from the node to the root are also sent to the client as a series of
/// `setChildNodes` notifications.
/// 
/// Parameters:  
///  - `object_id` : JavaScript object id to convert into node.
/// 
/// Returns:  
///  - `node_id` : Node id for given object.
/// 
pub fn request_node(callback__, object_id object_id: runtime.RemoteObjectId) {
  use result__ <- result.try(callback__(
    "DOM.requestNode",
    option.Some(
      json.object([
        #("objectId", runtime.encode__remote_object_id(object_id)),
      ]),
    ),
  ))

  decode.run(result__, decode__request_node_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Resolves the JavaScript node object for a given NodeId or BackendNodeId.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to resolve.
///  - `backend_node_id` : Backend identifier of the node to resolve.
///  - `object_group` : Symbolic group name that can be used to release multiple objects.
///  - `execution_context_id` : Execution context in which to resolve the node.
/// 
/// Returns:  
///  - `object` : JavaScript object wrapper for given node.
/// 
pub fn resolve_node(
  callback__,
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_group object_group: option.Option(String),
  execution_context_id execution_context_id: option.Option(
    runtime.ExecutionContextId,
  ),
) {
  use result__ <- result.try(callback__(
    "DOM.resolveNode",
    option.Some(json.object(
      []
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_group, fn(inner_value__) {
        #("objectGroup", json.string(inner_value__))
      })
      |> utils.add_optional(execution_context_id, fn(inner_value__) {
        #(
          "executionContextId",
          runtime.encode__execution_context_id(inner_value__),
        )
      }),
    )),
  ))

  decode.run(result__, decode__resolve_node_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Sets attribute for an element with given id.
/// 
/// Parameters:  
///  - `node_id` : Id of the element to set attribute for.
///  - `name` : Attribute name.
///  - `value` : Attribute value.
/// 
/// Returns:  
/// 
pub fn set_attribute_value(
  callback__,
  node_id node_id: NodeId,
  name name: String,
  value value: String,
) {
  callback__(
    "DOM.setAttributeValue",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("name", json.string(name)),
        #("value", json.string(value)),
      ]),
    ),
  )
}

/// Sets attributes on element with given id. This method is useful when user edits some existing
/// attribute value and types in several attribute name/value pairs.
/// 
/// Parameters:  
///  - `node_id` : Id of the element to set attributes for.
///  - `text` : Text with a number of attributes. Will parse this text using HTML parser.
///  - `name` : Attribute name to replace with new attributes derived from text in case text parsed
/// successfully.
/// 
/// Returns:  
/// 
pub fn set_attributes_as_text(
  callback__,
  node_id node_id: NodeId,
  text text: String,
  name name: option.Option(String),
) {
  callback__(
    "DOM.setAttributesAsText",
    option.Some(json.object(
      [
        #("nodeId", encode__node_id(node_id)),
        #("text", json.string(text)),
      ]
      |> utils.add_optional(name, fn(inner_value__) {
        #("name", json.string(inner_value__))
      }),
    )),
  )
}

/// Sets files for the given file input element.
/// 
/// Parameters:  
///  - `files` : Array of file paths to set.
///  - `node_id` : Identifier of the node.
///  - `backend_node_id` : Identifier of the backend node.
///  - `object_id` : JavaScript object id of the node wrapper.
/// 
/// Returns:  
/// 
pub fn set_file_input_files(
  callback__,
  files files: List(String),
  node_id node_id: option.Option(NodeId),
  backend_node_id backend_node_id: option.Option(BackendNodeId),
  object_id object_id: option.Option(runtime.RemoteObjectId),
) {
  callback__(
    "DOM.setFileInputFiles",
    option.Some(json.object(
      [
        #("files", json.array(files, of: json.string)),
      ]
      |> utils.add_optional(node_id, fn(inner_value__) {
        #("nodeId", encode__node_id(inner_value__))
      })
      |> utils.add_optional(backend_node_id, fn(inner_value__) {
        #("backendNodeId", encode__backend_node_id(inner_value__))
      })
      |> utils.add_optional(object_id, fn(inner_value__) {
        #("objectId", runtime.encode__remote_object_id(inner_value__))
      }),
    )),
  )
}

/// Sets node name for a node with given id.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to set name for.
///  - `name` : New node's name.
/// 
/// Returns:  
///  - `node_id` : New node's id.
/// 
pub fn set_node_name(callback__, node_id node_id: NodeId, name name: String) {
  use result__ <- result.try(callback__(
    "DOM.setNodeName",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("name", json.string(name)),
      ]),
    ),
  ))

  decode.run(result__, decode__set_node_name_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Sets node value for a node with given id.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to set value for.
///  - `value` : New node's value.
/// 
/// Returns:  
/// 
pub fn set_node_value(callback__, node_id node_id: NodeId, value value: String) {
  callback__(
    "DOM.setNodeValue",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("value", json.string(value)),
      ]),
    ),
  )
}

/// Sets node HTML markup, returns new node id.
/// 
/// Parameters:  
///  - `node_id` : Id of the node to set markup for.
///  - `outer_html` : Outer HTML markup to set.
/// 
/// Returns:  
/// 
pub fn set_outer_html(
  callback__,
  node_id node_id: NodeId,
  outer_html outer_html: String,
) {
  callback__(
    "DOM.setOuterHTML",
    option.Some(
      json.object([
        #("nodeId", encode__node_id(node_id)),
        #("outerHTML", json.string(outer_html)),
      ]),
    ),
  )
}
