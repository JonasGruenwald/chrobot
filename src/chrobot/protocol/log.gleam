//// > âš™ï¸  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Log Domain  
////
//// Provides access to log entries.  
////
//// [ðŸ“–   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Log/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// |                     Run `codegen.sh` to regenerate.                     |
// ---------------------------------------------------------------------------

import chrobot/internal/utils
import chrobot/protocol/network
import chrobot/protocol/runtime
import gleam/dynamic/decode
import gleam/json
import gleam/option

/// Log entry.
pub type LogEntry {
  LogEntry(
    /// Log entry source.  
    source: LogEntrySource,
    /// Log entry severity.  
    level: LogEntryLevel,
    /// Logged text.  
    text: String,
    category: option.Option(LogEntryCategory),
    /// Timestamp when this entry was added.  
    timestamp: runtime.Timestamp,
    /// URL of the resource if known.  
    url: option.Option(String),
    /// Line number in the resource.  
    line_number: option.Option(Int),
    /// JavaScript stack trace.  
    stack_trace: option.Option(runtime.StackTrace),
    /// Identifier of the network request associated with this entry.  
    network_request_id: option.Option(network.RequestId),
    /// Identifier of the worker associated with this entry.  
    worker_id: option.Option(String),
    /// Call arguments.  
    args: option.Option(List(runtime.RemoteObject)),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `source` of `LogEntry`
pub type LogEntrySource {
  LogEntrySourceXml
  LogEntrySourceJavascript
  LogEntrySourceNetwork
  LogEntrySourceStorage
  LogEntrySourceAppcache
  LogEntrySourceRendering
  LogEntrySourceSecurity
  LogEntrySourceDeprecation
  LogEntrySourceWorker
  LogEntrySourceViolation
  LogEntrySourceIntervention
  LogEntrySourceRecommendation
  LogEntrySourceOther
}

@internal
pub fn encode__log_entry_source(value__: LogEntrySource) {
  case value__ {
    LogEntrySourceXml -> "xml"
    LogEntrySourceJavascript -> "javascript"
    LogEntrySourceNetwork -> "network"
    LogEntrySourceStorage -> "storage"
    LogEntrySourceAppcache -> "appcache"
    LogEntrySourceRendering -> "rendering"
    LogEntrySourceSecurity -> "security"
    LogEntrySourceDeprecation -> "deprecation"
    LogEntrySourceWorker -> "worker"
    LogEntrySourceViolation -> "violation"
    LogEntrySourceIntervention -> "intervention"
    LogEntrySourceRecommendation -> "recommendation"
    LogEntrySourceOther -> "other"
  }
  |> json.string()
}

@internal
pub fn decode__log_entry_source() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "xml" -> decode.success(LogEntrySourceXml)
      "javascript" -> decode.success(LogEntrySourceJavascript)
      "network" -> decode.success(LogEntrySourceNetwork)
      "storage" -> decode.success(LogEntrySourceStorage)
      "appcache" -> decode.success(LogEntrySourceAppcache)
      "rendering" -> decode.success(LogEntrySourceRendering)
      "security" -> decode.success(LogEntrySourceSecurity)
      "deprecation" -> decode.success(LogEntrySourceDeprecation)
      "worker" -> decode.success(LogEntrySourceWorker)
      "violation" -> decode.success(LogEntrySourceViolation)
      "intervention" -> decode.success(LogEntrySourceIntervention)
      "recommendation" -> decode.success(LogEntrySourceRecommendation)
      "other" -> decode.success(LogEntrySourceOther)
      _ -> decode.failure(LogEntrySourceXml, "valid enum property")
    }
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `level` of `LogEntry`
pub type LogEntryLevel {
  LogEntryLevelVerbose
  LogEntryLevelInfo
  LogEntryLevelWarning
  LogEntryLevelError
}

@internal
pub fn encode__log_entry_level(value__: LogEntryLevel) {
  case value__ {
    LogEntryLevelVerbose -> "verbose"
    LogEntryLevelInfo -> "info"
    LogEntryLevelWarning -> "warning"
    LogEntryLevelError -> "error"
  }
  |> json.string()
}

@internal
pub fn decode__log_entry_level() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "verbose" -> decode.success(LogEntryLevelVerbose)
      "info" -> decode.success(LogEntryLevelInfo)
      "warning" -> decode.success(LogEntryLevelWarning)
      "error" -> decode.success(LogEntryLevelError)
      _ -> decode.failure(LogEntryLevelVerbose, "valid enum property")
    }
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `category` of `LogEntry`
pub type LogEntryCategory {
  LogEntryCategoryCors
}

@internal
pub fn encode__log_entry_category(value__: LogEntryCategory) {
  case value__ {
    LogEntryCategoryCors -> "cors"
  }
  |> json.string()
}

@internal
pub fn decode__log_entry_category() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "cors" -> decode.success(LogEntryCategoryCors)
      _ -> decode.failure(LogEntryCategoryCors, "valid enum property")
    }
  }
}

@internal
pub fn encode__log_entry(value__: LogEntry) {
  json.object(
    [
      #("source", encode__log_entry_source(value__.source)),
      #("level", encode__log_entry_level(value__.level)),
      #("text", json.string(value__.text)),
      #("timestamp", runtime.encode__timestamp(value__.timestamp)),
    ]
    |> utils.add_optional(value__.category, fn(inner_value__) {
      #("category", encode__log_entry_category(inner_value__))
    })
    |> utils.add_optional(value__.url, fn(inner_value__) {
      #("url", json.string(inner_value__))
    })
    |> utils.add_optional(value__.line_number, fn(inner_value__) {
      #("lineNumber", json.int(inner_value__))
    })
    |> utils.add_optional(value__.stack_trace, fn(inner_value__) {
      #("stackTrace", runtime.encode__stack_trace(inner_value__))
    })
    |> utils.add_optional(value__.network_request_id, fn(inner_value__) {
      #("networkRequestId", network.encode__request_id(inner_value__))
    })
    |> utils.add_optional(value__.worker_id, fn(inner_value__) {
      #("workerId", json.string(inner_value__))
    })
    |> utils.add_optional(value__.args, fn(inner_value__) {
      #("args", json.array(inner_value__, of: runtime.encode__remote_object))
    }),
  )
}

@internal
pub fn decode__log_entry() {
  {
    use source <- decode.field("source", decode__log_entry_source())
    use level <- decode.field("level", decode__log_entry_level())
    use text <- decode.field("text", decode.string)
    use category <- decode.optional_field(
      "category",
      option.None,
      decode.optional(decode__log_entry_category()),
    )
    use timestamp <- decode.field("timestamp", runtime.decode__timestamp())
    use url <- decode.optional_field(
      "url",
      option.None,
      decode.optional(decode.string),
    )
    use line_number <- decode.optional_field(
      "lineNumber",
      option.None,
      decode.optional(decode.int),
    )
    use stack_trace <- decode.optional_field(
      "stackTrace",
      option.None,
      decode.optional(runtime.decode__stack_trace()),
    )
    use network_request_id <- decode.optional_field(
      "networkRequestId",
      option.None,
      decode.optional(network.decode__request_id()),
    )
    use worker_id <- decode.optional_field(
      "workerId",
      option.None,
      decode.optional(decode.string),
    )
    use args <- decode.optional_field(
      "args",
      option.None,
      decode.optional(decode.list(runtime.decode__remote_object())),
    )

    decode.success(LogEntry(
      source: source,
      level: level,
      text: text,
      category: category,
      timestamp: timestamp,
      url: url,
      line_number: line_number,
      stack_trace: stack_trace,
      network_request_id: network_request_id,
      worker_id: worker_id,
      args: args,
    ))
  }
}

/// Violation configuration setting.
pub type ViolationSetting {
  ViolationSetting(
    /// Violation type.  
    name: ViolationSettingName,
    /// Time threshold to trigger upon.  
    threshold: Float,
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `name` of `ViolationSetting`
pub type ViolationSettingName {
  ViolationSettingNameLongTask
  ViolationSettingNameLongLayout
  ViolationSettingNameBlockedEvent
  ViolationSettingNameBlockedParser
  ViolationSettingNameDiscouragedApiUse
  ViolationSettingNameHandler
  ViolationSettingNameRecurringHandler
}

@internal
pub fn encode__violation_setting_name(value__: ViolationSettingName) {
  case value__ {
    ViolationSettingNameLongTask -> "longTask"
    ViolationSettingNameLongLayout -> "longLayout"
    ViolationSettingNameBlockedEvent -> "blockedEvent"
    ViolationSettingNameBlockedParser -> "blockedParser"
    ViolationSettingNameDiscouragedApiUse -> "discouragedAPIUse"
    ViolationSettingNameHandler -> "handler"
    ViolationSettingNameRecurringHandler -> "recurringHandler"
  }
  |> json.string()
}

@internal
pub fn decode__violation_setting_name() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "longTask" -> decode.success(ViolationSettingNameLongTask)
      "longLayout" -> decode.success(ViolationSettingNameLongLayout)
      "blockedEvent" -> decode.success(ViolationSettingNameBlockedEvent)
      "blockedParser" -> decode.success(ViolationSettingNameBlockedParser)
      "discouragedAPIUse" ->
        decode.success(ViolationSettingNameDiscouragedApiUse)
      "handler" -> decode.success(ViolationSettingNameHandler)
      "recurringHandler" -> decode.success(ViolationSettingNameRecurringHandler)
      _ -> decode.failure(ViolationSettingNameLongTask, "valid enum property")
    }
  }
}

@internal
pub fn encode__violation_setting(value__: ViolationSetting) {
  json.object([
    #("name", encode__violation_setting_name(value__.name)),
    #("threshold", json.float(value__.threshold)),
  ])
}

@internal
pub fn decode__violation_setting() {
  {
    use name <- decode.field("name", decode__violation_setting_name())
    use threshold <- decode.field("threshold", decode.float)

    decode.success(ViolationSetting(name: name, threshold: threshold))
  }
}

/// Clears the log.
/// 
pub fn clear(callback__) {
  callback__("Log.clear", option.None)
}

/// Disables log domain, prevents further log entries from being reported to the client.
/// 
pub fn disable(callback__) {
  callback__("Log.disable", option.None)
}

/// Enables log domain, sends the entries collected so far to the client by means of the
/// `entryAdded` notification.
/// 
pub fn enable(callback__) {
  callback__("Log.enable", option.None)
}

/// start violation reporting.
/// 
/// Parameters:  
///  - `config` : Configuration for violations.
/// 
/// Returns:  
/// 
pub fn start_violations_report(
  callback__,
  config config: List(ViolationSetting),
) {
  callback__(
    "Log.startViolationsReport",
    option.Some(
      json.object([
        #("config", json.array(config, of: encode__violation_setting)),
      ]),
    ),
  )
}

/// Stop violation reporting.
/// 
pub fn stop_violations_report(callback__) {
  callback__("Log.stopViolationsReport", option.None)
}
