//// > ⚙️  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## DOMDebugger Domain  
////
//// DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
//// execution will stop on these operations as if there was a regular breakpoint set.  
////
//// [📖   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/DOMDebugger/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// |                     Run `codegen.sh` to regenerate.                     |
// ---------------------------------------------------------------------------

import chrobot/chrome
import chrobot/internal/utils
import chrobot/protocol/dom
import chrobot/protocol/runtime
import gleam/dynamic
import gleam/json
import gleam/option
import gleam/result

/// DOM breakpoint type.
pub type DOMBreakpointType {
  DOMBreakpointTypeSubtreeModified
  DOMBreakpointTypeAttributeModified
  DOMBreakpointTypeNodeRemoved
}

@internal
pub fn encode__dom_breakpoint_type(value__: DOMBreakpointType) {
  case value__ {
    DOMBreakpointTypeSubtreeModified -> "subtree-modified"
    DOMBreakpointTypeAttributeModified -> "attribute-modified"
    DOMBreakpointTypeNodeRemoved -> "node-removed"
  }
  |> json.string()
}

@internal
pub fn decode__dom_breakpoint_type(value__: dynamic.Dynamic) {
  case dynamic.string(value__) {
    Ok("subtree-modified") -> Ok(DOMBreakpointTypeSubtreeModified)
    Ok("attribute-modified") -> Ok(DOMBreakpointTypeAttributeModified)
    Ok("node-removed") -> Ok(DOMBreakpointTypeNodeRemoved)
    Error(error) -> Error(error)
    Ok(other) ->
      Error([
        dynamic.DecodeError(
          expected: "valid enum property",
          found: other,
          path: ["enum decoder"],
        ),
      ])
  }
}

/// Object event listener.
pub type EventListener {
  EventListener(
    /// `EventListener`'s type.  
    type_: String,
    /// `EventListener`'s useCapture.  
    use_capture: Bool,
    /// `EventListener`'s passive flag.  
    passive: Bool,
    /// `EventListener`'s once flag.  
    once: Bool,
    /// Script id of the handler code.  
    script_id: runtime.ScriptId,
    /// Line number in the script (0-based).  
    line_number: Int,
    /// Column number in the script (0-based).  
    column_number: Int,
    /// Event handler function value.  
    handler: option.Option(runtime.RemoteObject),
    /// Event original handler function value.  
    original_handler: option.Option(runtime.RemoteObject),
    /// Node the listener is added to (if any).  
    backend_node_id: option.Option(dom.BackendNodeId),
  )
}

@internal
pub fn encode__event_listener(value__: EventListener) {
  json.object(
    [
      #("type", json.string(value__.type_)),
      #("useCapture", json.bool(value__.use_capture)),
      #("passive", json.bool(value__.passive)),
      #("once", json.bool(value__.once)),
      #("scriptId", runtime.encode__script_id(value__.script_id)),
      #("lineNumber", json.int(value__.line_number)),
      #("columnNumber", json.int(value__.column_number)),
    ]
    |> utils.add_optional(value__.handler, fn(inner_value__) {
      #("handler", runtime.encode__remote_object(inner_value__))
    })
    |> utils.add_optional(value__.original_handler, fn(inner_value__) {
      #("originalHandler", runtime.encode__remote_object(inner_value__))
    })
    |> utils.add_optional(value__.backend_node_id, fn(inner_value__) {
      #("backendNodeId", dom.encode__backend_node_id(inner_value__))
    }),
  )
}

@internal
pub fn decode__event_listener(value__: dynamic.Dynamic) {
  use type_ <- result.try(dynamic.field("type", dynamic.string)(value__))
  use use_capture <- result.try(dynamic.field("useCapture", dynamic.bool)(
    value__,
  ))
  use passive <- result.try(dynamic.field("passive", dynamic.bool)(value__))
  use once <- result.try(dynamic.field("once", dynamic.bool)(value__))
  use script_id <- result.try(dynamic.field(
    "scriptId",
    runtime.decode__script_id,
  )(value__))
  use line_number <- result.try(dynamic.field("lineNumber", dynamic.int)(
    value__,
  ))
  use column_number <- result.try(dynamic.field("columnNumber", dynamic.int)(
    value__,
  ))
  use handler <- result.try(dynamic.optional_field(
    "handler",
    runtime.decode__remote_object,
  )(value__))
  use original_handler <- result.try(dynamic.optional_field(
    "originalHandler",
    runtime.decode__remote_object,
  )(value__))
  use backend_node_id <- result.try(dynamic.optional_field(
    "backendNodeId",
    dom.decode__backend_node_id,
  )(value__))

  Ok(EventListener(
    type_: type_,
    use_capture: use_capture,
    passive: passive,
    once: once,
    script_id: script_id,
    line_number: line_number,
    column_number: column_number,
    handler: handler,
    original_handler: original_handler,
    backend_node_id: backend_node_id,
  ))
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_event_listeners`
pub type GetEventListenersResponse {
  GetEventListenersResponse(
    /// Array of relevant listeners.  
    listeners: List(EventListener),
  )
}

@internal
pub fn decode__get_event_listeners_response(value__: dynamic.Dynamic) {
  use listeners <- result.try(dynamic.field(
    "listeners",
    dynamic.list(decode__event_listener),
  )(value__))

  Ok(GetEventListenersResponse(listeners: listeners))
}

/// Returns event listeners of the given object.
/// 
/// Parameters:  
///  - `object_id` : Identifier of the object to return listeners for.
///  - `depth` : The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the
/// entire subtree or provide an integer larger than 0.
///  - `pierce` : Whether or not iframes and shadow roots should be traversed when returning the subtree
/// (default is false). Reports listeners for all contexts if pierce is enabled.
/// 
/// Returns:  
///  - `listeners` : Array of relevant listeners.
/// 
pub fn get_event_listeners(
  callback__,
  object_id object_id: runtime.RemoteObjectId,
  depth depth: option.Option(Int),
  pierce pierce: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "DOMDebugger.getEventListeners",
    option.Some(json.object(
      [#("objectId", runtime.encode__remote_object_id(object_id))]
      |> utils.add_optional(depth, fn(inner_value__) {
        #("depth", json.int(inner_value__))
      })
      |> utils.add_optional(pierce, fn(inner_value__) {
        #("pierce", json.bool(inner_value__))
      }),
    )),
  ))

  decode__get_event_listeners_response(result__)
  |> result.replace_error(chrome.ProtocolError)
}

/// Removes DOM breakpoint that was set using `setDOMBreakpoint`.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node to remove breakpoint from.
///  - `type_` : Type of the breakpoint to remove.
/// 
/// Returns:  
/// 
pub fn remove_dom_breakpoint(
  callback__,
  node_id node_id: dom.NodeId,
  type_ type_: DOMBreakpointType,
) {
  callback__(
    "DOMDebugger.removeDOMBreakpoint",
    option.Some(
      json.object([
        #("nodeId", dom.encode__node_id(node_id)),
        #("type", encode__dom_breakpoint_type(type_)),
      ]),
    ),
  )
}

/// Removes breakpoint on particular DOM event.
/// 
/// Parameters:  
///  - `event_name` : Event name.
/// 
/// Returns:  
/// 
pub fn remove_event_listener_breakpoint(
  callback__,
  event_name event_name: String,
) {
  callback__(
    "DOMDebugger.removeEventListenerBreakpoint",
    option.Some(json.object([#("eventName", json.string(event_name))])),
  )
}

/// Removes breakpoint from XMLHttpRequest.
/// 
/// Parameters:  
///  - `url` : Resource URL substring.
/// 
/// Returns:  
/// 
pub fn remove_xhr_breakpoint(callback__, url url: String) {
  callback__(
    "DOMDebugger.removeXHRBreakpoint",
    option.Some(json.object([#("url", json.string(url))])),
  )
}

/// Sets breakpoint on particular operation with DOM.
/// 
/// Parameters:  
///  - `node_id` : Identifier of the node to set breakpoint on.
///  - `type_` : Type of the operation to stop upon.
/// 
/// Returns:  
/// 
pub fn set_dom_breakpoint(
  callback__,
  node_id node_id: dom.NodeId,
  type_ type_: DOMBreakpointType,
) {
  callback__(
    "DOMDebugger.setDOMBreakpoint",
    option.Some(
      json.object([
        #("nodeId", dom.encode__node_id(node_id)),
        #("type", encode__dom_breakpoint_type(type_)),
      ]),
    ),
  )
}

/// Sets breakpoint on particular DOM event.
/// 
/// Parameters:  
///  - `event_name` : DOM Event name to stop on (any DOM event will do).
/// 
/// Returns:  
/// 
pub fn set_event_listener_breakpoint(callback__, event_name event_name: String) {
  callback__(
    "DOMDebugger.setEventListenerBreakpoint",
    option.Some(json.object([#("eventName", json.string(event_name))])),
  )
}

/// Sets breakpoint on XMLHttpRequest.
/// 
/// Parameters:  
///  - `url` : Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
/// 
/// Returns:  
/// 
pub fn set_xhr_breakpoint(callback__, url url: String) {
  callback__(
    "DOMDebugger.setXHRBreakpoint",
    option.Some(json.object([#("url", json.string(url))])),
  )
}
