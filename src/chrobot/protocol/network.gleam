//// > âš™ï¸  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Network Domain  
////
//// Network domain allows tracking network activities of the page. It exposes information about http,
//// file, data and other requests and responses, their headers, bodies, timing, etc.  
////
//// [ðŸ“–   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Network/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// |                     Run `codegen.sh` to regenerate.                     |
// ---------------------------------------------------------------------------

import chrobot/chrome
import chrobot/internal/utils
import chrobot/protocol/runtime
import chrobot/protocol/security
import gleam/dict
import gleam/dynamic/decode
import gleam/json
import gleam/list
import gleam/option
import gleam/result

/// Resource type as it was perceived by the rendering engine.
pub type ResourceType {
  ResourceTypeDocument
  ResourceTypeStylesheet
  ResourceTypeImage
  ResourceTypeMedia
  ResourceTypeFont
  ResourceTypeScript
  ResourceTypeTextTrack
  ResourceTypeXhr
  ResourceTypeFetch
  ResourceTypePrefetch
  ResourceTypeEventSource
  ResourceTypeWebSocket
  ResourceTypeManifest
  ResourceTypeSignedExchange
  ResourceTypePing
  ResourceTypeCspViolationReport
  ResourceTypePreflight
  ResourceTypeOther
}

@internal
pub fn encode__resource_type(value__: ResourceType) {
  case value__ {
    ResourceTypeDocument -> "Document"
    ResourceTypeStylesheet -> "Stylesheet"
    ResourceTypeImage -> "Image"
    ResourceTypeMedia -> "Media"
    ResourceTypeFont -> "Font"
    ResourceTypeScript -> "Script"
    ResourceTypeTextTrack -> "TextTrack"
    ResourceTypeXhr -> "XHR"
    ResourceTypeFetch -> "Fetch"
    ResourceTypePrefetch -> "Prefetch"
    ResourceTypeEventSource -> "EventSource"
    ResourceTypeWebSocket -> "WebSocket"
    ResourceTypeManifest -> "Manifest"
    ResourceTypeSignedExchange -> "SignedExchange"
    ResourceTypePing -> "Ping"
    ResourceTypeCspViolationReport -> "CSPViolationReport"
    ResourceTypePreflight -> "Preflight"
    ResourceTypeOther -> "Other"
  }
  |> json.string()
}

@internal
pub fn decode__resource_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "Document" -> decode.success(ResourceTypeDocument)
      "Stylesheet" -> decode.success(ResourceTypeStylesheet)
      "Image" -> decode.success(ResourceTypeImage)
      "Media" -> decode.success(ResourceTypeMedia)
      "Font" -> decode.success(ResourceTypeFont)
      "Script" -> decode.success(ResourceTypeScript)
      "TextTrack" -> decode.success(ResourceTypeTextTrack)
      "XHR" -> decode.success(ResourceTypeXhr)
      "Fetch" -> decode.success(ResourceTypeFetch)
      "Prefetch" -> decode.success(ResourceTypePrefetch)
      "EventSource" -> decode.success(ResourceTypeEventSource)
      "WebSocket" -> decode.success(ResourceTypeWebSocket)
      "Manifest" -> decode.success(ResourceTypeManifest)
      "SignedExchange" -> decode.success(ResourceTypeSignedExchange)
      "Ping" -> decode.success(ResourceTypePing)
      "CSPViolationReport" -> decode.success(ResourceTypeCspViolationReport)
      "Preflight" -> decode.success(ResourceTypePreflight)
      "Other" -> decode.success(ResourceTypeOther)
      _ -> decode.failure(ResourceTypeDocument, "valid enum property")
    }
  }
}

/// Unique loader identifier.
pub type LoaderId {
  LoaderId(String)
}

@internal
pub fn encode__loader_id(value__: LoaderId) {
  case value__ {
    LoaderId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__loader_id() {
  {
    use value__ <- decode.then(decode.string)
    decode.success(LoaderId(value__))
  }
}

/// Unique request identifier.
pub type RequestId {
  RequestId(String)
}

@internal
pub fn encode__request_id(value__: RequestId) {
  case value__ {
    RequestId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__request_id() {
  {
    use value__ <- decode.then(decode.string)
    decode.success(RequestId(value__))
  }
}

/// Unique intercepted request identifier.
pub type InterceptionId {
  InterceptionId(String)
}

@internal
pub fn encode__interception_id(value__: InterceptionId) {
  case value__ {
    InterceptionId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__interception_id() {
  {
    use value__ <- decode.then(decode.string)
    decode.success(InterceptionId(value__))
  }
}

/// Network level fetch failure reason.
pub type ErrorReason {
  ErrorReasonFailed
  ErrorReasonAborted
  ErrorReasonTimedOut
  ErrorReasonAccessDenied
  ErrorReasonConnectionClosed
  ErrorReasonConnectionReset
  ErrorReasonConnectionRefused
  ErrorReasonConnectionAborted
  ErrorReasonConnectionFailed
  ErrorReasonNameNotResolved
  ErrorReasonInternetDisconnected
  ErrorReasonAddressUnreachable
  ErrorReasonBlockedByClient
  ErrorReasonBlockedByResponse
}

@internal
pub fn encode__error_reason(value__: ErrorReason) {
  case value__ {
    ErrorReasonFailed -> "Failed"
    ErrorReasonAborted -> "Aborted"
    ErrorReasonTimedOut -> "TimedOut"
    ErrorReasonAccessDenied -> "AccessDenied"
    ErrorReasonConnectionClosed -> "ConnectionClosed"
    ErrorReasonConnectionReset -> "ConnectionReset"
    ErrorReasonConnectionRefused -> "ConnectionRefused"
    ErrorReasonConnectionAborted -> "ConnectionAborted"
    ErrorReasonConnectionFailed -> "ConnectionFailed"
    ErrorReasonNameNotResolved -> "NameNotResolved"
    ErrorReasonInternetDisconnected -> "InternetDisconnected"
    ErrorReasonAddressUnreachable -> "AddressUnreachable"
    ErrorReasonBlockedByClient -> "BlockedByClient"
    ErrorReasonBlockedByResponse -> "BlockedByResponse"
  }
  |> json.string()
}

@internal
pub fn decode__error_reason() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "Failed" -> decode.success(ErrorReasonFailed)
      "Aborted" -> decode.success(ErrorReasonAborted)
      "TimedOut" -> decode.success(ErrorReasonTimedOut)
      "AccessDenied" -> decode.success(ErrorReasonAccessDenied)
      "ConnectionClosed" -> decode.success(ErrorReasonConnectionClosed)
      "ConnectionReset" -> decode.success(ErrorReasonConnectionReset)
      "ConnectionRefused" -> decode.success(ErrorReasonConnectionRefused)
      "ConnectionAborted" -> decode.success(ErrorReasonConnectionAborted)
      "ConnectionFailed" -> decode.success(ErrorReasonConnectionFailed)
      "NameNotResolved" -> decode.success(ErrorReasonNameNotResolved)
      "InternetDisconnected" -> decode.success(ErrorReasonInternetDisconnected)
      "AddressUnreachable" -> decode.success(ErrorReasonAddressUnreachable)
      "BlockedByClient" -> decode.success(ErrorReasonBlockedByClient)
      "BlockedByResponse" -> decode.success(ErrorReasonBlockedByResponse)
      _ -> decode.failure(ErrorReasonFailed, "valid enum property")
    }
  }
}

/// UTC time in seconds, counted from January 1, 1970.
pub type TimeSinceEpoch {
  TimeSinceEpoch(Float)
}

@internal
pub fn encode__time_since_epoch(value__: TimeSinceEpoch) {
  case value__ {
    TimeSinceEpoch(inner_value__) -> json.float(inner_value__)
  }
}

@internal
pub fn decode__time_since_epoch() {
  {
    use value__ <- decode.then(decode.float)
    decode.success(TimeSinceEpoch(value__))
  }
}

/// Monotonically increasing time in seconds since an arbitrary point in the past.
pub type MonotonicTime {
  MonotonicTime(Float)
}

@internal
pub fn encode__monotonic_time(value__: MonotonicTime) {
  case value__ {
    MonotonicTime(inner_value__) -> json.float(inner_value__)
  }
}

@internal
pub fn decode__monotonic_time() {
  {
    use value__ <- decode.then(decode.float)
    decode.success(MonotonicTime(value__))
  }
}

/// Request / response headers as keys / values of JSON object.
pub type Headers {
  Headers(dict.Dict(String, String))
}

@internal
pub fn encode__headers(value__: Headers) {
  case value__ {
    Headers(inner_value__) ->
      dict.to_list(inner_value__)
      |> list.map(fn(i) { #(i.0, json.string(i.1)) })
      |> json.object
  }
}

@internal
pub fn decode__headers() {
  {
    use value__ <- decode.then(decode.dict(decode.string, decode.string))
    decode.success(Headers(value__))
  }
}

/// The underlying connection technology that the browser is supposedly using.
pub type ConnectionType {
  ConnectionTypeNone
  ConnectionTypeCellular2g
  ConnectionTypeCellular3g
  ConnectionTypeCellular4g
  ConnectionTypeBluetooth
  ConnectionTypeEthernet
  ConnectionTypeWifi
  ConnectionTypeWimax
  ConnectionTypeOther
}

@internal
pub fn encode__connection_type(value__: ConnectionType) {
  case value__ {
    ConnectionTypeNone -> "none"
    ConnectionTypeCellular2g -> "cellular2g"
    ConnectionTypeCellular3g -> "cellular3g"
    ConnectionTypeCellular4g -> "cellular4g"
    ConnectionTypeBluetooth -> "bluetooth"
    ConnectionTypeEthernet -> "ethernet"
    ConnectionTypeWifi -> "wifi"
    ConnectionTypeWimax -> "wimax"
    ConnectionTypeOther -> "other"
  }
  |> json.string()
}

@internal
pub fn decode__connection_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "none" -> decode.success(ConnectionTypeNone)
      "cellular2g" -> decode.success(ConnectionTypeCellular2g)
      "cellular3g" -> decode.success(ConnectionTypeCellular3g)
      "cellular4g" -> decode.success(ConnectionTypeCellular4g)
      "bluetooth" -> decode.success(ConnectionTypeBluetooth)
      "ethernet" -> decode.success(ConnectionTypeEthernet)
      "wifi" -> decode.success(ConnectionTypeWifi)
      "wimax" -> decode.success(ConnectionTypeWimax)
      "other" -> decode.success(ConnectionTypeOther)
      _ -> decode.failure(ConnectionTypeNone, "valid enum property")
    }
  }
}

/// Represents the cookie's 'SameSite' status:
/// https://tools.ietf.org/html/draft-west-first-party-cookies
pub type CookieSameSite {
  CookieSameSiteStrict
  CookieSameSiteLax
  CookieSameSiteNone
}

@internal
pub fn encode__cookie_same_site(value__: CookieSameSite) {
  case value__ {
    CookieSameSiteStrict -> "Strict"
    CookieSameSiteLax -> "Lax"
    CookieSameSiteNone -> "None"
  }
  |> json.string()
}

@internal
pub fn decode__cookie_same_site() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "Strict" -> decode.success(CookieSameSiteStrict)
      "Lax" -> decode.success(CookieSameSiteLax)
      "None" -> decode.success(CookieSameSiteNone)
      _ -> decode.failure(CookieSameSiteStrict, "valid enum property")
    }
  }
}

/// Timing information for the request.
pub type ResourceTiming {
  ResourceTiming(
    /// Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
    /// milliseconds relatively to this requestTime.  
    request_time: Float,
    /// Started resolving proxy.  
    proxy_start: Float,
    /// Finished resolving proxy.  
    proxy_end: Float,
    /// Started DNS address resolve.  
    dns_start: Float,
    /// Finished DNS address resolve.  
    dns_end: Float,
    /// Started connecting to the remote host.  
    connect_start: Float,
    /// Connected to the remote host.  
    connect_end: Float,
    /// Started SSL handshake.  
    ssl_start: Float,
    /// Finished SSL handshake.  
    ssl_end: Float,
    /// Started sending request.  
    send_start: Float,
    /// Finished sending request.  
    send_end: Float,
    /// Finished receiving response headers.  
    receive_headers_end: Float,
  )
}

@internal
pub fn encode__resource_timing(value__: ResourceTiming) {
  json.object([
    #("requestTime", json.float(value__.request_time)),
    #("proxyStart", json.float(value__.proxy_start)),
    #("proxyEnd", json.float(value__.proxy_end)),
    #("dnsStart", json.float(value__.dns_start)),
    #("dnsEnd", json.float(value__.dns_end)),
    #("connectStart", json.float(value__.connect_start)),
    #("connectEnd", json.float(value__.connect_end)),
    #("sslStart", json.float(value__.ssl_start)),
    #("sslEnd", json.float(value__.ssl_end)),
    #("sendStart", json.float(value__.send_start)),
    #("sendEnd", json.float(value__.send_end)),
    #("receiveHeadersEnd", json.float(value__.receive_headers_end)),
  ])
}

@internal
pub fn decode__resource_timing() {
  {
    use request_time <- decode.field("requestTime", decode.float)
    use proxy_start <- decode.field("proxyStart", decode.float)
    use proxy_end <- decode.field("proxyEnd", decode.float)
    use dns_start <- decode.field("dnsStart", decode.float)
    use dns_end <- decode.field("dnsEnd", decode.float)
    use connect_start <- decode.field("connectStart", decode.float)
    use connect_end <- decode.field("connectEnd", decode.float)
    use ssl_start <- decode.field("sslStart", decode.float)
    use ssl_end <- decode.field("sslEnd", decode.float)
    use send_start <- decode.field("sendStart", decode.float)
    use send_end <- decode.field("sendEnd", decode.float)
    use receive_headers_end <- decode.field("receiveHeadersEnd", decode.float)

    decode.success(ResourceTiming(
      request_time: request_time,
      proxy_start: proxy_start,
      proxy_end: proxy_end,
      dns_start: dns_start,
      dns_end: dns_end,
      connect_start: connect_start,
      connect_end: connect_end,
      ssl_start: ssl_start,
      ssl_end: ssl_end,
      send_start: send_start,
      send_end: send_end,
      receive_headers_end: receive_headers_end,
    ))
  }
}

/// Loading priority of a resource request.
pub type ResourcePriority {
  ResourcePriorityVeryLow
  ResourcePriorityLow
  ResourcePriorityMedium
  ResourcePriorityHigh
  ResourcePriorityVeryHigh
}

@internal
pub fn encode__resource_priority(value__: ResourcePriority) {
  case value__ {
    ResourcePriorityVeryLow -> "VeryLow"
    ResourcePriorityLow -> "Low"
    ResourcePriorityMedium -> "Medium"
    ResourcePriorityHigh -> "High"
    ResourcePriorityVeryHigh -> "VeryHigh"
  }
  |> json.string()
}

@internal
pub fn decode__resource_priority() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "VeryLow" -> decode.success(ResourcePriorityVeryLow)
      "Low" -> decode.success(ResourcePriorityLow)
      "Medium" -> decode.success(ResourcePriorityMedium)
      "High" -> decode.success(ResourcePriorityHigh)
      "VeryHigh" -> decode.success(ResourcePriorityVeryHigh)
      _ -> decode.failure(ResourcePriorityVeryLow, "valid enum property")
    }
  }
}

/// Post data entry for HTTP request
pub type PostDataEntry {
  PostDataEntry(bytes: option.Option(String))
}

@internal
pub fn encode__post_data_entry(value__: PostDataEntry) {
  json.object(
    []
    |> utils.add_optional(value__.bytes, fn(inner_value__) {
      #("bytes", json.string(inner_value__))
    }),
  )
}

@internal
pub fn decode__post_data_entry() {
  {
    use bytes <- decode.optional_field(
      "bytes",
      option.None,
      decode.optional(decode.string),
    )

    decode.success(PostDataEntry(bytes: bytes))
  }
}

/// HTTP request data.
pub type Request {
  Request(
    /// Request URL (without fragment).  
    url: String,
    /// Fragment of the requested URL starting with hash, if present.  
    url_fragment: option.Option(String),
    /// HTTP request method.  
    method: String,
    /// HTTP request headers.  
    headers: Headers,
    /// True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.  
    has_post_data: option.Option(Bool),
    /// The mixed content type of the request.  
    mixed_content_type: option.Option(security.MixedContentType),
    /// Priority of the resource request at the time request is sent.  
    initial_priority: ResourcePriority,
    /// The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/  
    referrer_policy: RequestReferrerPolicy,
    /// Whether is loaded via link preload.  
    is_link_preload: option.Option(Bool),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `referrerPolicy` of `Request`
pub type RequestReferrerPolicy {
  RequestReferrerPolicyUnsafeUrl
  RequestReferrerPolicyNoReferrerWhenDowngrade
  RequestReferrerPolicyNoReferrer
  RequestReferrerPolicyOrigin
  RequestReferrerPolicyOriginWhenCrossOrigin
  RequestReferrerPolicySameOrigin
  RequestReferrerPolicyStrictOrigin
  RequestReferrerPolicyStrictOriginWhenCrossOrigin
}

@internal
pub fn encode__request_referrer_policy(value__: RequestReferrerPolicy) {
  case value__ {
    RequestReferrerPolicyUnsafeUrl -> "unsafe-url"
    RequestReferrerPolicyNoReferrerWhenDowngrade -> "no-referrer-when-downgrade"
    RequestReferrerPolicyNoReferrer -> "no-referrer"
    RequestReferrerPolicyOrigin -> "origin"
    RequestReferrerPolicyOriginWhenCrossOrigin -> "origin-when-cross-origin"
    RequestReferrerPolicySameOrigin -> "same-origin"
    RequestReferrerPolicyStrictOrigin -> "strict-origin"
    RequestReferrerPolicyStrictOriginWhenCrossOrigin ->
      "strict-origin-when-cross-origin"
  }
  |> json.string()
}

@internal
pub fn decode__request_referrer_policy() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "unsafe-url" -> decode.success(RequestReferrerPolicyUnsafeUrl)
      "no-referrer-when-downgrade" ->
        decode.success(RequestReferrerPolicyNoReferrerWhenDowngrade)
      "no-referrer" -> decode.success(RequestReferrerPolicyNoReferrer)
      "origin" -> decode.success(RequestReferrerPolicyOrigin)
      "origin-when-cross-origin" ->
        decode.success(RequestReferrerPolicyOriginWhenCrossOrigin)
      "same-origin" -> decode.success(RequestReferrerPolicySameOrigin)
      "strict-origin" -> decode.success(RequestReferrerPolicyStrictOrigin)
      "strict-origin-when-cross-origin" ->
        decode.success(RequestReferrerPolicyStrictOriginWhenCrossOrigin)
      _ -> decode.failure(RequestReferrerPolicyUnsafeUrl, "valid enum property")
    }
  }
}

@internal
pub fn encode__request(value__: Request) {
  json.object(
    [
      #("url", json.string(value__.url)),
      #("method", json.string(value__.method)),
      #("headers", encode__headers(value__.headers)),
      #("initialPriority", encode__resource_priority(value__.initial_priority)),
      #(
        "referrerPolicy",
        encode__request_referrer_policy(value__.referrer_policy),
      ),
    ]
    |> utils.add_optional(value__.url_fragment, fn(inner_value__) {
      #("urlFragment", json.string(inner_value__))
    })
    |> utils.add_optional(value__.has_post_data, fn(inner_value__) {
      #("hasPostData", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.mixed_content_type, fn(inner_value__) {
      #("mixedContentType", security.encode__mixed_content_type(inner_value__))
    })
    |> utils.add_optional(value__.is_link_preload, fn(inner_value__) {
      #("isLinkPreload", json.bool(inner_value__))
    }),
  )
}

@internal
pub fn decode__request() {
  {
    use url <- decode.field("url", decode.string)
    use url_fragment <- decode.optional_field(
      "urlFragment",
      option.None,
      decode.optional(decode.string),
    )
    use method <- decode.field("method", decode.string)
    use headers <- decode.field("headers", decode__headers())
    use has_post_data <- decode.optional_field(
      "hasPostData",
      option.None,
      decode.optional(decode.bool),
    )
    use mixed_content_type <- decode.optional_field(
      "mixedContentType",
      option.None,
      decode.optional(security.decode__mixed_content_type()),
    )
    use initial_priority <- decode.field(
      "initialPriority",
      decode__resource_priority(),
    )
    use referrer_policy <- decode.field(
      "referrerPolicy",
      decode__request_referrer_policy(),
    )
    use is_link_preload <- decode.optional_field(
      "isLinkPreload",
      option.None,
      decode.optional(decode.bool),
    )

    decode.success(Request(
      url: url,
      url_fragment: url_fragment,
      method: method,
      headers: headers,
      has_post_data: has_post_data,
      mixed_content_type: mixed_content_type,
      initial_priority: initial_priority,
      referrer_policy: referrer_policy,
      is_link_preload: is_link_preload,
    ))
  }
}

/// Details of a signed certificate timestamp (SCT).
pub type SignedCertificateTimestamp {
  SignedCertificateTimestamp(
    /// Validation status.  
    status: String,
    /// Origin.  
    origin: String,
    /// Log name / description.  
    log_description: String,
    /// Log ID.  
    log_id: String,
    /// Issuance date. Unlike TimeSinceEpoch, this contains the number of
    /// milliseconds since January 1, 1970, UTC, not the number of seconds.  
    timestamp: Float,
    /// Hash algorithm.  
    hash_algorithm: String,
    /// Signature algorithm.  
    signature_algorithm: String,
    /// Signature data.  
    signature_data: String,
  )
}

@internal
pub fn encode__signed_certificate_timestamp(value__: SignedCertificateTimestamp) {
  json.object([
    #("status", json.string(value__.status)),
    #("origin", json.string(value__.origin)),
    #("logDescription", json.string(value__.log_description)),
    #("logId", json.string(value__.log_id)),
    #("timestamp", json.float(value__.timestamp)),
    #("hashAlgorithm", json.string(value__.hash_algorithm)),
    #("signatureAlgorithm", json.string(value__.signature_algorithm)),
    #("signatureData", json.string(value__.signature_data)),
  ])
}

@internal
pub fn decode__signed_certificate_timestamp() {
  {
    use status <- decode.field("status", decode.string)
    use origin <- decode.field("origin", decode.string)
    use log_description <- decode.field("logDescription", decode.string)
    use log_id <- decode.field("logId", decode.string)
    use timestamp <- decode.field("timestamp", decode.float)
    use hash_algorithm <- decode.field("hashAlgorithm", decode.string)
    use signature_algorithm <- decode.field("signatureAlgorithm", decode.string)
    use signature_data <- decode.field("signatureData", decode.string)

    decode.success(SignedCertificateTimestamp(
      status: status,
      origin: origin,
      log_description: log_description,
      log_id: log_id,
      timestamp: timestamp,
      hash_algorithm: hash_algorithm,
      signature_algorithm: signature_algorithm,
      signature_data: signature_data,
    ))
  }
}

/// Security details about a request.
pub type SecurityDetails {
  SecurityDetails(
    /// Protocol name (e.g. "TLS 1.2" or "QUIC").  
    protocol: String,
    /// Key Exchange used by the connection, or the empty string if not applicable.  
    key_exchange: String,
    /// (EC)DH group used by the connection, if applicable.  
    key_exchange_group: option.Option(String),
    /// Cipher name.  
    cipher: String,
    /// TLS MAC. Note that AEAD ciphers do not have separate MACs.  
    mac: option.Option(String),
    /// Certificate ID value.  
    certificate_id: security.CertificateId,
    /// Certificate subject name.  
    subject_name: String,
    /// Subject Alternative Name (SAN) DNS names and IP addresses.  
    san_list: List(String),
    /// Name of the issuing CA.  
    issuer: String,
    /// Certificate valid from date.  
    valid_from: TimeSinceEpoch,
    /// Certificate valid to (expiration) date  
    valid_to: TimeSinceEpoch,
    /// List of signed certificate timestamps (SCTs).  
    signed_certificate_timestamp_list: List(SignedCertificateTimestamp),
    /// Whether the request complied with Certificate Transparency policy  
    certificate_transparency_compliance: CertificateTransparencyCompliance,
    /// The signature algorithm used by the server in the TLS server signature,
    /// represented as a TLS SignatureScheme code point. Omitted if not
    /// applicable or not known.  
    server_signature_algorithm: option.Option(Int),
    /// Whether the connection used Encrypted ClientHello  
    encrypted_client_hello: Bool,
  )
}

@internal
pub fn encode__security_details(value__: SecurityDetails) {
  json.object(
    [
      #("protocol", json.string(value__.protocol)),
      #("keyExchange", json.string(value__.key_exchange)),
      #("cipher", json.string(value__.cipher)),
      #(
        "certificateId",
        security.encode__certificate_id(value__.certificate_id),
      ),
      #("subjectName", json.string(value__.subject_name)),
      #("sanList", json.array(value__.san_list, of: json.string)),
      #("issuer", json.string(value__.issuer)),
      #("validFrom", encode__time_since_epoch(value__.valid_from)),
      #("validTo", encode__time_since_epoch(value__.valid_to)),
      #(
        "signedCertificateTimestampList",
        json.array(
          value__.signed_certificate_timestamp_list,
          of: encode__signed_certificate_timestamp,
        ),
      ),
      #(
        "certificateTransparencyCompliance",
        encode__certificate_transparency_compliance(
          value__.certificate_transparency_compliance,
        ),
      ),
      #("encryptedClientHello", json.bool(value__.encrypted_client_hello)),
    ]
    |> utils.add_optional(value__.key_exchange_group, fn(inner_value__) {
      #("keyExchangeGroup", json.string(inner_value__))
    })
    |> utils.add_optional(value__.mac, fn(inner_value__) {
      #("mac", json.string(inner_value__))
    })
    |> utils.add_optional(value__.server_signature_algorithm, fn(inner_value__) {
      #("serverSignatureAlgorithm", json.int(inner_value__))
    }),
  )
}

@internal
pub fn decode__security_details() {
  {
    use protocol <- decode.field("protocol", decode.string)
    use key_exchange <- decode.field("keyExchange", decode.string)
    use key_exchange_group <- decode.optional_field(
      "keyExchangeGroup",
      option.None,
      decode.optional(decode.string),
    )
    use cipher <- decode.field("cipher", decode.string)
    use mac <- decode.optional_field(
      "mac",
      option.None,
      decode.optional(decode.string),
    )
    use certificate_id <- decode.field(
      "certificateId",
      security.decode__certificate_id(),
    )
    use subject_name <- decode.field("subjectName", decode.string)
    use san_list <- decode.field("sanList", decode.list(decode.string))
    use issuer <- decode.field("issuer", decode.string)
    use valid_from <- decode.field("validFrom", decode__time_since_epoch())
    use valid_to <- decode.field("validTo", decode__time_since_epoch())
    use signed_certificate_timestamp_list <- decode.field(
      "signedCertificateTimestampList",
      decode.list(decode__signed_certificate_timestamp()),
    )
    use certificate_transparency_compliance <- decode.field(
      "certificateTransparencyCompliance",
      decode__certificate_transparency_compliance(),
    )
    use server_signature_algorithm <- decode.optional_field(
      "serverSignatureAlgorithm",
      option.None,
      decode.optional(decode.int),
    )
    use encrypted_client_hello <- decode.field(
      "encryptedClientHello",
      decode.bool,
    )

    decode.success(SecurityDetails(
      protocol: protocol,
      key_exchange: key_exchange,
      key_exchange_group: key_exchange_group,
      cipher: cipher,
      mac: mac,
      certificate_id: certificate_id,
      subject_name: subject_name,
      san_list: san_list,
      issuer: issuer,
      valid_from: valid_from,
      valid_to: valid_to,
      signed_certificate_timestamp_list: signed_certificate_timestamp_list,
      certificate_transparency_compliance: certificate_transparency_compliance,
      server_signature_algorithm: server_signature_algorithm,
      encrypted_client_hello: encrypted_client_hello,
    ))
  }
}

/// Whether the request complied with Certificate Transparency policy.
pub type CertificateTransparencyCompliance {
  CertificateTransparencyComplianceUnknown
  CertificateTransparencyComplianceNotCompliant
  CertificateTransparencyComplianceCompliant
}

@internal
pub fn encode__certificate_transparency_compliance(
  value__: CertificateTransparencyCompliance,
) {
  case value__ {
    CertificateTransparencyComplianceUnknown -> "unknown"
    CertificateTransparencyComplianceNotCompliant -> "not-compliant"
    CertificateTransparencyComplianceCompliant -> "compliant"
  }
  |> json.string()
}

@internal
pub fn decode__certificate_transparency_compliance() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "unknown" -> decode.success(CertificateTransparencyComplianceUnknown)
      "not-compliant" ->
        decode.success(CertificateTransparencyComplianceNotCompliant)
      "compliant" -> decode.success(CertificateTransparencyComplianceCompliant)
      _ ->
        decode.failure(
          CertificateTransparencyComplianceUnknown,
          "valid enum property",
        )
    }
  }
}

/// The reason why request was blocked.
pub type BlockedReason {
  BlockedReasonOther
  BlockedReasonCsp
  BlockedReasonMixedContent
  BlockedReasonOrigin
  BlockedReasonInspector
  BlockedReasonSubresourceFilter
  BlockedReasonContentType
  BlockedReasonCoepFrameResourceNeedsCoepHeader
  BlockedReasonCoopSandboxedIframeCannotNavigateToCoopPage
  BlockedReasonCorpNotSameOrigin
  BlockedReasonCorpNotSameOriginAfterDefaultedToSameOriginByCoep
  BlockedReasonCorpNotSameSite
}

@internal
pub fn encode__blocked_reason(value__: BlockedReason) {
  case value__ {
    BlockedReasonOther -> "other"
    BlockedReasonCsp -> "csp"
    BlockedReasonMixedContent -> "mixed-content"
    BlockedReasonOrigin -> "origin"
    BlockedReasonInspector -> "inspector"
    BlockedReasonSubresourceFilter -> "subresource-filter"
    BlockedReasonContentType -> "content-type"
    BlockedReasonCoepFrameResourceNeedsCoepHeader ->
      "coep-frame-resource-needs-coep-header"
    BlockedReasonCoopSandboxedIframeCannotNavigateToCoopPage ->
      "coop-sandboxed-iframe-cannot-navigate-to-coop-page"
    BlockedReasonCorpNotSameOrigin -> "corp-not-same-origin"
    BlockedReasonCorpNotSameOriginAfterDefaultedToSameOriginByCoep ->
      "corp-not-same-origin-after-defaulted-to-same-origin-by-coep"
    BlockedReasonCorpNotSameSite -> "corp-not-same-site"
  }
  |> json.string()
}

@internal
pub fn decode__blocked_reason() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "other" -> decode.success(BlockedReasonOther)
      "csp" -> decode.success(BlockedReasonCsp)
      "mixed-content" -> decode.success(BlockedReasonMixedContent)
      "origin" -> decode.success(BlockedReasonOrigin)
      "inspector" -> decode.success(BlockedReasonInspector)
      "subresource-filter" -> decode.success(BlockedReasonSubresourceFilter)
      "content-type" -> decode.success(BlockedReasonContentType)
      "coep-frame-resource-needs-coep-header" ->
        decode.success(BlockedReasonCoepFrameResourceNeedsCoepHeader)
      "coop-sandboxed-iframe-cannot-navigate-to-coop-page" ->
        decode.success(BlockedReasonCoopSandboxedIframeCannotNavigateToCoopPage)
      "corp-not-same-origin" -> decode.success(BlockedReasonCorpNotSameOrigin)
      "corp-not-same-origin-after-defaulted-to-same-origin-by-coep" ->
        decode.success(
          BlockedReasonCorpNotSameOriginAfterDefaultedToSameOriginByCoep,
        )
      "corp-not-same-site" -> decode.success(BlockedReasonCorpNotSameSite)
      _ -> decode.failure(BlockedReasonOther, "valid enum property")
    }
  }
}

/// The reason why request was blocked.
pub type CorsError {
  CorsErrorDisallowedByMode
  CorsErrorInvalidResponse
  CorsErrorWildcardOriginNotAllowed
  CorsErrorMissingAllowOriginHeader
  CorsErrorMultipleAllowOriginValues
  CorsErrorInvalidAllowOriginValue
  CorsErrorAllowOriginMismatch
  CorsErrorInvalidAllowCredentials
  CorsErrorCorsDisabledScheme
  CorsErrorPreflightInvalidStatus
  CorsErrorPreflightDisallowedRedirect
  CorsErrorPreflightWildcardOriginNotAllowed
  CorsErrorPreflightMissingAllowOriginHeader
  CorsErrorPreflightMultipleAllowOriginValues
  CorsErrorPreflightInvalidAllowOriginValue
  CorsErrorPreflightAllowOriginMismatch
  CorsErrorPreflightInvalidAllowCredentials
  CorsErrorPreflightMissingAllowExternal
  CorsErrorPreflightInvalidAllowExternal
  CorsErrorPreflightMissingAllowPrivateNetwork
  CorsErrorPreflightInvalidAllowPrivateNetwork
  CorsErrorInvalidAllowMethodsPreflightResponse
  CorsErrorInvalidAllowHeadersPreflightResponse
  CorsErrorMethodDisallowedByPreflightResponse
  CorsErrorHeaderDisallowedByPreflightResponse
  CorsErrorRedirectContainsCredentials
  CorsErrorInsecurePrivateNetwork
  CorsErrorInvalidPrivateNetworkAccess
  CorsErrorUnexpectedPrivateNetworkAccess
  CorsErrorNoCorsRedirectModeNotFollow
  CorsErrorPreflightMissingPrivateNetworkAccessId
  CorsErrorPreflightMissingPrivateNetworkAccessName
  CorsErrorPrivateNetworkAccessPermissionUnavailable
  CorsErrorPrivateNetworkAccessPermissionDenied
}

@internal
pub fn encode__cors_error(value__: CorsError) {
  case value__ {
    CorsErrorDisallowedByMode -> "DisallowedByMode"
    CorsErrorInvalidResponse -> "InvalidResponse"
    CorsErrorWildcardOriginNotAllowed -> "WildcardOriginNotAllowed"
    CorsErrorMissingAllowOriginHeader -> "MissingAllowOriginHeader"
    CorsErrorMultipleAllowOriginValues -> "MultipleAllowOriginValues"
    CorsErrorInvalidAllowOriginValue -> "InvalidAllowOriginValue"
    CorsErrorAllowOriginMismatch -> "AllowOriginMismatch"
    CorsErrorInvalidAllowCredentials -> "InvalidAllowCredentials"
    CorsErrorCorsDisabledScheme -> "CorsDisabledScheme"
    CorsErrorPreflightInvalidStatus -> "PreflightInvalidStatus"
    CorsErrorPreflightDisallowedRedirect -> "PreflightDisallowedRedirect"
    CorsErrorPreflightWildcardOriginNotAllowed ->
      "PreflightWildcardOriginNotAllowed"
    CorsErrorPreflightMissingAllowOriginHeader ->
      "PreflightMissingAllowOriginHeader"
    CorsErrorPreflightMultipleAllowOriginValues ->
      "PreflightMultipleAllowOriginValues"
    CorsErrorPreflightInvalidAllowOriginValue ->
      "PreflightInvalidAllowOriginValue"
    CorsErrorPreflightAllowOriginMismatch -> "PreflightAllowOriginMismatch"
    CorsErrorPreflightInvalidAllowCredentials ->
      "PreflightInvalidAllowCredentials"
    CorsErrorPreflightMissingAllowExternal -> "PreflightMissingAllowExternal"
    CorsErrorPreflightInvalidAllowExternal -> "PreflightInvalidAllowExternal"
    CorsErrorPreflightMissingAllowPrivateNetwork ->
      "PreflightMissingAllowPrivateNetwork"
    CorsErrorPreflightInvalidAllowPrivateNetwork ->
      "PreflightInvalidAllowPrivateNetwork"
    CorsErrorInvalidAllowMethodsPreflightResponse ->
      "InvalidAllowMethodsPreflightResponse"
    CorsErrorInvalidAllowHeadersPreflightResponse ->
      "InvalidAllowHeadersPreflightResponse"
    CorsErrorMethodDisallowedByPreflightResponse ->
      "MethodDisallowedByPreflightResponse"
    CorsErrorHeaderDisallowedByPreflightResponse ->
      "HeaderDisallowedByPreflightResponse"
    CorsErrorRedirectContainsCredentials -> "RedirectContainsCredentials"
    CorsErrorInsecurePrivateNetwork -> "InsecurePrivateNetwork"
    CorsErrorInvalidPrivateNetworkAccess -> "InvalidPrivateNetworkAccess"
    CorsErrorUnexpectedPrivateNetworkAccess -> "UnexpectedPrivateNetworkAccess"
    CorsErrorNoCorsRedirectModeNotFollow -> "NoCorsRedirectModeNotFollow"
    CorsErrorPreflightMissingPrivateNetworkAccessId ->
      "PreflightMissingPrivateNetworkAccessId"
    CorsErrorPreflightMissingPrivateNetworkAccessName ->
      "PreflightMissingPrivateNetworkAccessName"
    CorsErrorPrivateNetworkAccessPermissionUnavailable ->
      "PrivateNetworkAccessPermissionUnavailable"
    CorsErrorPrivateNetworkAccessPermissionDenied ->
      "PrivateNetworkAccessPermissionDenied"
  }
  |> json.string()
}

@internal
pub fn decode__cors_error() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "DisallowedByMode" -> decode.success(CorsErrorDisallowedByMode)
      "InvalidResponse" -> decode.success(CorsErrorInvalidResponse)
      "WildcardOriginNotAllowed" ->
        decode.success(CorsErrorWildcardOriginNotAllowed)
      "MissingAllowOriginHeader" ->
        decode.success(CorsErrorMissingAllowOriginHeader)
      "MultipleAllowOriginValues" ->
        decode.success(CorsErrorMultipleAllowOriginValues)
      "InvalidAllowOriginValue" ->
        decode.success(CorsErrorInvalidAllowOriginValue)
      "AllowOriginMismatch" -> decode.success(CorsErrorAllowOriginMismatch)
      "InvalidAllowCredentials" ->
        decode.success(CorsErrorInvalidAllowCredentials)
      "CorsDisabledScheme" -> decode.success(CorsErrorCorsDisabledScheme)
      "PreflightInvalidStatus" ->
        decode.success(CorsErrorPreflightInvalidStatus)
      "PreflightDisallowedRedirect" ->
        decode.success(CorsErrorPreflightDisallowedRedirect)
      "PreflightWildcardOriginNotAllowed" ->
        decode.success(CorsErrorPreflightWildcardOriginNotAllowed)
      "PreflightMissingAllowOriginHeader" ->
        decode.success(CorsErrorPreflightMissingAllowOriginHeader)
      "PreflightMultipleAllowOriginValues" ->
        decode.success(CorsErrorPreflightMultipleAllowOriginValues)
      "PreflightInvalidAllowOriginValue" ->
        decode.success(CorsErrorPreflightInvalidAllowOriginValue)
      "PreflightAllowOriginMismatch" ->
        decode.success(CorsErrorPreflightAllowOriginMismatch)
      "PreflightInvalidAllowCredentials" ->
        decode.success(CorsErrorPreflightInvalidAllowCredentials)
      "PreflightMissingAllowExternal" ->
        decode.success(CorsErrorPreflightMissingAllowExternal)
      "PreflightInvalidAllowExternal" ->
        decode.success(CorsErrorPreflightInvalidAllowExternal)
      "PreflightMissingAllowPrivateNetwork" ->
        decode.success(CorsErrorPreflightMissingAllowPrivateNetwork)
      "PreflightInvalidAllowPrivateNetwork" ->
        decode.success(CorsErrorPreflightInvalidAllowPrivateNetwork)
      "InvalidAllowMethodsPreflightResponse" ->
        decode.success(CorsErrorInvalidAllowMethodsPreflightResponse)
      "InvalidAllowHeadersPreflightResponse" ->
        decode.success(CorsErrorInvalidAllowHeadersPreflightResponse)
      "MethodDisallowedByPreflightResponse" ->
        decode.success(CorsErrorMethodDisallowedByPreflightResponse)
      "HeaderDisallowedByPreflightResponse" ->
        decode.success(CorsErrorHeaderDisallowedByPreflightResponse)
      "RedirectContainsCredentials" ->
        decode.success(CorsErrorRedirectContainsCredentials)
      "InsecurePrivateNetwork" ->
        decode.success(CorsErrorInsecurePrivateNetwork)
      "InvalidPrivateNetworkAccess" ->
        decode.success(CorsErrorInvalidPrivateNetworkAccess)
      "UnexpectedPrivateNetworkAccess" ->
        decode.success(CorsErrorUnexpectedPrivateNetworkAccess)
      "NoCorsRedirectModeNotFollow" ->
        decode.success(CorsErrorNoCorsRedirectModeNotFollow)
      "PreflightMissingPrivateNetworkAccessId" ->
        decode.success(CorsErrorPreflightMissingPrivateNetworkAccessId)
      "PreflightMissingPrivateNetworkAccessName" ->
        decode.success(CorsErrorPreflightMissingPrivateNetworkAccessName)
      "PrivateNetworkAccessPermissionUnavailable" ->
        decode.success(CorsErrorPrivateNetworkAccessPermissionUnavailable)
      "PrivateNetworkAccessPermissionDenied" ->
        decode.success(CorsErrorPrivateNetworkAccessPermissionDenied)
      _ -> decode.failure(CorsErrorDisallowedByMode, "valid enum property")
    }
  }
}

pub type CorsErrorStatus {
  CorsErrorStatus(cors_error: CorsError, failed_parameter: String)
}

@internal
pub fn encode__cors_error_status(value__: CorsErrorStatus) {
  json.object([
    #("corsError", encode__cors_error(value__.cors_error)),
    #("failedParameter", json.string(value__.failed_parameter)),
  ])
}

@internal
pub fn decode__cors_error_status() {
  {
    use cors_error <- decode.field("corsError", decode__cors_error())
    use failed_parameter <- decode.field("failedParameter", decode.string)

    decode.success(CorsErrorStatus(
      cors_error: cors_error,
      failed_parameter: failed_parameter,
    ))
  }
}

/// Source of serviceworker response.
pub type ServiceWorkerResponseSource {
  ServiceWorkerResponseSourceCacheStorage
  ServiceWorkerResponseSourceHttpCache
  ServiceWorkerResponseSourceFallbackCode
  ServiceWorkerResponseSourceNetwork
}

@internal
pub fn encode__service_worker_response_source(
  value__: ServiceWorkerResponseSource,
) {
  case value__ {
    ServiceWorkerResponseSourceCacheStorage -> "cache-storage"
    ServiceWorkerResponseSourceHttpCache -> "http-cache"
    ServiceWorkerResponseSourceFallbackCode -> "fallback-code"
    ServiceWorkerResponseSourceNetwork -> "network"
  }
  |> json.string()
}

@internal
pub fn decode__service_worker_response_source() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "cache-storage" -> decode.success(ServiceWorkerResponseSourceCacheStorage)
      "http-cache" -> decode.success(ServiceWorkerResponseSourceHttpCache)
      "fallback-code" -> decode.success(ServiceWorkerResponseSourceFallbackCode)
      "network" -> decode.success(ServiceWorkerResponseSourceNetwork)
      _ ->
        decode.failure(
          ServiceWorkerResponseSourceCacheStorage,
          "valid enum property",
        )
    }
  }
}

/// Source of service worker router.
pub type ServiceWorkerRouterSource {
  ServiceWorkerRouterSourceNetwork
  ServiceWorkerRouterSourceCache
  ServiceWorkerRouterSourceFetchEvent
  ServiceWorkerRouterSourceRaceNetworkAndFetchHandler
}

@internal
pub fn encode__service_worker_router_source(value__: ServiceWorkerRouterSource) {
  case value__ {
    ServiceWorkerRouterSourceNetwork -> "network"
    ServiceWorkerRouterSourceCache -> "cache"
    ServiceWorkerRouterSourceFetchEvent -> "fetch-event"
    ServiceWorkerRouterSourceRaceNetworkAndFetchHandler ->
      "race-network-and-fetch-handler"
  }
  |> json.string()
}

@internal
pub fn decode__service_worker_router_source() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "network" -> decode.success(ServiceWorkerRouterSourceNetwork)
      "cache" -> decode.success(ServiceWorkerRouterSourceCache)
      "fetch-event" -> decode.success(ServiceWorkerRouterSourceFetchEvent)
      "race-network-and-fetch-handler" ->
        decode.success(ServiceWorkerRouterSourceRaceNetworkAndFetchHandler)
      _ ->
        decode.failure(ServiceWorkerRouterSourceNetwork, "valid enum property")
    }
  }
}

/// HTTP response data.
pub type Response {
  Response(
    /// Response URL. This URL can be different from CachedResource.url in case of redirect.  
    url: String,
    /// HTTP response status code.  
    status: Int,
    /// HTTP response status text.  
    status_text: String,
    /// HTTP response headers.  
    headers: Headers,
    /// Resource mimeType as determined by the browser.  
    mime_type: String,
    /// Resource charset as determined by the browser (if applicable).  
    charset: String,
    /// Refined HTTP request headers that were actually transmitted over the network.  
    request_headers: option.Option(Headers),
    /// Specifies whether physical connection was actually reused for this request.  
    connection_reused: Bool,
    /// Physical connection id that was actually used for this request.  
    connection_id: Float,
    /// Remote IP address.  
    remote_ip_address: option.Option(String),
    /// Remote port.  
    remote_port: option.Option(Int),
    /// Specifies that the request was served from the disk cache.  
    from_disk_cache: option.Option(Bool),
    /// Specifies that the request was served from the ServiceWorker.  
    from_service_worker: option.Option(Bool),
    /// Specifies that the request was served from the prefetch cache.  
    from_prefetch_cache: option.Option(Bool),
    /// Specifies that the request was served from the prefetch cache.  
    from_early_hints: option.Option(Bool),
    /// Total number of bytes received for this request so far.  
    encoded_data_length: Float,
    /// Timing information for the given request.  
    timing: option.Option(ResourceTiming),
    /// Response source of response from ServiceWorker.  
    service_worker_response_source: option.Option(ServiceWorkerResponseSource),
    /// The time at which the returned response was generated.  
    response_time: option.Option(TimeSinceEpoch),
    /// Cache Storage Cache Name.  
    cache_storage_cache_name: option.Option(String),
    /// Protocol used to fetch this request.  
    protocol: option.Option(String),
    /// Security state of the request resource.  
    security_state: security.SecurityState,
    /// Security details for the request.  
    security_details: option.Option(SecurityDetails),
  )
}

@internal
pub fn encode__response(value__: Response) {
  json.object(
    [
      #("url", json.string(value__.url)),
      #("status", json.int(value__.status)),
      #("statusText", json.string(value__.status_text)),
      #("headers", encode__headers(value__.headers)),
      #("mimeType", json.string(value__.mime_type)),
      #("charset", json.string(value__.charset)),
      #("connectionReused", json.bool(value__.connection_reused)),
      #("connectionId", json.float(value__.connection_id)),
      #("encodedDataLength", json.float(value__.encoded_data_length)),
      #(
        "securityState",
        security.encode__security_state(value__.security_state),
      ),
    ]
    |> utils.add_optional(value__.request_headers, fn(inner_value__) {
      #("requestHeaders", encode__headers(inner_value__))
    })
    |> utils.add_optional(value__.remote_ip_address, fn(inner_value__) {
      #("remoteIPAddress", json.string(inner_value__))
    })
    |> utils.add_optional(value__.remote_port, fn(inner_value__) {
      #("remotePort", json.int(inner_value__))
    })
    |> utils.add_optional(value__.from_disk_cache, fn(inner_value__) {
      #("fromDiskCache", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.from_service_worker, fn(inner_value__) {
      #("fromServiceWorker", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.from_prefetch_cache, fn(inner_value__) {
      #("fromPrefetchCache", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.from_early_hints, fn(inner_value__) {
      #("fromEarlyHints", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.timing, fn(inner_value__) {
      #("timing", encode__resource_timing(inner_value__))
    })
    |> utils.add_optional(
      value__.service_worker_response_source,
      fn(inner_value__) {
        #(
          "serviceWorkerResponseSource",
          encode__service_worker_response_source(inner_value__),
        )
      },
    )
    |> utils.add_optional(value__.response_time, fn(inner_value__) {
      #("responseTime", encode__time_since_epoch(inner_value__))
    })
    |> utils.add_optional(value__.cache_storage_cache_name, fn(inner_value__) {
      #("cacheStorageCacheName", json.string(inner_value__))
    })
    |> utils.add_optional(value__.protocol, fn(inner_value__) {
      #("protocol", json.string(inner_value__))
    })
    |> utils.add_optional(value__.security_details, fn(inner_value__) {
      #("securityDetails", encode__security_details(inner_value__))
    }),
  )
}

@internal
pub fn decode__response() {
  {
    use url <- decode.field("url", decode.string)
    use status <- decode.field("status", decode.int)
    use status_text <- decode.field("statusText", decode.string)
    use headers <- decode.field("headers", decode__headers())
    use mime_type <- decode.field("mimeType", decode.string)
    use charset <- decode.field("charset", decode.string)
    use request_headers <- decode.optional_field(
      "requestHeaders",
      option.None,
      decode.optional(decode__headers()),
    )
    use connection_reused <- decode.field("connectionReused", decode.bool)
    use connection_id <- decode.field("connectionId", decode.float)
    use remote_ip_address <- decode.optional_field(
      "remoteIPAddress",
      option.None,
      decode.optional(decode.string),
    )
    use remote_port <- decode.optional_field(
      "remotePort",
      option.None,
      decode.optional(decode.int),
    )
    use from_disk_cache <- decode.optional_field(
      "fromDiskCache",
      option.None,
      decode.optional(decode.bool),
    )
    use from_service_worker <- decode.optional_field(
      "fromServiceWorker",
      option.None,
      decode.optional(decode.bool),
    )
    use from_prefetch_cache <- decode.optional_field(
      "fromPrefetchCache",
      option.None,
      decode.optional(decode.bool),
    )
    use from_early_hints <- decode.optional_field(
      "fromEarlyHints",
      option.None,
      decode.optional(decode.bool),
    )
    use encoded_data_length <- decode.field("encodedDataLength", decode.float)
    use timing <- decode.optional_field(
      "timing",
      option.None,
      decode.optional(decode__resource_timing()),
    )
    use service_worker_response_source <- decode.optional_field(
      "serviceWorkerResponseSource",
      option.None,
      decode.optional(decode__service_worker_response_source()),
    )
    use response_time <- decode.optional_field(
      "responseTime",
      option.None,
      decode.optional(decode__time_since_epoch()),
    )
    use cache_storage_cache_name <- decode.optional_field(
      "cacheStorageCacheName",
      option.None,
      decode.optional(decode.string),
    )
    use protocol <- decode.optional_field(
      "protocol",
      option.None,
      decode.optional(decode.string),
    )
    use security_state <- decode.field(
      "securityState",
      security.decode__security_state(),
    )
    use security_details <- decode.optional_field(
      "securityDetails",
      option.None,
      decode.optional(decode__security_details()),
    )

    decode.success(Response(
      url: url,
      status: status,
      status_text: status_text,
      headers: headers,
      mime_type: mime_type,
      charset: charset,
      request_headers: request_headers,
      connection_reused: connection_reused,
      connection_id: connection_id,
      remote_ip_address: remote_ip_address,
      remote_port: remote_port,
      from_disk_cache: from_disk_cache,
      from_service_worker: from_service_worker,
      from_prefetch_cache: from_prefetch_cache,
      from_early_hints: from_early_hints,
      encoded_data_length: encoded_data_length,
      timing: timing,
      service_worker_response_source: service_worker_response_source,
      response_time: response_time,
      cache_storage_cache_name: cache_storage_cache_name,
      protocol: protocol,
      security_state: security_state,
      security_details: security_details,
    ))
  }
}

/// WebSocket request data.
pub type WebSocketRequest {
  WebSocketRequest(
    /// HTTP request headers.  
    headers: Headers,
  )
}

@internal
pub fn encode__web_socket_request(value__: WebSocketRequest) {
  json.object([
    #("headers", encode__headers(value__.headers)),
  ])
}

@internal
pub fn decode__web_socket_request() {
  {
    use headers <- decode.field("headers", decode__headers())

    decode.success(WebSocketRequest(headers: headers))
  }
}

/// WebSocket response data.
pub type WebSocketResponse {
  WebSocketResponse(
    /// HTTP response status code.  
    status: Int,
    /// HTTP response status text.  
    status_text: String,
    /// HTTP response headers.  
    headers: Headers,
    /// HTTP response headers text.  
    headers_text: option.Option(String),
    /// HTTP request headers.  
    request_headers: option.Option(Headers),
    /// HTTP request headers text.  
    request_headers_text: option.Option(String),
  )
}

@internal
pub fn encode__web_socket_response(value__: WebSocketResponse) {
  json.object(
    [
      #("status", json.int(value__.status)),
      #("statusText", json.string(value__.status_text)),
      #("headers", encode__headers(value__.headers)),
    ]
    |> utils.add_optional(value__.headers_text, fn(inner_value__) {
      #("headersText", json.string(inner_value__))
    })
    |> utils.add_optional(value__.request_headers, fn(inner_value__) {
      #("requestHeaders", encode__headers(inner_value__))
    })
    |> utils.add_optional(value__.request_headers_text, fn(inner_value__) {
      #("requestHeadersText", json.string(inner_value__))
    }),
  )
}

@internal
pub fn decode__web_socket_response() {
  {
    use status <- decode.field("status", decode.int)
    use status_text <- decode.field("statusText", decode.string)
    use headers <- decode.field("headers", decode__headers())
    use headers_text <- decode.optional_field(
      "headersText",
      option.None,
      decode.optional(decode.string),
    )
    use request_headers <- decode.optional_field(
      "requestHeaders",
      option.None,
      decode.optional(decode__headers()),
    )
    use request_headers_text <- decode.optional_field(
      "requestHeadersText",
      option.None,
      decode.optional(decode.string),
    )

    decode.success(WebSocketResponse(
      status: status,
      status_text: status_text,
      headers: headers,
      headers_text: headers_text,
      request_headers: request_headers,
      request_headers_text: request_headers_text,
    ))
  }
}

/// WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
pub type WebSocketFrame {
  WebSocketFrame(
    /// WebSocket message opcode.  
    opcode: Float,
    /// WebSocket message mask.  
    mask: Bool,
    /// WebSocket message payload data.
    /// If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
    /// If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.  
    payload_data: String,
  )
}

@internal
pub fn encode__web_socket_frame(value__: WebSocketFrame) {
  json.object([
    #("opcode", json.float(value__.opcode)),
    #("mask", json.bool(value__.mask)),
    #("payloadData", json.string(value__.payload_data)),
  ])
}

@internal
pub fn decode__web_socket_frame() {
  {
    use opcode <- decode.field("opcode", decode.float)
    use mask <- decode.field("mask", decode.bool)
    use payload_data <- decode.field("payloadData", decode.string)

    decode.success(WebSocketFrame(
      opcode: opcode,
      mask: mask,
      payload_data: payload_data,
    ))
  }
}

/// Information about the cached resource.
pub type CachedResource {
  CachedResource(
    /// Resource URL. This is the url of the original network request.  
    url: String,
    /// Type of this resource.  
    type_: ResourceType,
    /// Cached response data.  
    response: option.Option(Response),
    /// Cached response body size.  
    body_size: Float,
  )
}

@internal
pub fn encode__cached_resource(value__: CachedResource) {
  json.object(
    [
      #("url", json.string(value__.url)),
      #("type", encode__resource_type(value__.type_)),
      #("bodySize", json.float(value__.body_size)),
    ]
    |> utils.add_optional(value__.response, fn(inner_value__) {
      #("response", encode__response(inner_value__))
    }),
  )
}

@internal
pub fn decode__cached_resource() {
  {
    use url <- decode.field("url", decode.string)
    use type_ <- decode.field("type", decode__resource_type())
    use response <- decode.optional_field(
      "response",
      option.None,
      decode.optional(decode__response()),
    )
    use body_size <- decode.field("bodySize", decode.float)

    decode.success(CachedResource(
      url: url,
      type_: type_,
      response: response,
      body_size: body_size,
    ))
  }
}

/// Information about the request initiator.
pub type Initiator {
  Initiator(
    /// Type of this initiator.  
    type_: InitiatorType,
    /// Initiator JavaScript stack trace, set for Script only.  
    stack: option.Option(runtime.StackTrace),
    /// Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.  
    url: option.Option(String),
    /// Initiator line number, set for Parser type or for Script type (when script is importing
    /// module) (0-based).  
    line_number: option.Option(Float),
    /// Initiator column number, set for Parser type or for Script type (when script is importing
    /// module) (0-based).  
    column_number: option.Option(Float),
    /// Set if another request triggered this request (e.g. preflight).  
    request_id: option.Option(RequestId),
  )
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `type` of `Initiator`
pub type InitiatorType {
  InitiatorTypeParser
  InitiatorTypeScript
  InitiatorTypePreload
  InitiatorTypeSignedExchange
  InitiatorTypePreflight
  InitiatorTypeOther
}

@internal
pub fn encode__initiator_type(value__: InitiatorType) {
  case value__ {
    InitiatorTypeParser -> "parser"
    InitiatorTypeScript -> "script"
    InitiatorTypePreload -> "preload"
    InitiatorTypeSignedExchange -> "SignedExchange"
    InitiatorTypePreflight -> "preflight"
    InitiatorTypeOther -> "other"
  }
  |> json.string()
}

@internal
pub fn decode__initiator_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "parser" -> decode.success(InitiatorTypeParser)
      "script" -> decode.success(InitiatorTypeScript)
      "preload" -> decode.success(InitiatorTypePreload)
      "SignedExchange" -> decode.success(InitiatorTypeSignedExchange)
      "preflight" -> decode.success(InitiatorTypePreflight)
      "other" -> decode.success(InitiatorTypeOther)
      _ -> decode.failure(InitiatorTypeParser, "valid enum property")
    }
  }
}

@internal
pub fn encode__initiator(value__: Initiator) {
  json.object(
    [
      #("type", encode__initiator_type(value__.type_)),
    ]
    |> utils.add_optional(value__.stack, fn(inner_value__) {
      #("stack", runtime.encode__stack_trace(inner_value__))
    })
    |> utils.add_optional(value__.url, fn(inner_value__) {
      #("url", json.string(inner_value__))
    })
    |> utils.add_optional(value__.line_number, fn(inner_value__) {
      #("lineNumber", json.float(inner_value__))
    })
    |> utils.add_optional(value__.column_number, fn(inner_value__) {
      #("columnNumber", json.float(inner_value__))
    })
    |> utils.add_optional(value__.request_id, fn(inner_value__) {
      #("requestId", encode__request_id(inner_value__))
    }),
  )
}

@internal
pub fn decode__initiator() {
  {
    use type_ <- decode.field("type", decode__initiator_type())
    use stack <- decode.optional_field(
      "stack",
      option.None,
      decode.optional(runtime.decode__stack_trace()),
    )
    use url <- decode.optional_field(
      "url",
      option.None,
      decode.optional(decode.string),
    )
    use line_number <- decode.optional_field(
      "lineNumber",
      option.None,
      decode.optional(decode.float),
    )
    use column_number <- decode.optional_field(
      "columnNumber",
      option.None,
      decode.optional(decode.float),
    )
    use request_id <- decode.optional_field(
      "requestId",
      option.None,
      decode.optional(decode__request_id()),
    )

    decode.success(Initiator(
      type_: type_,
      stack: stack,
      url: url,
      line_number: line_number,
      column_number: column_number,
      request_id: request_id,
    ))
  }
}

/// Cookie object
pub type Cookie {
  Cookie(
    /// Cookie name.  
    name: String,
    /// Cookie value.  
    value: String,
    /// Cookie domain.  
    domain: String,
    /// Cookie path.  
    path: String,
    /// Cookie expiration date as the number of seconds since the UNIX epoch.  
    expires: Float,
    /// Cookie size.  
    size: Int,
    /// True if cookie is http-only.  
    http_only: Bool,
    /// True if cookie is secure.  
    secure: Bool,
    /// True in case of session cookie.  
    session: Bool,
    /// Cookie SameSite type.  
    same_site: option.Option(CookieSameSite),
  )
}

@internal
pub fn encode__cookie(value__: Cookie) {
  json.object(
    [
      #("name", json.string(value__.name)),
      #("value", json.string(value__.value)),
      #("domain", json.string(value__.domain)),
      #("path", json.string(value__.path)),
      #("expires", json.float(value__.expires)),
      #("size", json.int(value__.size)),
      #("httpOnly", json.bool(value__.http_only)),
      #("secure", json.bool(value__.secure)),
      #("session", json.bool(value__.session)),
    ]
    |> utils.add_optional(value__.same_site, fn(inner_value__) {
      #("sameSite", encode__cookie_same_site(inner_value__))
    }),
  )
}

@internal
pub fn decode__cookie() {
  {
    use name <- decode.field("name", decode.string)
    use value <- decode.field("value", decode.string)
    use domain <- decode.field("domain", decode.string)
    use path <- decode.field("path", decode.string)
    use expires <- decode.field("expires", decode.float)
    use size <- decode.field("size", decode.int)
    use http_only <- decode.field("httpOnly", decode.bool)
    use secure <- decode.field("secure", decode.bool)
    use session <- decode.field("session", decode.bool)
    use same_site <- decode.optional_field(
      "sameSite",
      option.None,
      decode.optional(decode__cookie_same_site()),
    )

    decode.success(Cookie(
      name: name,
      value: value,
      domain: domain,
      path: path,
      expires: expires,
      size: size,
      http_only: http_only,
      secure: secure,
      session: session,
      same_site: same_site,
    ))
  }
}

/// Cookie parameter object
pub type CookieParam {
  CookieParam(
    /// Cookie name.  
    name: String,
    /// Cookie value.  
    value: String,
    /// The request-URI to associate with the setting of the cookie. This value can affect the
    /// default domain, path, source port, and source scheme values of the created cookie.  
    url: option.Option(String),
    /// Cookie domain.  
    domain: option.Option(String),
    /// Cookie path.  
    path: option.Option(String),
    /// True if cookie is secure.  
    secure: option.Option(Bool),
    /// True if cookie is http-only.  
    http_only: option.Option(Bool),
    /// Cookie SameSite type.  
    same_site: option.Option(CookieSameSite),
    /// Cookie expiration date, session cookie if not set  
    expires: option.Option(TimeSinceEpoch),
  )
}

@internal
pub fn encode__cookie_param(value__: CookieParam) {
  json.object(
    [
      #("name", json.string(value__.name)),
      #("value", json.string(value__.value)),
    ]
    |> utils.add_optional(value__.url, fn(inner_value__) {
      #("url", json.string(inner_value__))
    })
    |> utils.add_optional(value__.domain, fn(inner_value__) {
      #("domain", json.string(inner_value__))
    })
    |> utils.add_optional(value__.path, fn(inner_value__) {
      #("path", json.string(inner_value__))
    })
    |> utils.add_optional(value__.secure, fn(inner_value__) {
      #("secure", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.http_only, fn(inner_value__) {
      #("httpOnly", json.bool(inner_value__))
    })
    |> utils.add_optional(value__.same_site, fn(inner_value__) {
      #("sameSite", encode__cookie_same_site(inner_value__))
    })
    |> utils.add_optional(value__.expires, fn(inner_value__) {
      #("expires", encode__time_since_epoch(inner_value__))
    }),
  )
}

@internal
pub fn decode__cookie_param() {
  {
    use name <- decode.field("name", decode.string)
    use value <- decode.field("value", decode.string)
    use url <- decode.optional_field(
      "url",
      option.None,
      decode.optional(decode.string),
    )
    use domain <- decode.optional_field(
      "domain",
      option.None,
      decode.optional(decode.string),
    )
    use path <- decode.optional_field(
      "path",
      option.None,
      decode.optional(decode.string),
    )
    use secure <- decode.optional_field(
      "secure",
      option.None,
      decode.optional(decode.bool),
    )
    use http_only <- decode.optional_field(
      "httpOnly",
      option.None,
      decode.optional(decode.bool),
    )
    use same_site <- decode.optional_field(
      "sameSite",
      option.None,
      decode.optional(decode__cookie_same_site()),
    )
    use expires <- decode.optional_field(
      "expires",
      option.None,
      decode.optional(decode__time_since_epoch()),
    )

    decode.success(CookieParam(
      name: name,
      value: value,
      url: url,
      domain: domain,
      path: path,
      secure: secure,
      http_only: http_only,
      same_site: same_site,
      expires: expires,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_cookies`
pub type GetCookiesResponse {
  GetCookiesResponse(
    /// Array of cookie objects.  
    cookies: List(Cookie),
  )
}

@internal
pub fn decode__get_cookies_response() {
  {
    use cookies <- decode.field("cookies", decode.list(decode__cookie()))

    decode.success(GetCookiesResponse(cookies: cookies))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_response_body`
pub type GetResponseBodyResponse {
  GetResponseBodyResponse(
    /// Response body.  
    body: String,
    /// True, if content was sent as base64.  
    base64_encoded: Bool,
  )
}

@internal
pub fn decode__get_response_body_response() {
  {
    use body <- decode.field("body", decode.string)
    use base64_encoded <- decode.field("base64Encoded", decode.bool)

    decode.success(GetResponseBodyResponse(
      body: body,
      base64_encoded: base64_encoded,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_request_post_data`
pub type GetRequestPostDataResponse {
  GetRequestPostDataResponse(
    /// Request body string, omitting files from multipart requests  
    post_data: String,
  )
}

@internal
pub fn decode__get_request_post_data_response() {
  {
    use post_data <- decode.field("postData", decode.string)

    decode.success(GetRequestPostDataResponse(post_data: post_data))
  }
}

/// Clears browser cache.
/// 
pub fn clear_browser_cache(callback__) {
  callback__("Network.clearBrowserCache", option.None)
}

/// Clears browser cookies.
/// 
pub fn clear_browser_cookies(callback__) {
  callback__("Network.clearBrowserCookies", option.None)
}

/// Deletes browser cookies with matching name and url or domain/path/partitionKey pair.
/// 
/// Parameters:  
///  - `name` : Name of the cookies to remove.
///  - `url` : If specified, deletes all the cookies with the given name where domain and path match
/// provided URL.
///  - `domain` : If specified, deletes only cookies with the exact domain.
///  - `path` : If specified, deletes only cookies with the exact path.
///  - `partition_key` : If specified, deletes only cookies with the the given name and partitionKey where domain
/// matches provided URL.
/// 
/// Returns:  
/// 
pub fn delete_cookies(
  callback__,
  name name: String,
  url url: option.Option(String),
  domain domain: option.Option(String),
  path path: option.Option(String),
  partition_key partition_key: option.Option(String),
) {
  callback__(
    "Network.deleteCookies",
    option.Some(json.object(
      [
        #("name", json.string(name)),
      ]
      |> utils.add_optional(url, fn(inner_value__) {
        #("url", json.string(inner_value__))
      })
      |> utils.add_optional(domain, fn(inner_value__) {
        #("domain", json.string(inner_value__))
      })
      |> utils.add_optional(path, fn(inner_value__) {
        #("path", json.string(inner_value__))
      })
      |> utils.add_optional(partition_key, fn(inner_value__) {
        #("partitionKey", json.string(inner_value__))
      }),
    )),
  )
}

/// Disables network tracking, prevents network events from being sent to the client.
/// 
pub fn disable(callback__) {
  callback__("Network.disable", option.None)
}

/// Activates emulation of network conditions.
/// 
/// Parameters:  
///  - `offline` : True to emulate internet disconnection.
///  - `latency` : Minimum latency from request sent to response headers received (ms).
///  - `download_throughput` : Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
///  - `upload_throughput` : Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.
///  - `connection_type` : Connection type if known.
/// 
/// Returns:  
/// 
pub fn emulate_network_conditions(
  callback__,
  offline offline: Bool,
  latency latency: Float,
  download_throughput download_throughput: Float,
  upload_throughput upload_throughput: Float,
  connection_type connection_type: option.Option(ConnectionType),
) {
  callback__(
    "Network.emulateNetworkConditions",
    option.Some(json.object(
      [
        #("offline", json.bool(offline)),
        #("latency", json.float(latency)),
        #("downloadThroughput", json.float(download_throughput)),
        #("uploadThroughput", json.float(upload_throughput)),
      ]
      |> utils.add_optional(connection_type, fn(inner_value__) {
        #("connectionType", encode__connection_type(inner_value__))
      }),
    )),
  )
}

/// Enables network tracking, network events will now be delivered to the client.
/// 
/// Parameters:  
///  - `max_post_data_size` : Longest post body size (in bytes) that would be included in requestWillBeSent notification
/// 
/// Returns:  
/// 
pub fn enable(
  callback__,
  max_post_data_size max_post_data_size: option.Option(Int),
) {
  callback__(
    "Network.enable",
    option.Some(json.object(
      []
      |> utils.add_optional(max_post_data_size, fn(inner_value__) {
        #("maxPostDataSize", json.int(inner_value__))
      }),
    )),
  )
}

/// Returns all browser cookies for the current URL. Depending on the backend support, will return
/// detailed cookie information in the `cookies` field.
/// 
/// Parameters:  
///  - `urls` : The list of URLs for which applicable cookies will be fetched.
/// If not specified, it's assumed to be set to the list containing
/// the URLs of the page and all of its subframes.
/// 
/// Returns:  
///  - `cookies` : Array of cookie objects.
/// 
pub fn get_cookies(callback__, urls urls: option.Option(List(String))) {
  use result__ <- result.try(callback__(
    "Network.getCookies",
    option.Some(json.object(
      []
      |> utils.add_optional(urls, fn(inner_value__) {
        #("urls", json.array(inner_value__, of: json.string))
      }),
    )),
  ))

  decode.run(result__, decode__get_cookies_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns content served for the given request.
/// 
/// Parameters:  
///  - `request_id` : Identifier of the network request to get content for.
/// 
/// Returns:  
///  - `body` : Response body.
///  - `base64_encoded` : True, if content was sent as base64.
/// 
pub fn get_response_body(callback__, request_id request_id: RequestId) {
  use result__ <- result.try(callback__(
    "Network.getResponseBody",
    option.Some(
      json.object([
        #("requestId", encode__request_id(request_id)),
      ]),
    ),
  ))

  decode.run(result__, decode__get_response_body_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns post data sent with the request. Returns an error when no data was sent with the request.
/// 
/// Parameters:  
///  - `request_id` : Identifier of the network request to get content for.
/// 
/// Returns:  
///  - `post_data` : Request body string, omitting files from multipart requests
/// 
pub fn get_request_post_data(callback__, request_id request_id: RequestId) {
  use result__ <- result.try(callback__(
    "Network.getRequestPostData",
    option.Some(
      json.object([
        #("requestId", encode__request_id(request_id)),
      ]),
    ),
  ))

  decode.run(result__, decode__get_request_post_data_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Toggles ignoring of service worker for each request.
/// 
/// Parameters:  
///  - `bypass` : Bypass service worker and load from network.
/// 
/// Returns:  
/// 
pub fn set_bypass_service_worker(callback__, bypass bypass: Bool) {
  callback__(
    "Network.setBypassServiceWorker",
    option.Some(
      json.object([
        #("bypass", json.bool(bypass)),
      ]),
    ),
  )
}

/// Toggles ignoring cache for each request. If `true`, cache will not be used.
/// 
/// Parameters:  
///  - `cache_disabled` : Cache disabled state.
/// 
/// Returns:  
/// 
pub fn set_cache_disabled(callback__, cache_disabled cache_disabled: Bool) {
  callback__(
    "Network.setCacheDisabled",
    option.Some(
      json.object([
        #("cacheDisabled", json.bool(cache_disabled)),
      ]),
    ),
  )
}

/// Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
/// 
/// Parameters:  
///  - `name` : Cookie name.
///  - `value` : Cookie value.
///  - `url` : The request-URI to associate with the setting of the cookie. This value can affect the
/// default domain, path, source port, and source scheme values of the created cookie.
///  - `domain` : Cookie domain.
///  - `path` : Cookie path.
///  - `secure` : True if cookie is secure.
///  - `http_only` : True if cookie is http-only.
///  - `same_site` : Cookie SameSite type.
///  - `expires` : Cookie expiration date, session cookie if not set
/// 
/// Returns:  
/// 
pub fn set_cookie(
  callback__,
  name name: String,
  value value: String,
  url url: option.Option(String),
  domain domain: option.Option(String),
  path path: option.Option(String),
  secure secure: option.Option(Bool),
  http_only http_only: option.Option(Bool),
  same_site same_site: option.Option(CookieSameSite),
  expires expires: option.Option(TimeSinceEpoch),
) {
  callback__(
    "Network.setCookie",
    option.Some(json.object(
      [
        #("name", json.string(name)),
        #("value", json.string(value)),
      ]
      |> utils.add_optional(url, fn(inner_value__) {
        #("url", json.string(inner_value__))
      })
      |> utils.add_optional(domain, fn(inner_value__) {
        #("domain", json.string(inner_value__))
      })
      |> utils.add_optional(path, fn(inner_value__) {
        #("path", json.string(inner_value__))
      })
      |> utils.add_optional(secure, fn(inner_value__) {
        #("secure", json.bool(inner_value__))
      })
      |> utils.add_optional(http_only, fn(inner_value__) {
        #("httpOnly", json.bool(inner_value__))
      })
      |> utils.add_optional(same_site, fn(inner_value__) {
        #("sameSite", encode__cookie_same_site(inner_value__))
      })
      |> utils.add_optional(expires, fn(inner_value__) {
        #("expires", encode__time_since_epoch(inner_value__))
      }),
    )),
  )
}

/// Sets given cookies.
/// 
/// Parameters:  
///  - `cookies` : Cookies to be set.
/// 
/// Returns:  
/// 
pub fn set_cookies(callback__, cookies cookies: List(CookieParam)) {
  callback__(
    "Network.setCookies",
    option.Some(
      json.object([
        #("cookies", json.array(cookies, of: encode__cookie_param)),
      ]),
    ),
  )
}

/// Specifies whether to always send extra HTTP headers with the requests from this page.
/// 
/// Parameters:  
///  - `headers` : Map with extra HTTP headers.
/// 
/// Returns:  
/// 
pub fn set_extra_http_headers(callback__, headers headers: Headers) {
  callback__(
    "Network.setExtraHTTPHeaders",
    option.Some(
      json.object([
        #("headers", encode__headers(headers)),
      ]),
    ),
  )
}

/// Allows overriding user agent with the given string.
/// 
/// Parameters:  
///  - `user_agent` : User agent to use.
///  - `accept_language` : Browser language to emulate.
///  - `platform` : The platform navigator.platform should return.
/// 
/// Returns:  
/// 
pub fn set_user_agent_override(
  callback__,
  user_agent user_agent: String,
  accept_language accept_language: option.Option(String),
  platform platform: option.Option(String),
) {
  callback__(
    "Network.setUserAgentOverride",
    option.Some(json.object(
      [
        #("userAgent", json.string(user_agent)),
      ]
      |> utils.add_optional(accept_language, fn(inner_value__) {
        #("acceptLanguage", json.string(inner_value__))
      })
      |> utils.add_optional(platform, fn(inner_value__) {
        #("platform", json.string(inner_value__))
      }),
    )),
  )
}
