//// > âš™ï¸  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Page Domain  
////
//// Actions and events related to the inspected page belong to the page domain.  
////
//// [ðŸ“–   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Page/)

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// |                     Run `codegen.sh` to regenerate.                     |
// ---------------------------------------------------------------------------

import chrobot/chrome
import chrobot/internal/utils
import chrobot/protocol/dom
import chrobot/protocol/network
import chrobot/protocol/runtime
import gleam/dynamic/decode
import gleam/json
import gleam/option
import gleam/result

/// Unique frame identifier.
pub type FrameId {
  FrameId(String)
}

@internal
pub fn encode__frame_id(value__: FrameId) {
  case value__ {
    FrameId(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__frame_id() {
  {
    use value__ <- decode.then(decode.string)
    decode.success(FrameId(value__))
  }
}

/// Information about the Frame on the page.
pub type Frame {
  Frame(
    /// Frame unique identifier.  
    id: FrameId,
    /// Parent frame identifier.  
    parent_id: option.Option(FrameId),
    /// Identifier of the loader associated with this frame.  
    loader_id: network.LoaderId,
    /// Frame's name as specified in the tag.  
    name: option.Option(String),
    /// Frame document's URL without fragment.  
    url: String,
    /// Frame document's security origin.  
    security_origin: String,
    /// Frame document's mimeType as determined by the browser.  
    mime_type: String,
  )
}

@internal
pub fn encode__frame(value__: Frame) {
  json.object(
    [
      #("id", encode__frame_id(value__.id)),
      #("loaderId", network.encode__loader_id(value__.loader_id)),
      #("url", json.string(value__.url)),
      #("securityOrigin", json.string(value__.security_origin)),
      #("mimeType", json.string(value__.mime_type)),
    ]
    |> utils.add_optional(value__.parent_id, fn(inner_value__) {
      #("parentId", encode__frame_id(inner_value__))
    })
    |> utils.add_optional(value__.name, fn(inner_value__) {
      #("name", json.string(inner_value__))
    }),
  )
}

@internal
pub fn decode__frame() {
  {
    use id <- decode.field("id", decode__frame_id())
    use parent_id <- decode.optional_field(
      "parentId",
      option.None,
      decode.optional(decode__frame_id()),
    )
    use loader_id <- decode.field("loaderId", network.decode__loader_id())
    use name <- decode.optional_field(
      "name",
      option.None,
      decode.optional(decode.string),
    )
    use url <- decode.field("url", decode.string)
    use security_origin <- decode.field("securityOrigin", decode.string)
    use mime_type <- decode.field("mimeType", decode.string)

    decode.success(Frame(
      id: id,
      parent_id: parent_id,
      loader_id: loader_id,
      name: name,
      url: url,
      security_origin: security_origin,
      mime_type: mime_type,
    ))
  }
}

/// Information about the Frame hierarchy.
pub type FrameTree {
  FrameTree(
    /// Frame information for this tree item.  
    frame: Frame,
    /// Child frames.  
    child_frames: option.Option(List(FrameTree)),
  )
}

@internal
pub fn encode__frame_tree(value__: FrameTree) {
  json.object(
    [
      #("frame", encode__frame(value__.frame)),
    ]
    |> utils.add_optional(value__.child_frames, fn(inner_value__) {
      #("childFrames", json.array(inner_value__, of: encode__frame_tree))
    }),
  )
}

@internal
pub fn decode__frame_tree() {
  {
    use frame <- decode.field("frame", decode__frame())
    use child_frames <- decode.optional_field(
      "childFrames",
      option.None,
      decode.optional(decode.list(decode__frame_tree())),
    )

    decode.success(FrameTree(frame: frame, child_frames: child_frames))
  }
}

/// Unique script identifier.
pub type ScriptIdentifier {
  ScriptIdentifier(String)
}

@internal
pub fn encode__script_identifier(value__: ScriptIdentifier) {
  case value__ {
    ScriptIdentifier(inner_value__) -> json.string(inner_value__)
  }
}

@internal
pub fn decode__script_identifier() {
  {
    use value__ <- decode.then(decode.string)
    decode.success(ScriptIdentifier(value__))
  }
}

/// Transition type.
pub type TransitionType {
  TransitionTypeLink
  TransitionTypeTyped
  TransitionTypeAddressBar
  TransitionTypeAutoBookmark
  TransitionTypeAutoSubframe
  TransitionTypeManualSubframe
  TransitionTypeGenerated
  TransitionTypeAutoToplevel
  TransitionTypeFormSubmit
  TransitionTypeReload
  TransitionTypeKeyword
  TransitionTypeKeywordGenerated
  TransitionTypeOther
}

@internal
pub fn encode__transition_type(value__: TransitionType) {
  case value__ {
    TransitionTypeLink -> "link"
    TransitionTypeTyped -> "typed"
    TransitionTypeAddressBar -> "address_bar"
    TransitionTypeAutoBookmark -> "auto_bookmark"
    TransitionTypeAutoSubframe -> "auto_subframe"
    TransitionTypeManualSubframe -> "manual_subframe"
    TransitionTypeGenerated -> "generated"
    TransitionTypeAutoToplevel -> "auto_toplevel"
    TransitionTypeFormSubmit -> "form_submit"
    TransitionTypeReload -> "reload"
    TransitionTypeKeyword -> "keyword"
    TransitionTypeKeywordGenerated -> "keyword_generated"
    TransitionTypeOther -> "other"
  }
  |> json.string()
}

@internal
pub fn decode__transition_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "link" -> decode.success(TransitionTypeLink)
      "typed" -> decode.success(TransitionTypeTyped)
      "address_bar" -> decode.success(TransitionTypeAddressBar)
      "auto_bookmark" -> decode.success(TransitionTypeAutoBookmark)
      "auto_subframe" -> decode.success(TransitionTypeAutoSubframe)
      "manual_subframe" -> decode.success(TransitionTypeManualSubframe)
      "generated" -> decode.success(TransitionTypeGenerated)
      "auto_toplevel" -> decode.success(TransitionTypeAutoToplevel)
      "form_submit" -> decode.success(TransitionTypeFormSubmit)
      "reload" -> decode.success(TransitionTypeReload)
      "keyword" -> decode.success(TransitionTypeKeyword)
      "keyword_generated" -> decode.success(TransitionTypeKeywordGenerated)
      "other" -> decode.success(TransitionTypeOther)
      _ -> decode.failure(TransitionTypeLink, "valid enum property")
    }
  }
}

/// Navigation history entry.
pub type NavigationEntry {
  NavigationEntry(
    /// Unique id of the navigation history entry.  
    id: Int,
    /// URL of the navigation history entry.  
    url: String,
    /// URL that the user typed in the url bar.  
    user_typed_url: String,
    /// Title of the navigation history entry.  
    title: String,
    /// Transition type.  
    transition_type: TransitionType,
  )
}

@internal
pub fn encode__navigation_entry(value__: NavigationEntry) {
  json.object([
    #("id", json.int(value__.id)),
    #("url", json.string(value__.url)),
    #("userTypedURL", json.string(value__.user_typed_url)),
    #("title", json.string(value__.title)),
    #("transitionType", encode__transition_type(value__.transition_type)),
  ])
}

@internal
pub fn decode__navigation_entry() {
  {
    use id <- decode.field("id", decode.int)
    use url <- decode.field("url", decode.string)
    use user_typed_url <- decode.field("userTypedURL", decode.string)
    use title <- decode.field("title", decode.string)
    use transition_type <- decode.field(
      "transitionType",
      decode__transition_type(),
    )

    decode.success(NavigationEntry(
      id: id,
      url: url,
      user_typed_url: user_typed_url,
      title: title,
      transition_type: transition_type,
    ))
  }
}

/// Javascript dialog type.
pub type DialogType {
  DialogTypeAlert
  DialogTypeConfirm
  DialogTypePrompt
  DialogTypeBeforeunload
}

@internal
pub fn encode__dialog_type(value__: DialogType) {
  case value__ {
    DialogTypeAlert -> "alert"
    DialogTypeConfirm -> "confirm"
    DialogTypePrompt -> "prompt"
    DialogTypeBeforeunload -> "beforeunload"
  }
  |> json.string()
}

@internal
pub fn decode__dialog_type() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "alert" -> decode.success(DialogTypeAlert)
      "confirm" -> decode.success(DialogTypeConfirm)
      "prompt" -> decode.success(DialogTypePrompt)
      "beforeunload" -> decode.success(DialogTypeBeforeunload)
      _ -> decode.failure(DialogTypeAlert, "valid enum property")
    }
  }
}

/// Error while paring app manifest.
pub type AppManifestError {
  AppManifestError(
    /// Error message.  
    message: String,
    /// If critical, this is a non-recoverable parse error.  
    critical: Int,
    /// Error line.  
    line: Int,
    /// Error column.  
    column: Int,
  )
}

@internal
pub fn encode__app_manifest_error(value__: AppManifestError) {
  json.object([
    #("message", json.string(value__.message)),
    #("critical", json.int(value__.critical)),
    #("line", json.int(value__.line)),
    #("column", json.int(value__.column)),
  ])
}

@internal
pub fn decode__app_manifest_error() {
  {
    use message <- decode.field("message", decode.string)
    use critical <- decode.field("critical", decode.int)
    use line <- decode.field("line", decode.int)
    use column <- decode.field("column", decode.int)

    decode.success(AppManifestError(
      message: message,
      critical: critical,
      line: line,
      column: column,
    ))
  }
}

/// Layout viewport position and dimensions.
pub type LayoutViewport {
  LayoutViewport(
    /// Horizontal offset relative to the document (CSS pixels).  
    page_x: Int,
    /// Vertical offset relative to the document (CSS pixels).  
    page_y: Int,
    /// Width (CSS pixels), excludes scrollbar if present.  
    client_width: Int,
    /// Height (CSS pixels), excludes scrollbar if present.  
    client_height: Int,
  )
}

@internal
pub fn encode__layout_viewport(value__: LayoutViewport) {
  json.object([
    #("pageX", json.int(value__.page_x)),
    #("pageY", json.int(value__.page_y)),
    #("clientWidth", json.int(value__.client_width)),
    #("clientHeight", json.int(value__.client_height)),
  ])
}

@internal
pub fn decode__layout_viewport() {
  {
    use page_x <- decode.field("pageX", decode.int)
    use page_y <- decode.field("pageY", decode.int)
    use client_width <- decode.field("clientWidth", decode.int)
    use client_height <- decode.field("clientHeight", decode.int)

    decode.success(LayoutViewport(
      page_x: page_x,
      page_y: page_y,
      client_width: client_width,
      client_height: client_height,
    ))
  }
}

/// Visual viewport position, dimensions, and scale.
pub type VisualViewport {
  VisualViewport(
    /// Horizontal offset relative to the layout viewport (CSS pixels).  
    offset_x: Float,
    /// Vertical offset relative to the layout viewport (CSS pixels).  
    offset_y: Float,
    /// Horizontal offset relative to the document (CSS pixels).  
    page_x: Float,
    /// Vertical offset relative to the document (CSS pixels).  
    page_y: Float,
    /// Width (CSS pixels), excludes scrollbar if present.  
    client_width: Float,
    /// Height (CSS pixels), excludes scrollbar if present.  
    client_height: Float,
    /// Scale relative to the ideal viewport (size at width=device-width).  
    scale: Float,
    /// Page zoom factor (CSS to device independent pixels ratio).  
    zoom: option.Option(Float),
  )
}

@internal
pub fn encode__visual_viewport(value__: VisualViewport) {
  json.object(
    [
      #("offsetX", json.float(value__.offset_x)),
      #("offsetY", json.float(value__.offset_y)),
      #("pageX", json.float(value__.page_x)),
      #("pageY", json.float(value__.page_y)),
      #("clientWidth", json.float(value__.client_width)),
      #("clientHeight", json.float(value__.client_height)),
      #("scale", json.float(value__.scale)),
    ]
    |> utils.add_optional(value__.zoom, fn(inner_value__) {
      #("zoom", json.float(inner_value__))
    }),
  )
}

@internal
pub fn decode__visual_viewport() {
  {
    use offset_x <- decode.field("offsetX", decode.float)
    use offset_y <- decode.field("offsetY", decode.float)
    use page_x <- decode.field("pageX", decode.float)
    use page_y <- decode.field("pageY", decode.float)
    use client_width <- decode.field("clientWidth", decode.float)
    use client_height <- decode.field("clientHeight", decode.float)
    use scale <- decode.field("scale", decode.float)
    use zoom <- decode.optional_field(
      "zoom",
      option.None,
      decode.optional(decode.float),
    )

    decode.success(VisualViewport(
      offset_x: offset_x,
      offset_y: offset_y,
      page_x: page_x,
      page_y: page_y,
      client_width: client_width,
      client_height: client_height,
      scale: scale,
      zoom: zoom,
    ))
  }
}

/// Viewport for capturing screenshot.
pub type Viewport {
  Viewport(
    /// X offset in device independent pixels (dip).  
    x: Float,
    /// Y offset in device independent pixels (dip).  
    y: Float,
    /// Rectangle width in device independent pixels (dip).  
    width: Float,
    /// Rectangle height in device independent pixels (dip).  
    height: Float,
    /// Page scale factor.  
    scale: Float,
  )
}

@internal
pub fn encode__viewport(value__: Viewport) {
  json.object([
    #("x", json.float(value__.x)),
    #("y", json.float(value__.y)),
    #("width", json.float(value__.width)),
    #("height", json.float(value__.height)),
    #("scale", json.float(value__.scale)),
  ])
}

@internal
pub fn decode__viewport() {
  {
    use x <- decode.field("x", decode.float)
    use y <- decode.field("y", decode.float)
    use width <- decode.field("width", decode.float)
    use height <- decode.field("height", decode.float)
    use scale <- decode.field("scale", decode.float)

    decode.success(Viewport(
      x: x,
      y: y,
      width: width,
      height: height,
      scale: scale,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `add_script_to_evaluate_on_new_document`
pub type AddScriptToEvaluateOnNewDocumentResponse {
  AddScriptToEvaluateOnNewDocumentResponse(
    /// Identifier of the added script.  
    identifier: ScriptIdentifier,
  )
}

@internal
pub fn decode__add_script_to_evaluate_on_new_document_response() {
  {
    use identifier <- decode.field("identifier", decode__script_identifier())

    decode.success(AddScriptToEvaluateOnNewDocumentResponse(
      identifier: identifier,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `capture_screenshot`
pub type CaptureScreenshotResponse {
  CaptureScreenshotResponse(
    /// Base64-encoded image data. (Encoded as a base64 string when passed over JSON)  
    data: String,
  )
}

@internal
pub fn decode__capture_screenshot_response() {
  {
    use data <- decode.field("data", decode.string)

    decode.success(CaptureScreenshotResponse(data: data))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `create_isolated_world`
pub type CreateIsolatedWorldResponse {
  CreateIsolatedWorldResponse(
    /// Execution context of the isolated world.  
    execution_context_id: runtime.ExecutionContextId,
  )
}

@internal
pub fn decode__create_isolated_world_response() {
  {
    use execution_context_id <- decode.field(
      "executionContextId",
      runtime.decode__execution_context_id(),
    )

    decode.success(CreateIsolatedWorldResponse(
      execution_context_id: execution_context_id,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_app_manifest`
pub type GetAppManifestResponse {
  GetAppManifestResponse(
    /// Manifest location.  
    url: String,
    errors: List(AppManifestError),
    /// Manifest content.  
    data: option.Option(String),
  )
}

@internal
pub fn decode__get_app_manifest_response() {
  {
    use url <- decode.field("url", decode.string)
    use errors <- decode.field(
      "errors",
      decode.list(decode__app_manifest_error()),
    )
    use data <- decode.optional_field(
      "data",
      option.None,
      decode.optional(decode.string),
    )

    decode.success(GetAppManifestResponse(url: url, errors: errors, data: data))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_frame_tree`
pub type GetFrameTreeResponse {
  GetFrameTreeResponse(
    /// Present frame tree structure.  
    frame_tree: FrameTree,
  )
}

@internal
pub fn decode__get_frame_tree_response() {
  {
    use frame_tree <- decode.field("frameTree", decode__frame_tree())

    decode.success(GetFrameTreeResponse(frame_tree: frame_tree))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_layout_metrics`
pub type GetLayoutMetricsResponse {
  GetLayoutMetricsResponse(
    /// Metrics relating to the layout viewport in CSS pixels.  
    css_layout_viewport: LayoutViewport,
    /// Metrics relating to the visual viewport in CSS pixels.  
    css_visual_viewport: VisualViewport,
    /// Size of scrollable area in CSS pixels.  
    css_content_size: dom.Rect,
  )
}

@internal
pub fn decode__get_layout_metrics_response() {
  {
    use css_layout_viewport <- decode.field(
      "cssLayoutViewport",
      decode__layout_viewport(),
    )
    use css_visual_viewport <- decode.field(
      "cssVisualViewport",
      decode__visual_viewport(),
    )
    use css_content_size <- decode.field("cssContentSize", dom.decode__rect())

    decode.success(GetLayoutMetricsResponse(
      css_layout_viewport: css_layout_viewport,
      css_visual_viewport: css_visual_viewport,
      css_content_size: css_content_size,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_navigation_history`
pub type GetNavigationHistoryResponse {
  GetNavigationHistoryResponse(
    /// Index of the current navigation history entry.  
    current_index: Int,
    /// Array of navigation history entries.  
    entries: List(NavigationEntry),
  )
}

@internal
pub fn decode__get_navigation_history_response() {
  {
    use current_index <- decode.field("currentIndex", decode.int)
    use entries <- decode.field(
      "entries",
      decode.list(decode__navigation_entry()),
    )

    decode.success(GetNavigationHistoryResponse(
      current_index: current_index,
      entries: entries,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `navigate`
pub type NavigateResponse {
  NavigateResponse(
    /// Frame id that has navigated (or failed to navigate)  
    frame_id: FrameId,
    /// Loader identifier. This is omitted in case of same-document navigation,
    /// as the previously committed loaderId would not change.  
    loader_id: option.Option(network.LoaderId),
    /// User friendly error message, present if and only if navigation has failed.  
    error_text: option.Option(String),
  )
}

@internal
pub fn decode__navigate_response() {
  {
    use frame_id <- decode.field("frameId", decode__frame_id())
    use loader_id <- decode.optional_field(
      "loaderId",
      option.None,
      decode.optional(network.decode__loader_id()),
    )
    use error_text <- decode.optional_field(
      "errorText",
      option.None,
      decode.optional(decode.string),
    )

    decode.success(NavigateResponse(
      frame_id: frame_id,
      loader_id: loader_id,
      error_text: error_text,
    ))
  }
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `print_to_pdf`
pub type PrintToPdfResponse {
  PrintToPdfResponse(
    /// Base64-encoded pdf data. Empty if |returnAsStream| is specified. (Encoded as a base64 string when passed over JSON)  
    data: String,
  )
}

@internal
pub fn decode__print_to_pdf_response() {
  {
    use data <- decode.field("data", decode.string)

    decode.success(PrintToPdfResponse(data: data))
  }
}

/// Evaluates given script in every frame upon creation (before loading frame's scripts).
/// 
/// Parameters:  
///  - `source`
/// 
/// Returns:  
///  - `identifier` : Identifier of the added script.
/// 
pub fn add_script_to_evaluate_on_new_document(callback__, source source: String) {
  use result__ <- result.try(callback__(
    "Page.addScriptToEvaluateOnNewDocument",
    option.Some(
      json.object([
        #("source", json.string(source)),
      ]),
    ),
  ))

  decode.run(
    result__,
    decode__add_script_to_evaluate_on_new_document_response(),
  )
  |> result.replace_error(chrome.ProtocolError)
}

/// Brings page to front (activates tab).
/// 
pub fn bring_to_front(callback__) {
  callback__("Page.bringToFront", option.None)
}

/// Capture page screenshot.
/// 
/// Parameters:  
///  - `format` : Image compression format (defaults to png).
///  - `quality` : Compression quality from range [0..100] (jpeg only).
///  - `clip` : Capture the screenshot of a given region only.
/// 
/// Returns:  
///  - `data` : Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
/// 
pub fn capture_screenshot(
  callback__,
  format format: option.Option(CaptureScreenshotFormat),
  quality quality: option.Option(Int),
  clip clip: option.Option(Viewport),
) {
  use result__ <- result.try(callback__(
    "Page.captureScreenshot",
    option.Some(json.object(
      []
      |> utils.add_optional(format, fn(inner_value__) {
        #("format", encode__capture_screenshot_format(inner_value__))
      })
      |> utils.add_optional(quality, fn(inner_value__) {
        #("quality", json.int(inner_value__))
      })
      |> utils.add_optional(clip, fn(inner_value__) {
        #("clip", encode__viewport(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__capture_screenshot_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `format` of `captureScreenshot`
pub type CaptureScreenshotFormat {
  CaptureScreenshotFormatJpeg
  CaptureScreenshotFormatPng
  CaptureScreenshotFormatWebp
}

@internal
pub fn encode__capture_screenshot_format(value__: CaptureScreenshotFormat) {
  case value__ {
    CaptureScreenshotFormatJpeg -> "jpeg"
    CaptureScreenshotFormatPng -> "png"
    CaptureScreenshotFormatWebp -> "webp"
  }
  |> json.string()
}

@internal
pub fn decode__capture_screenshot_format() {
  {
    use value__ <- decode.then(decode.string)
    case value__ {
      "jpeg" -> decode.success(CaptureScreenshotFormatJpeg)
      "png" -> decode.success(CaptureScreenshotFormatPng)
      "webp" -> decode.success(CaptureScreenshotFormatWebp)
      _ -> decode.failure(CaptureScreenshotFormatJpeg, "valid enum property")
    }
  }
}

/// Creates an isolated world for the given frame.
/// 
/// Parameters:  
///  - `frame_id` : Id of the frame in which the isolated world should be created.
///  - `world_name` : An optional name which is reported in the Execution Context.
///  - `grant_univeral_access` : Whether or not universal access should be granted to the isolated world. This is a powerful
/// option, use with caution.
/// 
/// Returns:  
///  - `execution_context_id` : Execution context of the isolated world.
/// 
pub fn create_isolated_world(
  callback__,
  frame_id frame_id: FrameId,
  world_name world_name: option.Option(String),
  grant_univeral_access grant_univeral_access: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Page.createIsolatedWorld",
    option.Some(json.object(
      [
        #("frameId", encode__frame_id(frame_id)),
      ]
      |> utils.add_optional(world_name, fn(inner_value__) {
        #("worldName", json.string(inner_value__))
      })
      |> utils.add_optional(grant_univeral_access, fn(inner_value__) {
        #("grantUniveralAccess", json.bool(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__create_isolated_world_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Disables page domain notifications.
/// 
pub fn disable(callback__) {
  callback__("Page.disable", option.None)
}

/// Enables page domain notifications.
/// 
pub fn enable(callback__) {
  callback__("Page.enable", option.None)
}

/// Gets the processed manifest for this current document.
///   This API always waits for the manifest to be loaded.
///   If manifestId is provided, and it does not match the manifest of the
///     current document, this API errors out.
///   If there is not a loaded page, this API errors out immediately.
/// 
/// Parameters:  
///  - `manifest_id`
/// 
/// Returns:  
///  - `url` : Manifest location.
///  - `errors`
///  - `data` : Manifest content.
/// 
pub fn get_app_manifest(
  callback__,
  manifest_id manifest_id: option.Option(String),
) {
  use result__ <- result.try(callback__(
    "Page.getAppManifest",
    option.Some(json.object(
      []
      |> utils.add_optional(manifest_id, fn(inner_value__) {
        #("manifestId", json.string(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__get_app_manifest_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns present frame tree structure.
///  - `frame_tree` : Present frame tree structure.
/// 
pub fn get_frame_tree(callback__) {
  use result__ <- result.try(callback__("Page.getFrameTree", option.None))

  decode.run(result__, decode__get_frame_tree_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
///  - `css_layout_viewport` : Metrics relating to the layout viewport in CSS pixels.
///  - `css_visual_viewport` : Metrics relating to the visual viewport in CSS pixels.
///  - `css_content_size` : Size of scrollable area in CSS pixels.
/// 
pub fn get_layout_metrics(callback__) {
  use result__ <- result.try(callback__("Page.getLayoutMetrics", option.None))

  decode.run(result__, decode__get_layout_metrics_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Returns navigation history for the current page.
///  - `current_index` : Index of the current navigation history entry.
///  - `entries` : Array of navigation history entries.
/// 
pub fn get_navigation_history(callback__) {
  use result__ <- result.try(callback__(
    "Page.getNavigationHistory",
    option.None,
  ))

  decode.run(result__, decode__get_navigation_history_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Resets navigation history for the current page.
/// 
pub fn reset_navigation_history(callback__) {
  callback__("Page.resetNavigationHistory", option.None)
}

/// Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
/// 
/// Parameters:  
///  - `accept` : Whether to accept or dismiss the dialog.
///  - `prompt_text` : The text to enter into the dialog prompt before accepting. Used only if this is a prompt
/// dialog.
/// 
/// Returns:  
/// 
pub fn handle_java_script_dialog(
  callback__,
  accept accept: Bool,
  prompt_text prompt_text: option.Option(String),
) {
  callback__(
    "Page.handleJavaScriptDialog",
    option.Some(json.object(
      [
        #("accept", json.bool(accept)),
      ]
      |> utils.add_optional(prompt_text, fn(inner_value__) {
        #("promptText", json.string(inner_value__))
      }),
    )),
  )
}

/// Navigates current page to the given URL.
/// 
/// Parameters:  
///  - `url` : URL to navigate the page to.
///  - `referrer` : Referrer URL.
///  - `transition_type` : Intended transition type.
///  - `frame_id` : Frame id to navigate, if not specified navigates the top frame.
/// 
/// Returns:  
///  - `frame_id` : Frame id that has navigated (or failed to navigate)
///  - `loader_id` : Loader identifier. This is omitted in case of same-document navigation,
/// as the previously committed loaderId would not change.
///  - `error_text` : User friendly error message, present if and only if navigation has failed.
/// 
pub fn navigate(
  callback__,
  url url: String,
  referrer referrer: option.Option(String),
  transition_type transition_type: option.Option(TransitionType),
  frame_id frame_id: option.Option(FrameId),
) {
  use result__ <- result.try(callback__(
    "Page.navigate",
    option.Some(json.object(
      [
        #("url", json.string(url)),
      ]
      |> utils.add_optional(referrer, fn(inner_value__) {
        #("referrer", json.string(inner_value__))
      })
      |> utils.add_optional(transition_type, fn(inner_value__) {
        #("transitionType", encode__transition_type(inner_value__))
      })
      |> utils.add_optional(frame_id, fn(inner_value__) {
        #("frameId", encode__frame_id(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__navigate_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Navigates current page to the given history entry.
/// 
/// Parameters:  
///  - `entry_id` : Unique id of the entry to navigate to.
/// 
/// Returns:  
/// 
pub fn navigate_to_history_entry(callback__, entry_id entry_id: Int) {
  callback__(
    "Page.navigateToHistoryEntry",
    option.Some(
      json.object([
        #("entryId", json.int(entry_id)),
      ]),
    ),
  )
}

/// Print page as PDF.
/// 
/// Parameters:  
///  - `landscape` : Paper orientation. Defaults to false.
///  - `display_header_footer` : Display header and footer. Defaults to false.
///  - `print_background` : Print background graphics. Defaults to false.
///  - `scale` : Scale of the webpage rendering. Defaults to 1.
///  - `paper_width` : Paper width in inches. Defaults to 8.5 inches.
///  - `paper_height` : Paper height in inches. Defaults to 11 inches.
///  - `margin_top` : Top margin in inches. Defaults to 1cm (~0.4 inches).
///  - `margin_bottom` : Bottom margin in inches. Defaults to 1cm (~0.4 inches).
///  - `margin_left` : Left margin in inches. Defaults to 1cm (~0.4 inches).
///  - `margin_right` : Right margin in inches. Defaults to 1cm (~0.4 inches).
///  - `page_ranges` : Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are
/// printed in the document order, not in the order specified, and no
/// more than once.
/// Defaults to empty string, which implies the entire document is printed.
/// The page numbers are quietly capped to actual page count of the
/// document, and ranges beyond the end of the document are ignored.
/// If this results in no pages to print, an error is reported.
/// It is an error to specify a range with start greater than end.
///  - `header_template` : HTML template for the print header. Should be valid HTML markup with following
/// classes used to inject printing values into them:
/// - `date`: formatted print date
/// - `title`: document title
/// - `url`: document location
/// - `pageNumber`: current page number
/// - `totalPages`: total pages in the document
/// 
/// For example, `<span class=title></span>` would generate span containing the title.
///  - `footer_template` : HTML template for the print footer. Should use the same format as the `headerTemplate`.
///  - `prefer_css_page_size` : Whether or not to prefer page size as defined by css. Defaults to false,
/// in which case the content will be scaled to fit the paper size.
/// 
/// Returns:  
///  - `data` : Base64-encoded pdf data. Empty if |returnAsStream| is specified. (Encoded as a base64 string when passed over JSON)
/// 
pub fn print_to_pdf(
  callback__,
  landscape landscape: option.Option(Bool),
  display_header_footer display_header_footer: option.Option(Bool),
  print_background print_background: option.Option(Bool),
  scale scale: option.Option(Float),
  paper_width paper_width: option.Option(Float),
  paper_height paper_height: option.Option(Float),
  margin_top margin_top: option.Option(Float),
  margin_bottom margin_bottom: option.Option(Float),
  margin_left margin_left: option.Option(Float),
  margin_right margin_right: option.Option(Float),
  page_ranges page_ranges: option.Option(String),
  header_template header_template: option.Option(String),
  footer_template footer_template: option.Option(String),
  prefer_css_page_size prefer_css_page_size: option.Option(Bool),
) {
  use result__ <- result.try(callback__(
    "Page.printToPDF",
    option.Some(json.object(
      []
      |> utils.add_optional(landscape, fn(inner_value__) {
        #("landscape", json.bool(inner_value__))
      })
      |> utils.add_optional(display_header_footer, fn(inner_value__) {
        #("displayHeaderFooter", json.bool(inner_value__))
      })
      |> utils.add_optional(print_background, fn(inner_value__) {
        #("printBackground", json.bool(inner_value__))
      })
      |> utils.add_optional(scale, fn(inner_value__) {
        #("scale", json.float(inner_value__))
      })
      |> utils.add_optional(paper_width, fn(inner_value__) {
        #("paperWidth", json.float(inner_value__))
      })
      |> utils.add_optional(paper_height, fn(inner_value__) {
        #("paperHeight", json.float(inner_value__))
      })
      |> utils.add_optional(margin_top, fn(inner_value__) {
        #("marginTop", json.float(inner_value__))
      })
      |> utils.add_optional(margin_bottom, fn(inner_value__) {
        #("marginBottom", json.float(inner_value__))
      })
      |> utils.add_optional(margin_left, fn(inner_value__) {
        #("marginLeft", json.float(inner_value__))
      })
      |> utils.add_optional(margin_right, fn(inner_value__) {
        #("marginRight", json.float(inner_value__))
      })
      |> utils.add_optional(page_ranges, fn(inner_value__) {
        #("pageRanges", json.string(inner_value__))
      })
      |> utils.add_optional(header_template, fn(inner_value__) {
        #("headerTemplate", json.string(inner_value__))
      })
      |> utils.add_optional(footer_template, fn(inner_value__) {
        #("footerTemplate", json.string(inner_value__))
      })
      |> utils.add_optional(prefer_css_page_size, fn(inner_value__) {
        #("preferCSSPageSize", json.bool(inner_value__))
      }),
    )),
  ))

  decode.run(result__, decode__print_to_pdf_response())
  |> result.replace_error(chrome.ProtocolError)
}

/// Reloads given page optionally ignoring the cache.
/// 
/// Parameters:  
///  - `ignore_cache` : If true, browser cache is ignored (as if the user pressed Shift+refresh).
///  - `script_to_evaluate_on_load` : If set, the script will be injected into all frames of the inspected page after reload.
/// Argument will be ignored if reloading dataURL origin.
/// 
/// Returns:  
/// 
pub fn reload(
  callback__,
  ignore_cache ignore_cache: option.Option(Bool),
  script_to_evaluate_on_load script_to_evaluate_on_load: option.Option(String),
) {
  callback__(
    "Page.reload",
    option.Some(json.object(
      []
      |> utils.add_optional(ignore_cache, fn(inner_value__) {
        #("ignoreCache", json.bool(inner_value__))
      })
      |> utils.add_optional(script_to_evaluate_on_load, fn(inner_value__) {
        #("scriptToEvaluateOnLoad", json.string(inner_value__))
      }),
    )),
  )
}

/// Removes given script from the list.
/// 
/// Parameters:  
///  - `identifier`
/// 
/// Returns:  
/// 
pub fn remove_script_to_evaluate_on_new_document(
  callback__,
  identifier identifier: ScriptIdentifier,
) {
  callback__(
    "Page.removeScriptToEvaluateOnNewDocument",
    option.Some(
      json.object([
        #("identifier", encode__script_identifier(identifier)),
      ]),
    ),
  )
}

/// Enable page Content Security Policy by-passing.
/// 
/// Parameters:  
///  - `enabled` : Whether to bypass page CSP.
/// 
/// Returns:  
/// 
pub fn set_bypass_csp(callback__, enabled enabled: Bool) {
  callback__(
    "Page.setBypassCSP",
    option.Some(
      json.object([
        #("enabled", json.bool(enabled)),
      ]),
    ),
  )
}

/// Sets given markup as the document's HTML.
/// 
/// Parameters:  
///  - `frame_id` : Frame id to set HTML for.
///  - `html` : HTML content to set.
/// 
/// Returns:  
/// 
pub fn set_document_content(
  callback__,
  frame_id frame_id: FrameId,
  html html: String,
) {
  callback__(
    "Page.setDocumentContent",
    option.Some(
      json.object([
        #("frameId", encode__frame_id(frame_id)),
        #("html", json.string(html)),
      ]),
    ),
  )
}

/// Controls whether page will emit lifecycle events.
/// 
/// Parameters:  
///  - `enabled` : If true, starts emitting lifecycle events.
/// 
/// Returns:  
/// 
pub fn set_lifecycle_events_enabled(callback__, enabled enabled: Bool) {
  callback__(
    "Page.setLifecycleEventsEnabled",
    option.Some(
      json.object([
        #("enabled", json.bool(enabled)),
      ]),
    ),
  )
}

/// Force the page stop all navigations and pending resource fetches.
/// 
pub fn stop_loading(callback__) {
  callback__("Page.stopLoading", option.None)
}

/// Tries to close page, running its beforeunload hooks, if any.
/// 
pub fn close(callback__) {
  callback__("Page.close", option.None)
}

/// Intercept file chooser requests and transfer control to protocol clients.
/// When file chooser interception is enabled, native file chooser dialog is not shown.
/// Instead, a protocol event `Page.fileChooserOpened` is emitted.
/// 
/// Parameters:  
///  - `enabled`
/// 
/// Returns:  
/// 
pub fn set_intercept_file_chooser_dialog(callback__, enabled enabled: Bool) {
  callback__(
    "Page.setInterceptFileChooserDialog",
    option.Some(
      json.object([
        #("enabled", json.bool(enabled)),
      ]),
    ),
  )
}
