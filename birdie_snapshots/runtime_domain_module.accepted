---
version: 1.5.3
title: Runtime domain module
file: ./test/codegen/generate_bindings_test.gleam
test_name: gen_bindings_runtime_test
---

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// |                     Run `codegen.sh` to regenerate.                     |
// ---------------------------------------------------------------------------
//// > âš™ï¸  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Runtime Domain  
////
//// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
//// Evaluation results are returned as mirror object that expose object type, string representation
//// and unique identifier that can be used for further object reference. Original objects are
//// maintained in memory unless they are either explicitly released or are released along with the
//// other objects in their object group.  
////
//// [ðŸ“–   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/)

import chrobot/chrome
import gleam/dict
import gleam/dynamic
import gleam/dynamic/decode
import gleam/json
import gleam/list
import gleam/option
import gleam/result
import chrobot/internal/utils


/// Unique script identifier.
pub type ScriptId{
ScriptId(String)
}


@internal
pub fn encode__script_id(
value__: ScriptId
) {
case value__{
ScriptId(inner_value__) -> json.string(inner_value__)
}}
@internal
pub fn decode__script_id(
) {
{
use value__ <- decode.then(decode.string)
decode.success(ScriptId(value__))
}}
/// Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
pub type SerializationOptions{
SerializationOptions (
serialization: SerializationOptionsSerialization,

/// Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.  
max_depth: option.Option(Int),

/// Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM
/// serialization via `maxNodeDepth: integer` and `includeShadowTree: "none" | "open" | "all"`.
/// Values can be only of type string or integer.  
additional_parameters: option.Option(dict.Dict(String,String)),
)
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `serialization` of `SerializationOptions`

pub type SerializationOptionsSerialization{SerializationOptionsSerializationDeep
SerializationOptionsSerializationJson
SerializationOptionsSerializationIdOnly
}
@internal
pub fn encode__serialization_options_serialization(
value__: SerializationOptionsSerialization
) {
case value__{
SerializationOptionsSerializationDeep -> "deep"
SerializationOptionsSerializationJson -> "json"
SerializationOptionsSerializationIdOnly -> "idOnly"
}
|> json.string()
}

@internal
pub fn decode__serialization_options_serialization(
) {
{
use value__ <- decode.then(decode.string)
case value__ {
"deep" -> decode.success(SerializationOptionsSerializationDeep)
"json" -> decode.success(SerializationOptionsSerializationJson)
"idOnly" -> decode.success(SerializationOptionsSerializationIdOnly)
_ -> decode.failure(SerializationOptionsSerializationDeep, "valid enum property")
}
}}


@internal
pub fn encode__serialization_options(
value__: SerializationOptions
) {
json.object([
#("serialization", encode__serialization_options_serialization(value__.serialization)),
]|> utils.add_optional(value__.max_depth, fn(inner_value__){#("maxDepth", json.int(inner_value__))})
|> utils.add_optional(value__.additional_parameters, fn(inner_value__){#("additionalParameters", dict.to_list(inner_value__)
        |> list.map(fn(i) { #(i.0, json.string(i.1)) })
        |> json.object)})
)}
@internal
pub fn decode__serialization_options(
) {
{
use serialization <- decode.field("serialization", decode__serialization_options_serialization())
use max_depth <- decode.optional_field("maxDepth", option.None, decode.optional(decode.int))
use additional_parameters <- decode.optional_field("additionalParameters", option.None, decode.optional(decode.dict(decode.string, decode.string)))

decode.success(SerializationOptions(
serialization:serialization,
max_depth:max_depth,
additional_parameters:additional_parameters,
))
}}
/// Represents deep serialized value.
pub type DeepSerializedValue{
DeepSerializedValue (
type_: DeepSerializedValueType,
value: option.Option(dynamic.Dynamic),
object_id: option.Option(String),

/// Set if value reference met more then once during serialization. In such
/// case, value is provided only to one of the serialized values. Unique
/// per value in the scope of one CDP call.  
weak_local_object_reference: option.Option(Int),
)
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `type` of `DeepSerializedValue`

pub type DeepSerializedValueType{DeepSerializedValueTypeUndefined
DeepSerializedValueTypeNull
DeepSerializedValueTypeString
DeepSerializedValueTypeNumber
DeepSerializedValueTypeBoolean
DeepSerializedValueTypeBigint
DeepSerializedValueTypeRegexp
DeepSerializedValueTypeDate
DeepSerializedValueTypeSymbol
DeepSerializedValueTypeArray
DeepSerializedValueTypeObject
DeepSerializedValueTypeFunction
DeepSerializedValueTypeMap
DeepSerializedValueTypeSet
DeepSerializedValueTypeWeakmap
DeepSerializedValueTypeWeakset
DeepSerializedValueTypeError
DeepSerializedValueTypeProxy
DeepSerializedValueTypePromise
DeepSerializedValueTypeTypedarray
DeepSerializedValueTypeArraybuffer
DeepSerializedValueTypeNode
DeepSerializedValueTypeWindow
DeepSerializedValueTypeGenerator
}
@internal
pub fn encode__deep_serialized_value_type(
value__: DeepSerializedValueType
) {
case value__{
DeepSerializedValueTypeUndefined -> "undefined"
DeepSerializedValueTypeNull -> "null"
DeepSerializedValueTypeString -> "string"
DeepSerializedValueTypeNumber -> "number"
DeepSerializedValueTypeBoolean -> "boolean"
DeepSerializedValueTypeBigint -> "bigint"
DeepSerializedValueTypeRegexp -> "regexp"
DeepSerializedValueTypeDate -> "date"
DeepSerializedValueTypeSymbol -> "symbol"
DeepSerializedValueTypeArray -> "array"
DeepSerializedValueTypeObject -> "object"
DeepSerializedValueTypeFunction -> "function"
DeepSerializedValueTypeMap -> "map"
DeepSerializedValueTypeSet -> "set"
DeepSerializedValueTypeWeakmap -> "weakmap"
DeepSerializedValueTypeWeakset -> "weakset"
DeepSerializedValueTypeError -> "error"
DeepSerializedValueTypeProxy -> "proxy"
DeepSerializedValueTypePromise -> "promise"
DeepSerializedValueTypeTypedarray -> "typedarray"
DeepSerializedValueTypeArraybuffer -> "arraybuffer"
DeepSerializedValueTypeNode -> "node"
DeepSerializedValueTypeWindow -> "window"
DeepSerializedValueTypeGenerator -> "generator"
}
|> json.string()
}

@internal
pub fn decode__deep_serialized_value_type(
) {
{
use value__ <- decode.then(decode.string)
case value__ {
"undefined" -> decode.success(DeepSerializedValueTypeUndefined)
"null" -> decode.success(DeepSerializedValueTypeNull)
"string" -> decode.success(DeepSerializedValueTypeString)
"number" -> decode.success(DeepSerializedValueTypeNumber)
"boolean" -> decode.success(DeepSerializedValueTypeBoolean)
"bigint" -> decode.success(DeepSerializedValueTypeBigint)
"regexp" -> decode.success(DeepSerializedValueTypeRegexp)
"date" -> decode.success(DeepSerializedValueTypeDate)
"symbol" -> decode.success(DeepSerializedValueTypeSymbol)
"array" -> decode.success(DeepSerializedValueTypeArray)
"object" -> decode.success(DeepSerializedValueTypeObject)
"function" -> decode.success(DeepSerializedValueTypeFunction)
"map" -> decode.success(DeepSerializedValueTypeMap)
"set" -> decode.success(DeepSerializedValueTypeSet)
"weakmap" -> decode.success(DeepSerializedValueTypeWeakmap)
"weakset" -> decode.success(DeepSerializedValueTypeWeakset)
"error" -> decode.success(DeepSerializedValueTypeError)
"proxy" -> decode.success(DeepSerializedValueTypeProxy)
"promise" -> decode.success(DeepSerializedValueTypePromise)
"typedarray" -> decode.success(DeepSerializedValueTypeTypedarray)
"arraybuffer" -> decode.success(DeepSerializedValueTypeArraybuffer)
"node" -> decode.success(DeepSerializedValueTypeNode)
"window" -> decode.success(DeepSerializedValueTypeWindow)
"generator" -> decode.success(DeepSerializedValueTypeGenerator)
_ -> decode.failure(DeepSerializedValueTypeUndefined, "valid enum property")
}
}}


@internal
pub fn encode__deep_serialized_value(
value__: DeepSerializedValue
) {
json.object([
#("type", encode__deep_serialized_value_type(value__.type_)),
]|> utils.add_optional(value__.value, fn(inner_value__){#("value", utils.alert_encode_dynamic(inner_value__))})
|> utils.add_optional(value__.object_id, fn(inner_value__){#("objectId", json.string(inner_value__))})
|> utils.add_optional(value__.weak_local_object_reference, fn(inner_value__){#("weakLocalObjectReference", json.int(inner_value__))})
)}
@internal
pub fn decode__deep_serialized_value(
) {
{
use type_ <- decode.field("type", decode__deep_serialized_value_type())
use value <- decode.optional_field("value", option.None, decode.dynamic |> decode.map(option.Some))
use object_id <- decode.optional_field("objectId", option.None, decode.optional(decode.string))
use weak_local_object_reference <- decode.optional_field("weakLocalObjectReference", option.None, decode.optional(decode.int))

decode.success(DeepSerializedValue(
type_:type_,
value:value,
object_id:object_id,
weak_local_object_reference:weak_local_object_reference,
))
}}
/// Unique object identifier.
pub type RemoteObjectId{
RemoteObjectId(String)
}


@internal
pub fn encode__remote_object_id(
value__: RemoteObjectId
) {
case value__{
RemoteObjectId(inner_value__) -> json.string(inner_value__)
}}
@internal
pub fn decode__remote_object_id(
) {
{
use value__ <- decode.then(decode.string)
decode.success(RemoteObjectId(value__))
}}
/// Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
/// `-Infinity`, and bigint literals.
pub type UnserializableValue{
UnserializableValue(String)
}


@internal
pub fn encode__unserializable_value(
value__: UnserializableValue
) {
case value__{
UnserializableValue(inner_value__) -> json.string(inner_value__)
}}
@internal
pub fn decode__unserializable_value(
) {
{
use value__ <- decode.then(decode.string)
decode.success(UnserializableValue(value__))
}}
/// Mirror object referencing original JavaScript object.
pub type RemoteObject{
RemoteObject (

/// Object type.  
type_: RemoteObjectType,

/// Object subtype hint. Specified for `object` type values only.
/// NOTE: If you change anything here, make sure to also update
/// `subtype` in `ObjectPreview` and `PropertyPreview` below.  
subtype: option.Option(RemoteObjectSubtype),

/// Object class (constructor) name. Specified for `object` type values only.  
class_name: option.Option(String),

/// Remote object value in case of primitive values or JSON values (if it was requested).  
value: option.Option(dynamic.Dynamic),

/// Primitive value which can not be JSON-stringified does not have `value`, but gets this
/// property.  
unserializable_value: option.Option(UnserializableValue),

/// String representation of the object.  
description: option.Option(String),

/// Unique object identifier (for non-primitive values).  
object_id: option.Option(RemoteObjectId),
)
}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `type` of `RemoteObject`

pub type RemoteObjectType{RemoteObjectTypeObject
RemoteObjectTypeFunction
RemoteObjectTypeUndefined
RemoteObjectTypeString
RemoteObjectTypeNumber
RemoteObjectTypeBoolean
RemoteObjectTypeSymbol
RemoteObjectTypeBigint
}
@internal
pub fn encode__remote_object_type(
value__: RemoteObjectType
) {
case value__{
RemoteObjectTypeObject -> "object"
RemoteObjectTypeFunction -> "function"
RemoteObjectTypeUndefined -> "undefined"
RemoteObjectTypeString -> "string"
RemoteObjectTypeNumber -> "number"
RemoteObjectTypeBoolean -> "boolean"
RemoteObjectTypeSymbol -> "symbol"
RemoteObjectTypeBigint -> "bigint"
}
|> json.string()
}

@internal
pub fn decode__remote_object_type(
) {
{
use value__ <- decode.then(decode.string)
case value__ {
"object" -> decode.success(RemoteObjectTypeObject)
"function" -> decode.success(RemoteObjectTypeFunction)
"undefined" -> decode.success(RemoteObjectTypeUndefined)
"string" -> decode.success(RemoteObjectTypeString)
"number" -> decode.success(RemoteObjectTypeNumber)
"boolean" -> decode.success(RemoteObjectTypeBoolean)
"symbol" -> decode.success(RemoteObjectTypeSymbol)
"bigint" -> decode.success(RemoteObjectTypeBigint)
_ -> decode.failure(RemoteObjectTypeObject, "valid enum property")
}
}}

/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the possible values of the enum property `subtype` of `RemoteObject`

pub type RemoteObjectSubtype{RemoteObjectSubtypeArray
RemoteObjectSubtypeNull
RemoteObjectSubtypeNode
RemoteObjectSubtypeRegexp
RemoteObjectSubtypeDate
RemoteObjectSubtypeMap
RemoteObjectSubtypeSet
RemoteObjectSubtypeWeakmap
RemoteObjectSubtypeWeakset
RemoteObjectSubtypeIterator
RemoteObjectSubtypeGenerator
RemoteObjectSubtypeError
RemoteObjectSubtypeProxy
RemoteObjectSubtypePromise
RemoteObjectSubtypeTypedarray
RemoteObjectSubtypeArraybuffer
RemoteObjectSubtypeDataview
RemoteObjectSubtypeWebassemblymemory
RemoteObjectSubtypeWasmvalue
}
@internal
pub fn encode__remote_object_subtype(
value__: RemoteObjectSubtype
) {
case value__{
RemoteObjectSubtypeArray -> "array"
RemoteObjectSubtypeNull -> "null"
RemoteObjectSubtypeNode -> "node"
RemoteObjectSubtypeRegexp -> "regexp"
RemoteObjectSubtypeDate -> "date"
RemoteObjectSubtypeMap -> "map"
RemoteObjectSubtypeSet -> "set"
RemoteObjectSubtypeWeakmap -> "weakmap"
RemoteObjectSubtypeWeakset -> "weakset"
RemoteObjectSubtypeIterator -> "iterator"
RemoteObjectSubtypeGenerator -> "generator"
RemoteObjectSubtypeError -> "error"
RemoteObjectSubtypeProxy -> "proxy"
RemoteObjectSubtypePromise -> "promise"
RemoteObjectSubtypeTypedarray -> "typedarray"
RemoteObjectSubtypeArraybuffer -> "arraybuffer"
RemoteObjectSubtypeDataview -> "dataview"
RemoteObjectSubtypeWebassemblymemory -> "webassemblymemory"
RemoteObjectSubtypeWasmvalue -> "wasmvalue"
}
|> json.string()
}

@internal
pub fn decode__remote_object_subtype(
) {
{
use value__ <- decode.then(decode.string)
case value__ {
"array" -> decode.success(RemoteObjectSubtypeArray)
"null" -> decode.success(RemoteObjectSubtypeNull)
"node" -> decode.success(RemoteObjectSubtypeNode)
"regexp" -> decode.success(RemoteObjectSubtypeRegexp)
"date" -> decode.success(RemoteObjectSubtypeDate)
"map" -> decode.success(RemoteObjectSubtypeMap)
"set" -> decode.success(RemoteObjectSubtypeSet)
"weakmap" -> decode.success(RemoteObjectSubtypeWeakmap)
"weakset" -> decode.success(RemoteObjectSubtypeWeakset)
"iterator" -> decode.success(RemoteObjectSubtypeIterator)
"generator" -> decode.success(RemoteObjectSubtypeGenerator)
"error" -> decode.success(RemoteObjectSubtypeError)
"proxy" -> decode.success(RemoteObjectSubtypeProxy)
"promise" -> decode.success(RemoteObjectSubtypePromise)
"typedarray" -> decode.success(RemoteObjectSubtypeTypedarray)
"arraybuffer" -> decode.success(RemoteObjectSubtypeArraybuffer)
"dataview" -> decode.success(RemoteObjectSubtypeDataview)
"webassemblymemory" -> decode.success(RemoteObjectSubtypeWebassemblymemory)
"wasmvalue" -> decode.success(RemoteObjectSubtypeWasmvalue)
_ -> decode.failure(RemoteObjectSubtypeArray, "valid enum property")
}
}}


@internal
pub fn encode__remote_object(
value__: RemoteObject
) {
json.object([
#("type", encode__remote_object_type(value__.type_)),
]|> utils.add_optional(value__.subtype, fn(inner_value__){#("subtype", encode__remote_object_subtype(inner_value__))})
|> utils.add_optional(value__.class_name, fn(inner_value__){#("className", json.string(inner_value__))})
|> utils.add_optional(value__.value, fn(inner_value__){#("value", utils.alert_encode_dynamic(inner_value__))})
|> utils.add_optional(value__.unserializable_value, fn(inner_value__){#("unserializableValue", encode__unserializable_value(inner_value__))})
|> utils.add_optional(value__.description, fn(inner_value__){#("description", json.string(inner_value__))})
|> utils.add_optional(value__.object_id, fn(inner_value__){#("objectId", encode__remote_object_id(inner_value__))})
)}
@internal
pub fn decode__remote_object(
) {
{
use type_ <- decode.field("type", decode__remote_object_type())
use subtype <- decode.optional_field("subtype", option.None, decode.optional(decode__remote_object_subtype()))
use class_name <- decode.optional_field("className", option.None, decode.optional(decode.string))
use value <- decode.optional_field("value", option.None, decode.dynamic |> decode.map(option.Some))
use unserializable_value <- decode.optional_field("unserializableValue", option.None, decode.optional(decode__unserializable_value()))
use description <- decode.optional_field("description", option.None, decode.optional(decode.string))
use object_id <- decode.optional_field("objectId", option.None, decode.optional(decode__remote_object_id()))

decode.success(RemoteObject(
type_:type_,
subtype:subtype,
class_name:class_name,
value:value,
unserializable_value:unserializable_value,
description:description,
object_id:object_id,
))
}}
/// Object property descriptor.
pub type PropertyDescriptor{
PropertyDescriptor (

/// Property name or symbol description.  
name: String,

/// The value associated with the property.  
value: option.Option(RemoteObject),

/// True if the value associated with the property may be changed (data descriptors only).  
writable: option.Option(Bool),

/// A function which serves as a getter for the property, or `undefined` if there is no getter
/// (accessor descriptors only).  
get: option.Option(RemoteObject),

/// A function which serves as a setter for the property, or `undefined` if there is no setter
/// (accessor descriptors only).  
set: option.Option(RemoteObject),

/// True if the type of this property descriptor may be changed and if the property may be
/// deleted from the corresponding object.  
configurable: Bool,

/// True if this property shows up during enumeration of the properties on the corresponding
/// object.  
enumerable: Bool,

/// True if the result was thrown during the evaluation.  
was_thrown: option.Option(Bool),

/// True if the property is owned for the object.  
is_own: option.Option(Bool),

/// Property symbol object, if the property is of the `symbol` type.  
symbol: option.Option(RemoteObject),
)
}


@internal
pub fn encode__property_descriptor(
value__: PropertyDescriptor
) {
json.object([
#("name", json.string(value__.name)),
#("configurable", json.bool(value__.configurable)),
#("enumerable", json.bool(value__.enumerable)),
]|> utils.add_optional(value__.value, fn(inner_value__){#("value", encode__remote_object(inner_value__))})
|> utils.add_optional(value__.writable, fn(inner_value__){#("writable", json.bool(inner_value__))})
|> utils.add_optional(value__.get, fn(inner_value__){#("get", encode__remote_object(inner_value__))})
|> utils.add_optional(value__.set, fn(inner_value__){#("set", encode__remote_object(inner_value__))})
|> utils.add_optional(value__.was_thrown, fn(inner_value__){#("wasThrown", json.bool(inner_value__))})
|> utils.add_optional(value__.is_own, fn(inner_value__){#("isOwn", json.bool(inner_value__))})
|> utils.add_optional(value__.symbol, fn(inner_value__){#("symbol", encode__remote_object(inner_value__))})
)}
@internal
pub fn decode__property_descriptor(
) {
{
use name <- decode.field("name", decode.string)
use value <- decode.optional_field("value", option.None, decode.optional(decode__remote_object()))
use writable <- decode.optional_field("writable", option.None, decode.optional(decode.bool))
use get <- decode.optional_field("get", option.None, decode.optional(decode__remote_object()))
use set <- decode.optional_field("set", option.None, decode.optional(decode__remote_object()))
use configurable <- decode.field("configurable", decode.bool)
use enumerable <- decode.field("enumerable", decode.bool)
use was_thrown <- decode.optional_field("wasThrown", option.None, decode.optional(decode.bool))
use is_own <- decode.optional_field("isOwn", option.None, decode.optional(decode.bool))
use symbol <- decode.optional_field("symbol", option.None, decode.optional(decode__remote_object()))

decode.success(PropertyDescriptor(
name:name,
value:value,
writable:writable,
get:get,
set:set,
configurable:configurable,
enumerable:enumerable,
was_thrown:was_thrown,
is_own:is_own,
symbol:symbol,
))
}}
/// Object internal property descriptor. This property isn't normally visible in JavaScript code.
pub type InternalPropertyDescriptor{
InternalPropertyDescriptor (

/// Conventional property name.  
name: String,

/// The value associated with the property.  
value: option.Option(RemoteObject),
)
}


@internal
pub fn encode__internal_property_descriptor(
value__: InternalPropertyDescriptor
) {
json.object([
#("name", json.string(value__.name)),
]|> utils.add_optional(value__.value, fn(inner_value__){#("value", encode__remote_object(inner_value__))})
)}
@internal
pub fn decode__internal_property_descriptor(
) {
{
use name <- decode.field("name", decode.string)
use value <- decode.optional_field("value", option.None, decode.optional(decode__remote_object()))

decode.success(InternalPropertyDescriptor(
name:name,
value:value,
))
}}
/// Represents function call argument. Either remote object id `objectId`, primitive `value`,
/// unserializable primitive value or neither of (for undefined) them should be specified.
pub type CallArgument{
CallArgument (

/// Primitive value or serializable javascript object.  
value: option.Option(dynamic.Dynamic),

/// Primitive value which can not be JSON-stringified.  
unserializable_value: option.Option(UnserializableValue),

/// Remote object handle.  
object_id: option.Option(RemoteObjectId),
)
}


@internal
pub fn encode__call_argument(
value__: CallArgument
) {
json.object([
]|> utils.add_optional(value__.value, fn(inner_value__){#("value", utils.alert_encode_dynamic(inner_value__))})
|> utils.add_optional(value__.unserializable_value, fn(inner_value__){#("unserializableValue", encode__unserializable_value(inner_value__))})
|> utils.add_optional(value__.object_id, fn(inner_value__){#("objectId", encode__remote_object_id(inner_value__))})
)}
@internal
pub fn decode__call_argument(
) {
{
use value <- decode.optional_field("value", option.None, decode.dynamic |> decode.map(option.Some))
use unserializable_value <- decode.optional_field("unserializableValue", option.None, decode.optional(decode__unserializable_value()))
use object_id <- decode.optional_field("objectId", option.None, decode.optional(decode__remote_object_id()))

decode.success(CallArgument(
value:value,
unserializable_value:unserializable_value,
object_id:object_id,
))
}}
/// Id of an execution context.
pub type ExecutionContextId{
ExecutionContextId(Int)
}


@internal
pub fn encode__execution_context_id(
value__: ExecutionContextId
) {
case value__{
ExecutionContextId(inner_value__) -> json.int(inner_value__)
}}
@internal
pub fn decode__execution_context_id(
) {
{
use value__ <- decode.then(decode.int)
decode.success(ExecutionContextId(value__))
}}
/// Description of an isolated world.
pub type ExecutionContextDescription{
ExecutionContextDescription (

/// Unique id of the execution context. It can be used to specify in which execution context
/// script evaluation should be performed.  
id: ExecutionContextId,

/// Execution context origin.  
origin: String,

/// Human readable name describing given context.  
name: String,

/// Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}  
aux_data: option.Option(dict.Dict(String,String)),
)
}


@internal
pub fn encode__execution_context_description(
value__: ExecutionContextDescription
) {
json.object([
#("id", encode__execution_context_id(value__.id)),
#("origin", json.string(value__.origin)),
#("name", json.string(value__.name)),
]|> utils.add_optional(value__.aux_data, fn(inner_value__){#("auxData", dict.to_list(inner_value__)
        |> list.map(fn(i) { #(i.0, json.string(i.1)) })
        |> json.object)})
)}
@internal
pub fn decode__execution_context_description(
) {
{
use id <- decode.field("id", decode__execution_context_id())
use origin <- decode.field("origin", decode.string)
use name <- decode.field("name", decode.string)
use aux_data <- decode.optional_field("auxData", option.None, decode.optional(decode.dict(decode.string, decode.string)))

decode.success(ExecutionContextDescription(
id:id,
origin:origin,
name:name,
aux_data:aux_data,
))
}}
/// Detailed information about exception (or error) that was thrown during script compilation or
/// execution.
pub type ExceptionDetails{
ExceptionDetails (

/// Exception id.  
exception_id: Int,

/// Exception text, which should be used together with exception object when available.  
text: String,

/// Line number of the exception location (0-based).  
line_number: Int,

/// Column number of the exception location (0-based).  
column_number: Int,

/// Script ID of the exception location.  
script_id: option.Option(ScriptId),

/// URL of the exception location, to be used when the script was not reported.  
url: option.Option(String),

/// JavaScript stack trace if available.  
stack_trace: option.Option(StackTrace),

/// Exception object if available.  
exception: option.Option(RemoteObject),

/// Identifier of the context where exception happened.  
execution_context_id: option.Option(ExecutionContextId),
)
}


@internal
pub fn encode__exception_details(
value__: ExceptionDetails
) {
json.object([
#("exceptionId", json.int(value__.exception_id)),
#("text", json.string(value__.text)),
#("lineNumber", json.int(value__.line_number)),
#("columnNumber", json.int(value__.column_number)),
]|> utils.add_optional(value__.script_id, fn(inner_value__){#("scriptId", encode__script_id(inner_value__))})
|> utils.add_optional(value__.url, fn(inner_value__){#("url", json.string(inner_value__))})
|> utils.add_optional(value__.stack_trace, fn(inner_value__){#("stackTrace", encode__stack_trace(inner_value__))})
|> utils.add_optional(value__.exception, fn(inner_value__){#("exception", encode__remote_object(inner_value__))})
|> utils.add_optional(value__.execution_context_id, fn(inner_value__){#("executionContextId", encode__execution_context_id(inner_value__))})
)}
@internal
pub fn decode__exception_details(
) {
{
use exception_id <- decode.field("exceptionId", decode.int)
use text <- decode.field("text", decode.string)
use line_number <- decode.field("lineNumber", decode.int)
use column_number <- decode.field("columnNumber", decode.int)
use script_id <- decode.optional_field("scriptId", option.None, decode.optional(decode__script_id()))
use url <- decode.optional_field("url", option.None, decode.optional(decode.string))
use stack_trace <- decode.optional_field("stackTrace", option.None, decode.optional(decode__stack_trace()))
use exception <- decode.optional_field("exception", option.None, decode.optional(decode__remote_object()))
use execution_context_id <- decode.optional_field("executionContextId", option.None, decode.optional(decode__execution_context_id()))

decode.success(ExceptionDetails(
exception_id:exception_id,
text:text,
line_number:line_number,
column_number:column_number,
script_id:script_id,
url:url,
stack_trace:stack_trace,
exception:exception,
execution_context_id:execution_context_id,
))
}}
/// Number of milliseconds since epoch.
pub type Timestamp{
Timestamp(Float)
}


@internal
pub fn encode__timestamp(
value__: Timestamp
) {
case value__{
Timestamp(inner_value__) -> json.float(inner_value__)
}}
@internal
pub fn decode__timestamp(
) {
{
use value__ <- decode.then(decode.float)
decode.success(Timestamp(value__))
}}
/// Number of milliseconds.
pub type TimeDelta{
TimeDelta(Float)
}


@internal
pub fn encode__time_delta(
value__: TimeDelta
) {
case value__{
TimeDelta(inner_value__) -> json.float(inner_value__)
}}
@internal
pub fn decode__time_delta(
) {
{
use value__ <- decode.then(decode.float)
decode.success(TimeDelta(value__))
}}
/// Stack entry for runtime errors and assertions.
pub type CallFrame{
CallFrame (

/// JavaScript function name.  
function_name: String,

/// JavaScript script id.  
script_id: ScriptId,

/// JavaScript script name or url.  
url: String,

/// JavaScript script line number (0-based).  
line_number: Int,

/// JavaScript script column number (0-based).  
column_number: Int,
)
}


@internal
pub fn encode__call_frame(
value__: CallFrame
) {
json.object([
#("functionName", json.string(value__.function_name)),
#("scriptId", encode__script_id(value__.script_id)),
#("url", json.string(value__.url)),
#("lineNumber", json.int(value__.line_number)),
#("columnNumber", json.int(value__.column_number)),
])}
@internal
pub fn decode__call_frame(
) {
{
use function_name <- decode.field("functionName", decode.string)
use script_id <- decode.field("scriptId", decode__script_id())
use url <- decode.field("url", decode.string)
use line_number <- decode.field("lineNumber", decode.int)
use column_number <- decode.field("columnNumber", decode.int)

decode.success(CallFrame(
function_name:function_name,
script_id:script_id,
url:url,
line_number:line_number,
column_number:column_number,
))
}}
/// Call frames for assertions or error messages.
pub type StackTrace{
StackTrace (

/// String label of this stack trace. For async traces this may be a name of the function that
/// initiated the async call.  
description: option.Option(String),

/// JavaScript function name.  
call_frames: List(CallFrame),

/// Asynchronous JavaScript stack trace that preceded this stack, if available.  
parent: option.Option(StackTrace),
)
}


@internal
pub fn encode__stack_trace(
value__: StackTrace
) {
json.object([
#("callFrames", json.array(value__.call_frames, of: encode__call_frame)),
]|> utils.add_optional(value__.description, fn(inner_value__){#("description", json.string(inner_value__))})
|> utils.add_optional(value__.parent, fn(inner_value__){#("parent", encode__stack_trace(inner_value__))})
)}
@internal
pub fn decode__stack_trace(
) {
{
use description <- decode.optional_field("description", option.None, decode.optional(decode.string))
use call_frames <- decode.field("callFrames", decode.list(decode__call_frame()))
use parent <- decode.optional_field("parent", option.None, decode.optional(decode__stack_trace()))

decode.success(StackTrace(
description:description,
call_frames:call_frames,
parent:parent,
))
}}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `await_promise`
pub type AwaitPromiseResponse{
AwaitPromiseResponse (

/// Promise result. Will contain rejected value if promise was rejected.  
result: RemoteObject,

/// Exception details if stack strace is available.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__await_promise_response(
) {
{
use result <- decode.field("result", decode__remote_object())
use exception_details <- decode.optional_field("exceptionDetails", option.None, decode.optional(decode__exception_details()))

decode.success(AwaitPromiseResponse(
result:result,
exception_details:exception_details,
))
}}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `call_function_on`
pub type CallFunctionOnResponse{
CallFunctionOnResponse (

/// Call result.  
result: RemoteObject,

/// Exception details.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__call_function_on_response(
) {
{
use result <- decode.field("result", decode__remote_object())
use exception_details <- decode.optional_field("exceptionDetails", option.None, decode.optional(decode__exception_details()))

decode.success(CallFunctionOnResponse(
result:result,
exception_details:exception_details,
))
}}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `compile_script`
pub type CompileScriptResponse{
CompileScriptResponse (

/// Id of the script.  
script_id: option.Option(ScriptId),

/// Exception details.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__compile_script_response(
) {
{
use script_id <- decode.optional_field("scriptId", option.None, decode.optional(decode__script_id()))
use exception_details <- decode.optional_field("exceptionDetails", option.None, decode.optional(decode__exception_details()))

decode.success(CompileScriptResponse(
script_id:script_id,
exception_details:exception_details,
))
}}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `evaluate`
pub type EvaluateResponse{
EvaluateResponse (

/// Evaluation result.  
result: RemoteObject,

/// Exception details.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__evaluate_response(
) {
{
use result <- decode.field("result", decode__remote_object())
use exception_details <- decode.optional_field("exceptionDetails", option.None, decode.optional(decode__exception_details()))

decode.success(EvaluateResponse(
result:result,
exception_details:exception_details,
))
}}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_properties`
pub type GetPropertiesResponse{
GetPropertiesResponse (

/// Object properties.  
result: List(PropertyDescriptor),

/// Internal object properties (only of the element itself).  
internal_properties: option.Option(List(InternalPropertyDescriptor)),

/// Exception details.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__get_properties_response(
) {
{
use result <- decode.field("result", decode.list(decode__property_descriptor()))
use internal_properties <- decode.optional_field("internalProperties", option.None, decode.optional(decode.list(decode__internal_property_descriptor())))
use exception_details <- decode.optional_field("exceptionDetails", option.None, decode.optional(decode__exception_details()))

decode.success(GetPropertiesResponse(
result:result,
internal_properties:internal_properties,
exception_details:exception_details,
))
}}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `global_lexical_scope_names`
pub type GlobalLexicalScopeNamesResponse{
GlobalLexicalScopeNamesResponse (
names: List(String),
)
}


@internal
pub fn decode__global_lexical_scope_names_response(
) {
{
use names <- decode.field("names", decode.list(decode.string))

decode.success(GlobalLexicalScopeNamesResponse(
names:names,
))
}}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `query_objects`
pub type QueryObjectsResponse{
QueryObjectsResponse (

/// Array with objects.  
objects: RemoteObject,
)
}


@internal
pub fn decode__query_objects_response(
) {
{
use objects <- decode.field("objects", decode__remote_object())

decode.success(QueryObjectsResponse(
objects:objects,
))
}}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `run_script`
pub type RunScriptResponse{
RunScriptResponse (

/// Run result.  
result: RemoteObject,

/// Exception details.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__run_script_response(
) {
{
use result <- decode.field("result", decode__remote_object())
use exception_details <- decode.optional_field("exceptionDetails", option.None, decode.optional(decode__exception_details()))

decode.success(RunScriptResponse(
result:result,
exception_details:exception_details,
))
}}
/// Add handler to promise with given promise object id.
/// 
/// Parameters:  
///  - `promise_object_id` : Identifier of the promise.
///  - `return_by_value` : Whether the result is expected to be a JSON object that should be sent by value.
///  - `generate_preview` : Whether preview should be generated for the result.
/// 
/// Returns:  
///  - `result` : Promise result. Will contain rejected value if promise was rejected.
///  - `exception_details` : Exception details if stack strace is available.
/// 
pub fn await_promise(
callback__, 
promise_object_id promise_object_id: RemoteObjectId,
return_by_value return_by_value: option.Option(Bool),
generate_preview generate_preview: option.Option(Bool),
){
use result__ <- result.try(callback__("Runtime.awaitPromise", option.Some(json.object([#("promiseObjectId", encode__remote_object_id(promise_object_id)),
]|> utils.add_optional(return_by_value, fn(inner_value__){#("returnByValue", json.bool(inner_value__))})
|> utils.add_optional(generate_preview, fn(inner_value__){#("generatePreview", json.bool(inner_value__))})
)))
)

decode.run(result__, decode__await_promise_response())
|> result.replace_error(chrome.ProtocolError)

}

/// Calls function with given declaration on the given object. Object group of the result is
/// inherited from the target object.
/// 
/// Parameters:  
///  - `function_declaration` : Declaration of the function to call.
///  - `object_id` : Identifier of the object to call function on. Either objectId or executionContextId should
/// be specified.
///  - `arguments` : Call arguments. All call arguments must belong to the same JavaScript world as the target
/// object.
///  - `silent` : In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
///  - `return_by_value` : Whether the result is expected to be a JSON object which should be sent by value.
/// Can be overriden by `serializationOptions`.
///  - `user_gesture` : Whether execution should be treated as initiated by user in the UI.
///  - `await_promise` : Whether execution should `await` for resulting value and return once awaited promise is
/// resolved.
///  - `execution_context_id` : Specifies execution context which global object will be used to call function on. Either
/// executionContextId or objectId should be specified.
///  - `object_group` : Symbolic group name that can be used to release multiple objects. If objectGroup is not
/// specified and objectId is, objectGroup will be inherited from object.
/// 
/// Returns:  
///  - `result` : Call result.
///  - `exception_details` : Exception details.
/// 
pub fn call_function_on(
callback__, 
function_declaration function_declaration: String,
object_id object_id: option.Option(RemoteObjectId),
arguments arguments: option.Option(List(CallArgument)),
silent silent: option.Option(Bool),
return_by_value return_by_value: option.Option(Bool),
user_gesture user_gesture: option.Option(Bool),
await_promise await_promise: option.Option(Bool),
execution_context_id execution_context_id: option.Option(ExecutionContextId),
object_group object_group: option.Option(String),
){
use result__ <- result.try(callback__("Runtime.callFunctionOn", option.Some(json.object([#("functionDeclaration", json.string(function_declaration)),
]|> utils.add_optional(object_id, fn(inner_value__){#("objectId", encode__remote_object_id(inner_value__))})
|> utils.add_optional(arguments, fn(inner_value__){#("arguments", json.array(inner_value__, of: encode__call_argument))})
|> utils.add_optional(silent, fn(inner_value__){#("silent", json.bool(inner_value__))})
|> utils.add_optional(return_by_value, fn(inner_value__){#("returnByValue", json.bool(inner_value__))})
|> utils.add_optional(user_gesture, fn(inner_value__){#("userGesture", json.bool(inner_value__))})
|> utils.add_optional(await_promise, fn(inner_value__){#("awaitPromise", json.bool(inner_value__))})
|> utils.add_optional(execution_context_id, fn(inner_value__){#("executionContextId", encode__execution_context_id(inner_value__))})
|> utils.add_optional(object_group, fn(inner_value__){#("objectGroup", json.string(inner_value__))})
)))
)

decode.run(result__, decode__call_function_on_response())
|> result.replace_error(chrome.ProtocolError)

}

/// Compiles expression.
/// 
/// Parameters:  
///  - `expression` : Expression to compile.
///  - `source_url` : Source url to be set for the script.
///  - `persist_script` : Specifies whether the compiled script should be persisted.
///  - `execution_context_id` : Specifies in which execution context to perform script run. If the parameter is omitted the
/// evaluation will be performed in the context of the inspected page.
/// 
/// Returns:  
///  - `script_id` : Id of the script.
///  - `exception_details` : Exception details.
/// 
pub fn compile_script(
callback__, 
expression expression: String,
source_url source_url: String,
persist_script persist_script: Bool,
execution_context_id execution_context_id: option.Option(ExecutionContextId),
){
use result__ <- result.try(callback__("Runtime.compileScript", option.Some(json.object([#("expression", json.string(expression)),
#("sourceURL", json.string(source_url)),
#("persistScript", json.bool(persist_script)),
]|> utils.add_optional(execution_context_id, fn(inner_value__){#("executionContextId", encode__execution_context_id(inner_value__))})
)))
)

decode.run(result__, decode__compile_script_response())
|> result.replace_error(chrome.ProtocolError)

}

/// Disables reporting of execution contexts creation.
/// 
pub fn disable(
callback__, 
){
callback__("Runtime.disable", option.None,)


}

/// Discards collected exceptions and console API calls.
/// 
pub fn discard_console_entries(
callback__, 
){
callback__("Runtime.discardConsoleEntries", option.None,)


}

/// Enables reporting of execution contexts creation by means of `executionContextCreated` event.
/// When the reporting gets enabled the event will be sent immediately for each existing execution
/// context.
/// 
pub fn enable(
callback__, 
){
callback__("Runtime.enable", option.None,)


}

/// Evaluates expression on global object.
/// 
/// Parameters:  
///  - `expression` : Expression to evaluate.
///  - `object_group` : Symbolic group name that can be used to release multiple objects.
///  - `include_command_line_api` : Determines whether Command Line API should be available during the evaluation.
///  - `silent` : In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
///  - `context_id` : Specifies in which execution context to perform evaluation. If the parameter is omitted the
/// evaluation will be performed in the context of the inspected page.
/// This is mutually exclusive with `uniqueContextId`, which offers an
/// alternative way to identify the execution context that is more reliable
/// in a multi-process environment.
///  - `return_by_value` : Whether the result is expected to be a JSON object that should be sent by value.
///  - `user_gesture` : Whether execution should be treated as initiated by user in the UI.
///  - `await_promise` : Whether execution should `await` for resulting value and return once awaited promise is
/// resolved.
/// 
/// Returns:  
///  - `result` : Evaluation result.
///  - `exception_details` : Exception details.
/// 
pub fn evaluate(
callback__, 
expression expression: String,
object_group object_group: option.Option(String),
include_command_line_api include_command_line_api: option.Option(Bool),
silent silent: option.Option(Bool),
context_id context_id: option.Option(ExecutionContextId),
return_by_value return_by_value: option.Option(Bool),
user_gesture user_gesture: option.Option(Bool),
await_promise await_promise: option.Option(Bool),
){
use result__ <- result.try(callback__("Runtime.evaluate", option.Some(json.object([#("expression", json.string(expression)),
]|> utils.add_optional(object_group, fn(inner_value__){#("objectGroup", json.string(inner_value__))})
|> utils.add_optional(include_command_line_api, fn(inner_value__){#("includeCommandLineAPI", json.bool(inner_value__))})
|> utils.add_optional(silent, fn(inner_value__){#("silent", json.bool(inner_value__))})
|> utils.add_optional(context_id, fn(inner_value__){#("contextId", encode__execution_context_id(inner_value__))})
|> utils.add_optional(return_by_value, fn(inner_value__){#("returnByValue", json.bool(inner_value__))})
|> utils.add_optional(user_gesture, fn(inner_value__){#("userGesture", json.bool(inner_value__))})
|> utils.add_optional(await_promise, fn(inner_value__){#("awaitPromise", json.bool(inner_value__))})
)))
)

decode.run(result__, decode__evaluate_response())
|> result.replace_error(chrome.ProtocolError)

}

/// Returns properties of a given object. Object group of the result is inherited from the target
/// object.
/// 
/// Parameters:  
///  - `object_id` : Identifier of the object to return properties for.
///  - `own_properties` : If true, returns properties belonging only to the element itself, not to its prototype
/// chain.
/// 
/// Returns:  
///  - `result` : Object properties.
///  - `internal_properties` : Internal object properties (only of the element itself).
///  - `exception_details` : Exception details.
/// 
pub fn get_properties(
callback__, 
object_id object_id: RemoteObjectId,
own_properties own_properties: option.Option(Bool),
){
use result__ <- result.try(callback__("Runtime.getProperties", option.Some(json.object([#("objectId", encode__remote_object_id(object_id)),
]|> utils.add_optional(own_properties, fn(inner_value__){#("ownProperties", json.bool(inner_value__))})
)))
)

decode.run(result__, decode__get_properties_response())
|> result.replace_error(chrome.ProtocolError)

}

/// Returns all let, const and class variables from global scope.
/// 
/// Parameters:  
///  - `execution_context_id` : Specifies in which execution context to lookup global scope variables.
/// 
/// Returns:  
///  - `names`
/// 
pub fn global_lexical_scope_names(
callback__, 
execution_context_id execution_context_id: option.Option(ExecutionContextId),
){
use result__ <- result.try(callback__("Runtime.globalLexicalScopeNames", option.Some(json.object([]|> utils.add_optional(execution_context_id, fn(inner_value__){#("executionContextId", encode__execution_context_id(inner_value__))})
)))
)

decode.run(result__, decode__global_lexical_scope_names_response())
|> result.replace_error(chrome.ProtocolError)

}

/// This generated protocol command has no description
/// 
/// Parameters:  
///  - `prototype_object_id` : Identifier of the prototype to return objects for.
///  - `object_group` : Symbolic group name that can be used to release the results.
/// 
/// Returns:  
///  - `objects` : Array with objects.
/// 
pub fn query_objects(
callback__, 
prototype_object_id prototype_object_id: RemoteObjectId,
object_group object_group: option.Option(String),
){
use result__ <- result.try(callback__("Runtime.queryObjects", option.Some(json.object([#("prototypeObjectId", encode__remote_object_id(prototype_object_id)),
]|> utils.add_optional(object_group, fn(inner_value__){#("objectGroup", json.string(inner_value__))})
)))
)

decode.run(result__, decode__query_objects_response())
|> result.replace_error(chrome.ProtocolError)

}

/// Releases remote object with given id.
/// 
/// Parameters:  
///  - `object_id` : Identifier of the object to release.
/// 
/// Returns:  
/// 
pub fn release_object(
callback__, 
object_id object_id: RemoteObjectId,
){
callback__("Runtime.releaseObject", option.Some(json.object([#("objectId", encode__remote_object_id(object_id)),
])))


}

/// Releases all remote objects that belong to a given group.
/// 
/// Parameters:  
///  - `object_group` : Symbolic object group name.
/// 
/// Returns:  
/// 
pub fn release_object_group(
callback__, 
object_group object_group: String,
){
callback__("Runtime.releaseObjectGroup", option.Some(json.object([#("objectGroup", json.string(object_group)),
])))


}

/// Tells inspected instance to run if it was waiting for debugger to attach.
/// 
pub fn run_if_waiting_for_debugger(
callback__, 
){
callback__("Runtime.runIfWaitingForDebugger", option.None,)


}

/// Runs script with given id in a given context.
/// 
/// Parameters:  
///  - `script_id` : Id of the script to run.
///  - `execution_context_id` : Specifies in which execution context to perform script run. If the parameter is omitted the
/// evaluation will be performed in the context of the inspected page.
///  - `object_group` : Symbolic group name that can be used to release multiple objects.
///  - `silent` : In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
///  - `include_command_line_api` : Determines whether Command Line API should be available during the evaluation.
///  - `return_by_value` : Whether the result is expected to be a JSON object which should be sent by value.
///  - `generate_preview` : Whether preview should be generated for the result.
///  - `await_promise` : Whether execution should `await` for resulting value and return once awaited promise is
/// resolved.
/// 
/// Returns:  
///  - `result` : Run result.
///  - `exception_details` : Exception details.
/// 
pub fn run_script(
callback__, 
script_id script_id: ScriptId,
execution_context_id execution_context_id: option.Option(ExecutionContextId),
object_group object_group: option.Option(String),
silent silent: option.Option(Bool),
include_command_line_api include_command_line_api: option.Option(Bool),
return_by_value return_by_value: option.Option(Bool),
generate_preview generate_preview: option.Option(Bool),
await_promise await_promise: option.Option(Bool),
){
use result__ <- result.try(callback__("Runtime.runScript", option.Some(json.object([#("scriptId", encode__script_id(script_id)),
]|> utils.add_optional(execution_context_id, fn(inner_value__){#("executionContextId", encode__execution_context_id(inner_value__))})
|> utils.add_optional(object_group, fn(inner_value__){#("objectGroup", json.string(inner_value__))})
|> utils.add_optional(silent, fn(inner_value__){#("silent", json.bool(inner_value__))})
|> utils.add_optional(include_command_line_api, fn(inner_value__){#("includeCommandLineAPI", json.bool(inner_value__))})
|> utils.add_optional(return_by_value, fn(inner_value__){#("returnByValue", json.bool(inner_value__))})
|> utils.add_optional(generate_preview, fn(inner_value__){#("generatePreview", json.bool(inner_value__))})
|> utils.add_optional(await_promise, fn(inner_value__){#("awaitPromise", json.bool(inner_value__))})
)))
)

decode.run(result__, decode__run_script_response())
|> result.replace_error(chrome.ProtocolError)

}

/// Enables or disables async call stacks tracking.
/// 
/// Parameters:  
///  - `max_depth` : Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
/// call stacks (default).
/// 
/// Returns:  
/// 
pub fn set_async_call_stack_depth(
callback__, 
max_depth max_depth: Int,
){
callback__("Runtime.setAsyncCallStackDepth", option.Some(json.object([#("maxDepth", json.int(max_depth)),
])))


}

/// If executionContextId is empty, adds binding with the given name on the
/// global objects of all inspected contexts, including those created later,
/// bindings survive reloads.
/// Binding function takes exactly one argument, this argument should be string,
/// in case of any other input, function throws an exception.
/// Each binding function call produces Runtime.bindingCalled notification.
/// 
/// Parameters:  
///  - `name`
///  - `execution_context_name` : If specified, the binding is exposed to the executionContext with
/// matching name, even for contexts created after the binding is added.
/// See also `ExecutionContext.name` and `worldName` parameter to
/// `Page.addScriptToEvaluateOnNewDocument`.
/// This parameter is mutually exclusive with `executionContextId`.
/// 
/// Returns:  
/// 
pub fn add_binding(
callback__, 
name name: String,
execution_context_name execution_context_name: option.Option(String),
){
callback__("Runtime.addBinding", option.Some(json.object([#("name", json.string(name)),
]|> utils.add_optional(execution_context_name, fn(inner_value__){#("executionContextName", json.string(inner_value__))})
)))


}

/// This method does not remove binding function from global object but
/// unsubscribes current runtime agent from Runtime.bindingCalled notifications.
/// 
/// Parameters:  
///  - `name`
/// 
/// Returns:  
/// 
pub fn remove_binding(
callback__, 
name name: String,
){
callback__("Runtime.removeBinding", option.Some(json.object([#("name", json.string(name)),
])))


}


