---
version: 1.2.6
title: Runtime domain module
file: ./test/codegen/generate_bindings_test.gleam
test_name: gen_bindings_runtime_test
---

// ---------------------------------------------------------------------------
// |  !!!!!!   This is an autogenerated file - Do not edit manually  !!!!!!  |
// |                     Run `codegen.sh` to regenerate.                     |
// ---------------------------------------------------------------------------
//// > âš™ï¸  This module was generated from the Chrome DevTools Protocol version **1.3**
//// ## Runtime Domain  
////
//// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
//// Evaluation results are returned as mirror object that expose object type, string representation
//// and unique identifier that can be used for further object reference. Original objects are
//// maintained in memory unless they are either explicitly released or are released along with the
//// other objects in their object group.  
////
//// [ðŸ“–   View this domain on the DevTools Protocol API Docs](https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/)

import chrobot/chrome
import gleam/dict
import gleam/list
import gleam/dynamic
import gleam/result
import gleam/option
import gleam/json
import chrobot/internal/utils


/// Unique script identifier.
pub type ScriptId{
ScriptId(String)
}


@internal
pub fn encode__script_id(
value__: ScriptId
) {
case value__{
ScriptId(inner_value__) -> json.string(inner_value__)
}}
@internal
pub fn decode__script_id(
value__: dynamic.Dynamic) {
value__ |> dynamic.decode1(ScriptId, dynamic.string)}
/// Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
pub type SerializationOptions{
SerializationOptions (
serialization: SerializationOptionsSerialization,

/// Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.  
max_depth: option.Option(Int),

/// Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM
/// serialization via `maxNodeDepth: integer` and `includeShadowTree: "none" | "open" | "all"`.
/// Values can be only of type string or integer.  
additional_parameters: option.Option(dict.Dict(String,String)),
)
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `serialization` of `SerializationOptions`

pub type SerializationOptionsSerialization{SerializationOptionsSerializationDeep
SerializationOptionsSerializationJson
SerializationOptionsSerializationIdOnly
}
@internal
pub fn encode__serialization_options_serialization(
value__: SerializationOptionsSerialization
) {
case value__{
SerializationOptionsSerializationDeep -> "deep"
SerializationOptionsSerializationJson -> "json"
SerializationOptionsSerializationIdOnly -> "idOnly"
}
|> json.string()
}

@internal
pub fn decode__serialization_options_serialization(
value__: dynamic.Dynamic
) {
case dynamic.string(value__){
Ok("deep") -> Ok(SerializationOptionsSerializationDeep)
Ok("json") -> Ok(SerializationOptionsSerializationJson)
Ok("idOnly") -> Ok(SerializationOptionsSerializationIdOnly)
Error(error) -> Error(error)
Ok(other) -> Error([dynamic.DecodeError(expected: "valid enum property", found:other, path: ["enum decoder"])])}
}


@internal
pub fn encode__serialization_options(
value__: SerializationOptions
) {
json.object([
#("serialization", encode__serialization_options_serialization(value__.serialization)),
]|> utils.add_optional(value__.max_depth, fn(inner_value__){#("maxDepth", json.int(inner_value__))})
|> utils.add_optional(value__.additional_parameters, fn(inner_value__){#("additionalParameters", dict.to_list(inner_value__)
        |> list.map(fn(i) { #(i.0, json.string(i.1)) })
        |> json.object)})
)}
@internal
pub fn decode__serialization_options(
value__: dynamic.Dynamic) {
use serialization <- result.try(dynamic.field("serialization",decode__serialization_options_serialization)(value__))
use max_depth <- result.try(dynamic.optional_field("maxDepth",dynamic.int)(value__))
use additional_parameters <- result.try(dynamic.optional_field("additionalParameters",dynamic.dict(dynamic.string, dynamic.string))(value__))

Ok(SerializationOptions(
serialization:serialization,
max_depth:max_depth,
additional_parameters:additional_parameters,
))}
/// Represents deep serialized value.
pub type DeepSerializedValue{
DeepSerializedValue (
type_: DeepSerializedValueType,
value: option.Option(dynamic.Dynamic),
object_id: option.Option(String),

/// Set if value reference met more then once during serialization. In such
/// case, value is provided only to one of the serialized values. Unique
/// per value in the scope of one CDP call.  
weak_local_object_reference: option.Option(Int),
)
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `DeepSerializedValue`

pub type DeepSerializedValueType{DeepSerializedValueTypeUndefined
DeepSerializedValueTypeNull
DeepSerializedValueTypeString
DeepSerializedValueTypeNumber
DeepSerializedValueTypeBoolean
DeepSerializedValueTypeBigint
DeepSerializedValueTypeRegexp
DeepSerializedValueTypeDate
DeepSerializedValueTypeSymbol
DeepSerializedValueTypeArray
DeepSerializedValueTypeObject
DeepSerializedValueTypeFunction
DeepSerializedValueTypeMap
DeepSerializedValueTypeSet
DeepSerializedValueTypeWeakmap
DeepSerializedValueTypeWeakset
DeepSerializedValueTypeError
DeepSerializedValueTypeProxy
DeepSerializedValueTypePromise
DeepSerializedValueTypeTypedarray
DeepSerializedValueTypeArraybuffer
DeepSerializedValueTypeNode
DeepSerializedValueTypeWindow
DeepSerializedValueTypeGenerator
}
@internal
pub fn encode__deep_serialized_value_type(
value__: DeepSerializedValueType
) {
case value__{
DeepSerializedValueTypeUndefined -> "undefined"
DeepSerializedValueTypeNull -> "null"
DeepSerializedValueTypeString -> "string"
DeepSerializedValueTypeNumber -> "number"
DeepSerializedValueTypeBoolean -> "boolean"
DeepSerializedValueTypeBigint -> "bigint"
DeepSerializedValueTypeRegexp -> "regexp"
DeepSerializedValueTypeDate -> "date"
DeepSerializedValueTypeSymbol -> "symbol"
DeepSerializedValueTypeArray -> "array"
DeepSerializedValueTypeObject -> "object"
DeepSerializedValueTypeFunction -> "function"
DeepSerializedValueTypeMap -> "map"
DeepSerializedValueTypeSet -> "set"
DeepSerializedValueTypeWeakmap -> "weakmap"
DeepSerializedValueTypeWeakset -> "weakset"
DeepSerializedValueTypeError -> "error"
DeepSerializedValueTypeProxy -> "proxy"
DeepSerializedValueTypePromise -> "promise"
DeepSerializedValueTypeTypedarray -> "typedarray"
DeepSerializedValueTypeArraybuffer -> "arraybuffer"
DeepSerializedValueTypeNode -> "node"
DeepSerializedValueTypeWindow -> "window"
DeepSerializedValueTypeGenerator -> "generator"
}
|> json.string()
}

@internal
pub fn decode__deep_serialized_value_type(
value__: dynamic.Dynamic
) {
case dynamic.string(value__){
Ok("undefined") -> Ok(DeepSerializedValueTypeUndefined)
Ok("null") -> Ok(DeepSerializedValueTypeNull)
Ok("string") -> Ok(DeepSerializedValueTypeString)
Ok("number") -> Ok(DeepSerializedValueTypeNumber)
Ok("boolean") -> Ok(DeepSerializedValueTypeBoolean)
Ok("bigint") -> Ok(DeepSerializedValueTypeBigint)
Ok("regexp") -> Ok(DeepSerializedValueTypeRegexp)
Ok("date") -> Ok(DeepSerializedValueTypeDate)
Ok("symbol") -> Ok(DeepSerializedValueTypeSymbol)
Ok("array") -> Ok(DeepSerializedValueTypeArray)
Ok("object") -> Ok(DeepSerializedValueTypeObject)
Ok("function") -> Ok(DeepSerializedValueTypeFunction)
Ok("map") -> Ok(DeepSerializedValueTypeMap)
Ok("set") -> Ok(DeepSerializedValueTypeSet)
Ok("weakmap") -> Ok(DeepSerializedValueTypeWeakmap)
Ok("weakset") -> Ok(DeepSerializedValueTypeWeakset)
Ok("error") -> Ok(DeepSerializedValueTypeError)
Ok("proxy") -> Ok(DeepSerializedValueTypeProxy)
Ok("promise") -> Ok(DeepSerializedValueTypePromise)
Ok("typedarray") -> Ok(DeepSerializedValueTypeTypedarray)
Ok("arraybuffer") -> Ok(DeepSerializedValueTypeArraybuffer)
Ok("node") -> Ok(DeepSerializedValueTypeNode)
Ok("window") -> Ok(DeepSerializedValueTypeWindow)
Ok("generator") -> Ok(DeepSerializedValueTypeGenerator)
Error(error) -> Error(error)
Ok(other) -> Error([dynamic.DecodeError(expected: "valid enum property", found:other, path: ["enum decoder"])])}
}


@internal
pub fn encode__deep_serialized_value(
value__: DeepSerializedValue
) {
json.object([
#("type", encode__deep_serialized_value_type(value__.type_)),
]|> utils.add_optional(value__.value, fn(inner_value__){#("value", utils.alert_encode_dynamic(inner_value__))})
|> utils.add_optional(value__.object_id, fn(inner_value__){#("objectId", json.string(inner_value__))})
|> utils.add_optional(value__.weak_local_object_reference, fn(inner_value__){#("weakLocalObjectReference", json.int(inner_value__))})
)}
@internal
pub fn decode__deep_serialized_value(
value__: dynamic.Dynamic) {
use type_ <- result.try(dynamic.field("type",decode__deep_serialized_value_type)(value__))
use value <- result.try(dynamic.optional_field("value",dynamic.dynamic)(value__))
use object_id <- result.try(dynamic.optional_field("objectId",dynamic.string)(value__))
use weak_local_object_reference <- result.try(dynamic.optional_field("weakLocalObjectReference",dynamic.int)(value__))

Ok(DeepSerializedValue(
type_:type_,
value:value,
object_id:object_id,
weak_local_object_reference:weak_local_object_reference,
))}
/// Unique object identifier.
pub type RemoteObjectId{
RemoteObjectId(String)
}


@internal
pub fn encode__remote_object_id(
value__: RemoteObjectId
) {
case value__{
RemoteObjectId(inner_value__) -> json.string(inner_value__)
}}
@internal
pub fn decode__remote_object_id(
value__: dynamic.Dynamic) {
value__ |> dynamic.decode1(RemoteObjectId, dynamic.string)}
/// Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
/// `-Infinity`, and bigint literals.
pub type UnserializableValue{
UnserializableValue(String)
}


@internal
pub fn encode__unserializable_value(
value__: UnserializableValue
) {
case value__{
UnserializableValue(inner_value__) -> json.string(inner_value__)
}}
@internal
pub fn decode__unserializable_value(
value__: dynamic.Dynamic) {
value__ |> dynamic.decode1(UnserializableValue, dynamic.string)}
/// Mirror object referencing original JavaScript object.
pub type RemoteObject{
RemoteObject (

/// Object type.  
type_: RemoteObjectType,

/// Object subtype hint. Specified for `object` type values only.
/// NOTE: If you change anything here, make sure to also update
/// `subtype` in `ObjectPreview` and `PropertyPreview` below.  
subtype: option.Option(RemoteObjectSubtype),

/// Object class (constructor) name. Specified for `object` type values only.  
class_name: option.Option(String),

/// Remote object value in case of primitive values or JSON values (if it was requested).  
value: option.Option(dynamic.Dynamic),

/// Primitive value which can not be JSON-stringified does not have `value`, but gets this
/// property.  
unserializable_value: option.Option(UnserializableValue),

/// String representation of the object.  
description: option.Option(String),

/// Unique object identifier (for non-primitive values).  
object_id: option.Option(RemoteObjectId),
)
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `type` of `RemoteObject`

pub type RemoteObjectType{RemoteObjectTypeObject
RemoteObjectTypeFunction
RemoteObjectTypeUndefined
RemoteObjectTypeString
RemoteObjectTypeNumber
RemoteObjectTypeBoolean
RemoteObjectTypeSymbol
RemoteObjectTypeBigint
}
@internal
pub fn encode__remote_object_type(
value__: RemoteObjectType
) {
case value__{
RemoteObjectTypeObject -> "object"
RemoteObjectTypeFunction -> "function"
RemoteObjectTypeUndefined -> "undefined"
RemoteObjectTypeString -> "string"
RemoteObjectTypeNumber -> "number"
RemoteObjectTypeBoolean -> "boolean"
RemoteObjectTypeSymbol -> "symbol"
RemoteObjectTypeBigint -> "bigint"
}
|> json.string()
}

@internal
pub fn decode__remote_object_type(
value__: dynamic.Dynamic
) {
case dynamic.string(value__){
Ok("object") -> Ok(RemoteObjectTypeObject)
Ok("function") -> Ok(RemoteObjectTypeFunction)
Ok("undefined") -> Ok(RemoteObjectTypeUndefined)
Ok("string") -> Ok(RemoteObjectTypeString)
Ok("number") -> Ok(RemoteObjectTypeNumber)
Ok("boolean") -> Ok(RemoteObjectTypeBoolean)
Ok("symbol") -> Ok(RemoteObjectTypeSymbol)
Ok("bigint") -> Ok(RemoteObjectTypeBigint)
Error(error) -> Error(error)
Ok(other) -> Error([dynamic.DecodeError(expected: "valid enum property", found:other, path: ["enum decoder"])])}
}

/// This type is not part of the protocol spec, it has been generated dynamically 
/// to represent the possible values of the enum property `subtype` of `RemoteObject`

pub type RemoteObjectSubtype{RemoteObjectSubtypeArray
RemoteObjectSubtypeNull
RemoteObjectSubtypeNode
RemoteObjectSubtypeRegexp
RemoteObjectSubtypeDate
RemoteObjectSubtypeMap
RemoteObjectSubtypeSet
RemoteObjectSubtypeWeakmap
RemoteObjectSubtypeWeakset
RemoteObjectSubtypeIterator
RemoteObjectSubtypeGenerator
RemoteObjectSubtypeError
RemoteObjectSubtypeProxy
RemoteObjectSubtypePromise
RemoteObjectSubtypeTypedarray
RemoteObjectSubtypeArraybuffer
RemoteObjectSubtypeDataview
RemoteObjectSubtypeWebassemblymemory
RemoteObjectSubtypeWasmvalue
}
@internal
pub fn encode__remote_object_subtype(
value__: RemoteObjectSubtype
) {
case value__{
RemoteObjectSubtypeArray -> "array"
RemoteObjectSubtypeNull -> "null"
RemoteObjectSubtypeNode -> "node"
RemoteObjectSubtypeRegexp -> "regexp"
RemoteObjectSubtypeDate -> "date"
RemoteObjectSubtypeMap -> "map"
RemoteObjectSubtypeSet -> "set"
RemoteObjectSubtypeWeakmap -> "weakmap"
RemoteObjectSubtypeWeakset -> "weakset"
RemoteObjectSubtypeIterator -> "iterator"
RemoteObjectSubtypeGenerator -> "generator"
RemoteObjectSubtypeError -> "error"
RemoteObjectSubtypeProxy -> "proxy"
RemoteObjectSubtypePromise -> "promise"
RemoteObjectSubtypeTypedarray -> "typedarray"
RemoteObjectSubtypeArraybuffer -> "arraybuffer"
RemoteObjectSubtypeDataview -> "dataview"
RemoteObjectSubtypeWebassemblymemory -> "webassemblymemory"
RemoteObjectSubtypeWasmvalue -> "wasmvalue"
}
|> json.string()
}

@internal
pub fn decode__remote_object_subtype(
value__: dynamic.Dynamic
) {
case dynamic.string(value__){
Ok("array") -> Ok(RemoteObjectSubtypeArray)
Ok("null") -> Ok(RemoteObjectSubtypeNull)
Ok("node") -> Ok(RemoteObjectSubtypeNode)
Ok("regexp") -> Ok(RemoteObjectSubtypeRegexp)
Ok("date") -> Ok(RemoteObjectSubtypeDate)
Ok("map") -> Ok(RemoteObjectSubtypeMap)
Ok("set") -> Ok(RemoteObjectSubtypeSet)
Ok("weakmap") -> Ok(RemoteObjectSubtypeWeakmap)
Ok("weakset") -> Ok(RemoteObjectSubtypeWeakset)
Ok("iterator") -> Ok(RemoteObjectSubtypeIterator)
Ok("generator") -> Ok(RemoteObjectSubtypeGenerator)
Ok("error") -> Ok(RemoteObjectSubtypeError)
Ok("proxy") -> Ok(RemoteObjectSubtypeProxy)
Ok("promise") -> Ok(RemoteObjectSubtypePromise)
Ok("typedarray") -> Ok(RemoteObjectSubtypeTypedarray)
Ok("arraybuffer") -> Ok(RemoteObjectSubtypeArraybuffer)
Ok("dataview") -> Ok(RemoteObjectSubtypeDataview)
Ok("webassemblymemory") -> Ok(RemoteObjectSubtypeWebassemblymemory)
Ok("wasmvalue") -> Ok(RemoteObjectSubtypeWasmvalue)
Error(error) -> Error(error)
Ok(other) -> Error([dynamic.DecodeError(expected: "valid enum property", found:other, path: ["enum decoder"])])}
}


@internal
pub fn encode__remote_object(
value__: RemoteObject
) {
json.object([
#("type", encode__remote_object_type(value__.type_)),
]|> utils.add_optional(value__.subtype, fn(inner_value__){#("subtype", encode__remote_object_subtype(inner_value__))})
|> utils.add_optional(value__.class_name, fn(inner_value__){#("className", json.string(inner_value__))})
|> utils.add_optional(value__.value, fn(inner_value__){#("value", utils.alert_encode_dynamic(inner_value__))})
|> utils.add_optional(value__.unserializable_value, fn(inner_value__){#("unserializableValue", encode__unserializable_value(inner_value__))})
|> utils.add_optional(value__.description, fn(inner_value__){#("description", json.string(inner_value__))})
|> utils.add_optional(value__.object_id, fn(inner_value__){#("objectId", encode__remote_object_id(inner_value__))})
)}
@internal
pub fn decode__remote_object(
value__: dynamic.Dynamic) {
use type_ <- result.try(dynamic.field("type",decode__remote_object_type)(value__))
use subtype <- result.try(dynamic.optional_field("subtype",decode__remote_object_subtype)(value__))
use class_name <- result.try(dynamic.optional_field("className",dynamic.string)(value__))
use value <- result.try(dynamic.optional_field("value",dynamic.dynamic)(value__))
use unserializable_value <- result.try(dynamic.optional_field("unserializableValue",decode__unserializable_value)(value__))
use description <- result.try(dynamic.optional_field("description",dynamic.string)(value__))
use object_id <- result.try(dynamic.optional_field("objectId",decode__remote_object_id)(value__))

Ok(RemoteObject(
type_:type_,
subtype:subtype,
class_name:class_name,
value:value,
unserializable_value:unserializable_value,
description:description,
object_id:object_id,
))}
/// Object property descriptor.
pub type PropertyDescriptor{
PropertyDescriptor (

/// Property name or symbol description.  
name: String,

/// The value associated with the property.  
value: option.Option(RemoteObject),

/// True if the value associated with the property may be changed (data descriptors only).  
writable: option.Option(Bool),

/// A function which serves as a getter for the property, or `undefined` if there is no getter
/// (accessor descriptors only).  
get: option.Option(RemoteObject),

/// A function which serves as a setter for the property, or `undefined` if there is no setter
/// (accessor descriptors only).  
set: option.Option(RemoteObject),

/// True if the type of this property descriptor may be changed and if the property may be
/// deleted from the corresponding object.  
configurable: Bool,

/// True if this property shows up during enumeration of the properties on the corresponding
/// object.  
enumerable: Bool,

/// True if the result was thrown during the evaluation.  
was_thrown: option.Option(Bool),

/// True if the property is owned for the object.  
is_own: option.Option(Bool),

/// Property symbol object, if the property is of the `symbol` type.  
symbol: option.Option(RemoteObject),
)
}


@internal
pub fn encode__property_descriptor(
value__: PropertyDescriptor
) {
json.object([
#("name", json.string(value__.name)),
#("configurable", json.bool(value__.configurable)),
#("enumerable", json.bool(value__.enumerable)),
]|> utils.add_optional(value__.value, fn(inner_value__){#("value", encode__remote_object(inner_value__))})
|> utils.add_optional(value__.writable, fn(inner_value__){#("writable", json.bool(inner_value__))})
|> utils.add_optional(value__.get, fn(inner_value__){#("get", encode__remote_object(inner_value__))})
|> utils.add_optional(value__.set, fn(inner_value__){#("set", encode__remote_object(inner_value__))})
|> utils.add_optional(value__.was_thrown, fn(inner_value__){#("wasThrown", json.bool(inner_value__))})
|> utils.add_optional(value__.is_own, fn(inner_value__){#("isOwn", json.bool(inner_value__))})
|> utils.add_optional(value__.symbol, fn(inner_value__){#("symbol", encode__remote_object(inner_value__))})
)}
@internal
pub fn decode__property_descriptor(
value__: dynamic.Dynamic) {
use name <- result.try(dynamic.field("name",dynamic.string)(value__))
use value <- result.try(dynamic.optional_field("value",decode__remote_object)(value__))
use writable <- result.try(dynamic.optional_field("writable",dynamic.bool)(value__))
use get <- result.try(dynamic.optional_field("get",decode__remote_object)(value__))
use set <- result.try(dynamic.optional_field("set",decode__remote_object)(value__))
use configurable <- result.try(dynamic.field("configurable",dynamic.bool)(value__))
use enumerable <- result.try(dynamic.field("enumerable",dynamic.bool)(value__))
use was_thrown <- result.try(dynamic.optional_field("wasThrown",dynamic.bool)(value__))
use is_own <- result.try(dynamic.optional_field("isOwn",dynamic.bool)(value__))
use symbol <- result.try(dynamic.optional_field("symbol",decode__remote_object)(value__))

Ok(PropertyDescriptor(
name:name,
value:value,
writable:writable,
get:get,
set:set,
configurable:configurable,
enumerable:enumerable,
was_thrown:was_thrown,
is_own:is_own,
symbol:symbol,
))}
/// Object internal property descriptor. This property isn't normally visible in JavaScript code.
pub type InternalPropertyDescriptor{
InternalPropertyDescriptor (

/// Conventional property name.  
name: String,

/// The value associated with the property.  
value: option.Option(RemoteObject),
)
}


@internal
pub fn encode__internal_property_descriptor(
value__: InternalPropertyDescriptor
) {
json.object([
#("name", json.string(value__.name)),
]|> utils.add_optional(value__.value, fn(inner_value__){#("value", encode__remote_object(inner_value__))})
)}
@internal
pub fn decode__internal_property_descriptor(
value__: dynamic.Dynamic) {
use name <- result.try(dynamic.field("name",dynamic.string)(value__))
use value <- result.try(dynamic.optional_field("value",decode__remote_object)(value__))

Ok(InternalPropertyDescriptor(
name:name,
value:value,
))}
/// Represents function call argument. Either remote object id `objectId`, primitive `value`,
/// unserializable primitive value or neither of (for undefined) them should be specified.
pub type CallArgument{
CallArgument (

/// Primitive value or serializable javascript object.  
value: option.Option(dynamic.Dynamic),

/// Primitive value which can not be JSON-stringified.  
unserializable_value: option.Option(UnserializableValue),

/// Remote object handle.  
object_id: option.Option(RemoteObjectId),
)
}


@internal
pub fn encode__call_argument(
value__: CallArgument
) {
json.object([
]|> utils.add_optional(value__.value, fn(inner_value__){#("value", utils.alert_encode_dynamic(inner_value__))})
|> utils.add_optional(value__.unserializable_value, fn(inner_value__){#("unserializableValue", encode__unserializable_value(inner_value__))})
|> utils.add_optional(value__.object_id, fn(inner_value__){#("objectId", encode__remote_object_id(inner_value__))})
)}
@internal
pub fn decode__call_argument(
value__: dynamic.Dynamic) {
use value <- result.try(dynamic.optional_field("value",dynamic.dynamic)(value__))
use unserializable_value <- result.try(dynamic.optional_field("unserializableValue",decode__unserializable_value)(value__))
use object_id <- result.try(dynamic.optional_field("objectId",decode__remote_object_id)(value__))

Ok(CallArgument(
value:value,
unserializable_value:unserializable_value,
object_id:object_id,
))}
/// Id of an execution context.
pub type ExecutionContextId{
ExecutionContextId(Int)
}


@internal
pub fn encode__execution_context_id(
value__: ExecutionContextId
) {
case value__{
ExecutionContextId(inner_value__) -> json.int(inner_value__)
}}
@internal
pub fn decode__execution_context_id(
value__: dynamic.Dynamic) {
value__ |> dynamic.decode1(ExecutionContextId, dynamic.int)}
/// Description of an isolated world.
pub type ExecutionContextDescription{
ExecutionContextDescription (

/// Unique id of the execution context. It can be used to specify in which execution context
/// script evaluation should be performed.  
id: ExecutionContextId,

/// Execution context origin.  
origin: String,

/// Human readable name describing given context.  
name: String,

/// Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}  
aux_data: option.Option(dict.Dict(String,String)),
)
}


@internal
pub fn encode__execution_context_description(
value__: ExecutionContextDescription
) {
json.object([
#("id", encode__execution_context_id(value__.id)),
#("origin", json.string(value__.origin)),
#("name", json.string(value__.name)),
]|> utils.add_optional(value__.aux_data, fn(inner_value__){#("auxData", dict.to_list(inner_value__)
        |> list.map(fn(i) { #(i.0, json.string(i.1)) })
        |> json.object)})
)}
@internal
pub fn decode__execution_context_description(
value__: dynamic.Dynamic) {
use id <- result.try(dynamic.field("id",decode__execution_context_id)(value__))
use origin <- result.try(dynamic.field("origin",dynamic.string)(value__))
use name <- result.try(dynamic.field("name",dynamic.string)(value__))
use aux_data <- result.try(dynamic.optional_field("auxData",dynamic.dict(dynamic.string, dynamic.string))(value__))

Ok(ExecutionContextDescription(
id:id,
origin:origin,
name:name,
aux_data:aux_data,
))}
/// Detailed information about exception (or error) that was thrown during script compilation or
/// execution.
pub type ExceptionDetails{
ExceptionDetails (

/// Exception id.  
exception_id: Int,

/// Exception text, which should be used together with exception object when available.  
text: String,

/// Line number of the exception location (0-based).  
line_number: Int,

/// Column number of the exception location (0-based).  
column_number: Int,

/// Script ID of the exception location.  
script_id: option.Option(ScriptId),

/// URL of the exception location, to be used when the script was not reported.  
url: option.Option(String),

/// JavaScript stack trace if available.  
stack_trace: option.Option(StackTrace),

/// Exception object if available.  
exception: option.Option(RemoteObject),

/// Identifier of the context where exception happened.  
execution_context_id: option.Option(ExecutionContextId),
)
}


@internal
pub fn encode__exception_details(
value__: ExceptionDetails
) {
json.object([
#("exceptionId", json.int(value__.exception_id)),
#("text", json.string(value__.text)),
#("lineNumber", json.int(value__.line_number)),
#("columnNumber", json.int(value__.column_number)),
]|> utils.add_optional(value__.script_id, fn(inner_value__){#("scriptId", encode__script_id(inner_value__))})
|> utils.add_optional(value__.url, fn(inner_value__){#("url", json.string(inner_value__))})
|> utils.add_optional(value__.stack_trace, fn(inner_value__){#("stackTrace", encode__stack_trace(inner_value__))})
|> utils.add_optional(value__.exception, fn(inner_value__){#("exception", encode__remote_object(inner_value__))})
|> utils.add_optional(value__.execution_context_id, fn(inner_value__){#("executionContextId", encode__execution_context_id(inner_value__))})
)}
@internal
pub fn decode__exception_details(
value__: dynamic.Dynamic) {
use exception_id <- result.try(dynamic.field("exceptionId",dynamic.int)(value__))
use text <- result.try(dynamic.field("text",dynamic.string)(value__))
use line_number <- result.try(dynamic.field("lineNumber",dynamic.int)(value__))
use column_number <- result.try(dynamic.field("columnNumber",dynamic.int)(value__))
use script_id <- result.try(dynamic.optional_field("scriptId",decode__script_id)(value__))
use url <- result.try(dynamic.optional_field("url",dynamic.string)(value__))
use stack_trace <- result.try(dynamic.optional_field("stackTrace",decode__stack_trace)(value__))
use exception <- result.try(dynamic.optional_field("exception",decode__remote_object)(value__))
use execution_context_id <- result.try(dynamic.optional_field("executionContextId",decode__execution_context_id)(value__))

Ok(ExceptionDetails(
exception_id:exception_id,
text:text,
line_number:line_number,
column_number:column_number,
script_id:script_id,
url:url,
stack_trace:stack_trace,
exception:exception,
execution_context_id:execution_context_id,
))}
/// Number of milliseconds since epoch.
pub type Timestamp{
Timestamp(Float)
}


@internal
pub fn encode__timestamp(
value__: Timestamp
) {
case value__{
Timestamp(inner_value__) -> json.float(inner_value__)
}}
@internal
pub fn decode__timestamp(
value__: dynamic.Dynamic) {
value__ |> dynamic.decode1(Timestamp, dynamic.float)}
/// Number of milliseconds.
pub type TimeDelta{
TimeDelta(Float)
}


@internal
pub fn encode__time_delta(
value__: TimeDelta
) {
case value__{
TimeDelta(inner_value__) -> json.float(inner_value__)
}}
@internal
pub fn decode__time_delta(
value__: dynamic.Dynamic) {
value__ |> dynamic.decode1(TimeDelta, dynamic.float)}
/// Stack entry for runtime errors and assertions.
pub type CallFrame{
CallFrame (

/// JavaScript function name.  
function_name: String,

/// JavaScript script id.  
script_id: ScriptId,

/// JavaScript script name or url.  
url: String,

/// JavaScript script line number (0-based).  
line_number: Int,

/// JavaScript script column number (0-based).  
column_number: Int,
)
}


@internal
pub fn encode__call_frame(
value__: CallFrame
) {
json.object([
#("functionName", json.string(value__.function_name)),
#("scriptId", encode__script_id(value__.script_id)),
#("url", json.string(value__.url)),
#("lineNumber", json.int(value__.line_number)),
#("columnNumber", json.int(value__.column_number)),
])}
@internal
pub fn decode__call_frame(
value__: dynamic.Dynamic) {
use function_name <- result.try(dynamic.field("functionName",dynamic.string)(value__))
use script_id <- result.try(dynamic.field("scriptId",decode__script_id)(value__))
use url <- result.try(dynamic.field("url",dynamic.string)(value__))
use line_number <- result.try(dynamic.field("lineNumber",dynamic.int)(value__))
use column_number <- result.try(dynamic.field("columnNumber",dynamic.int)(value__))

Ok(CallFrame(
function_name:function_name,
script_id:script_id,
url:url,
line_number:line_number,
column_number:column_number,
))}
/// Call frames for assertions or error messages.
pub type StackTrace{
StackTrace (

/// String label of this stack trace. For async traces this may be a name of the function that
/// initiated the async call.  
description: option.Option(String),

/// JavaScript function name.  
call_frames: List(CallFrame),

/// Asynchronous JavaScript stack trace that preceded this stack, if available.  
parent: option.Option(StackTrace),
)
}


@internal
pub fn encode__stack_trace(
value__: StackTrace
) {
json.object([
#("callFrames", json.array(value__.call_frames, of: encode__call_frame)),
]|> utils.add_optional(value__.description, fn(inner_value__){#("description", json.string(inner_value__))})
|> utils.add_optional(value__.parent, fn(inner_value__){#("parent", encode__stack_trace(inner_value__))})
)}
@internal
pub fn decode__stack_trace(
value__: dynamic.Dynamic) {
use description <- result.try(dynamic.optional_field("description",dynamic.string)(value__))
use call_frames <- result.try(dynamic.field("callFrames",dynamic.list(decode__call_frame))(value__))
use parent <- result.try(dynamic.optional_field("parent",decode__stack_trace)(value__))

Ok(StackTrace(
description:description,
call_frames:call_frames,
parent:parent,
))}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `await_promise`
pub type AwaitPromiseResponse{
AwaitPromiseResponse (

/// Promise result. Will contain rejected value if promise was rejected.  
result: RemoteObject,

/// Exception details if stack strace is available.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__await_promise_response(
value__: dynamic.Dynamic) {
use result <- result.try(dynamic.field("result",decode__remote_object)(value__))
use exception_details <- result.try(dynamic.optional_field("exceptionDetails",decode__exception_details)(value__))

Ok(AwaitPromiseResponse(
result:result,
exception_details:exception_details,
))}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `call_function_on`
pub type CallFunctionOnResponse{
CallFunctionOnResponse (

/// Call result.  
result: RemoteObject,

/// Exception details.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__call_function_on_response(
value__: dynamic.Dynamic) {
use result <- result.try(dynamic.field("result",decode__remote_object)(value__))
use exception_details <- result.try(dynamic.optional_field("exceptionDetails",decode__exception_details)(value__))

Ok(CallFunctionOnResponse(
result:result,
exception_details:exception_details,
))}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `compile_script`
pub type CompileScriptResponse{
CompileScriptResponse (

/// Id of the script.  
script_id: option.Option(ScriptId),

/// Exception details.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__compile_script_response(
value__: dynamic.Dynamic) {
use script_id <- result.try(dynamic.optional_field("scriptId",decode__script_id)(value__))
use exception_details <- result.try(dynamic.optional_field("exceptionDetails",decode__exception_details)(value__))

Ok(CompileScriptResponse(
script_id:script_id,
exception_details:exception_details,
))}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `evaluate`
pub type EvaluateResponse{
EvaluateResponse (

/// Evaluation result.  
result: RemoteObject,

/// Exception details.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__evaluate_response(
value__: dynamic.Dynamic) {
use result <- result.try(dynamic.field("result",decode__remote_object)(value__))
use exception_details <- result.try(dynamic.optional_field("exceptionDetails",decode__exception_details)(value__))

Ok(EvaluateResponse(
result:result,
exception_details:exception_details,
))}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `get_properties`
pub type GetPropertiesResponse{
GetPropertiesResponse (

/// Object properties.  
result: List(PropertyDescriptor),

/// Internal object properties (only of the element itself).  
internal_properties: option.Option(List(InternalPropertyDescriptor)),

/// Exception details.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__get_properties_response(
value__: dynamic.Dynamic) {
use result <- result.try(dynamic.field("result",dynamic.list(decode__property_descriptor))(value__))
use internal_properties <- result.try(dynamic.optional_field("internalProperties",dynamic.list(decode__internal_property_descriptor))(value__))
use exception_details <- result.try(dynamic.optional_field("exceptionDetails",decode__exception_details)(value__))

Ok(GetPropertiesResponse(
result:result,
internal_properties:internal_properties,
exception_details:exception_details,
))}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `global_lexical_scope_names`
pub type GlobalLexicalScopeNamesResponse{
GlobalLexicalScopeNamesResponse (
names: List(String),
)
}


@internal
pub fn decode__global_lexical_scope_names_response(
value__: dynamic.Dynamic) {
use names <- result.try(dynamic.field("names",dynamic.list(dynamic.string))(value__))

Ok(GlobalLexicalScopeNamesResponse(
names:names,
))}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `query_objects`
pub type QueryObjectsResponse{
QueryObjectsResponse (

/// Array with objects.  
objects: RemoteObject,
)
}


@internal
pub fn decode__query_objects_response(
value__: dynamic.Dynamic) {
use objects <- result.try(dynamic.field("objects",decode__remote_object)(value__))

Ok(QueryObjectsResponse(
objects:objects,
))}
/// This type is not part of the protocol spec, it has been generated dynamically
/// to represent the response to the command `run_script`
pub type RunScriptResponse{
RunScriptResponse (

/// Run result.  
result: RemoteObject,

/// Exception details.  
exception_details: option.Option(ExceptionDetails),
)
}


@internal
pub fn decode__run_script_response(
value__: dynamic.Dynamic) {
use result <- result.try(dynamic.field("result",decode__remote_object)(value__))
use exception_details <- result.try(dynamic.optional_field("exceptionDetails",decode__exception_details)(value__))

Ok(RunScriptResponse(
result:result,
exception_details:exception_details,
))}
/// Add handler to promise with given promise object id.
/// 
/// Parameters:  
///  - `promise_object_id` : Identifier of the promise.
///  - `return_by_value` : Whether the result is expected to be a JSON object that should be sent by value.
///  - `generate_preview` : Whether preview should be generated for the result.
/// 
/// Returns:  
///  - `result` : Promise result. Will contain rejected value if promise was rejected.
///  - `exception_details` : Exception details if stack strace is available.
/// 
pub fn await_promise(
callback__, 
promise_object_id promise_object_id: RemoteObjectId,
return_by_value return_by_value: option.Option(Bool),
generate_preview generate_preview: option.Option(Bool),
){
use result__ <- result.try(callback__("Runtime.awaitPromise", option.Some(json.object([#("promiseObjectId", encode__remote_object_id(promise_object_id)),
]|> utils.add_optional(return_by_value, fn(inner_value__){#("returnByValue", json.bool(inner_value__))})
|> utils.add_optional(generate_preview, fn(inner_value__){#("generatePreview", json.bool(inner_value__))})
)))
)

decode__await_promise_response(result__)
|> result.replace_error(chrome.ProtocolError)

}

/// Calls function with given declaration on the given object. Object group of the result is
/// inherited from the target object.
/// 
/// Parameters:  
///  - `function_declaration` : Declaration of the function to call.
///  - `object_id` : Identifier of the object to call function on. Either objectId or executionContextId should
/// be specified.
///  - `arguments` : Call arguments. All call arguments must belong to the same JavaScript world as the target
/// object.
///  - `silent` : In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
///  - `return_by_value` : Whether the result is expected to be a JSON object which should be sent by value.
/// Can be overriden by `serializationOptions`.
///  - `user_gesture` : Whether execution should be treated as initiated by user in the UI.
///  - `await_promise` : Whether execution should `await` for resulting value and return once awaited promise is
/// resolved.
///  - `execution_context_id` : Specifies execution context which global object will be used to call function on. Either
/// executionContextId or objectId should be specified.
///  - `object_group` : Symbolic group name that can be used to release multiple objects. If objectGroup is not
/// specified and objectId is, objectGroup will be inherited from object.
/// 
/// Returns:  
///  - `result` : Call result.
///  - `exception_details` : Exception details.
/// 
pub fn call_function_on(
callback__, 
function_declaration function_declaration: String,
object_id object_id: option.Option(RemoteObjectId),
arguments arguments: option.Option(List(CallArgument)),
silent silent: option.Option(Bool),
return_by_value return_by_value: option.Option(Bool),
user_gesture user_gesture: option.Option(Bool),
await_promise await_promise: option.Option(Bool),
execution_context_id execution_context_id: option.Option(ExecutionContextId),
object_group object_group: option.Option(String),
){
use result__ <- result.try(callback__("Runtime.callFunctionOn", option.Some(json.object([#("functionDeclaration", json.string(function_declaration)),
]|> utils.add_optional(object_id, fn(inner_value__){#("objectId", encode__remote_object_id(inner_value__))})
|> utils.add_optional(arguments, fn(inner_value__){#("arguments", json.array(inner_value__, of: encode__call_argument))})
|> utils.add_optional(silent, fn(inner_value__){#("silent", json.bool(inner_value__))})
|> utils.add_optional(return_by_value, fn(inner_value__){#("returnByValue", json.bool(inner_value__))})
|> utils.add_optional(user_gesture, fn(inner_value__){#("userGesture", json.bool(inner_value__))})
|> utils.add_optional(await_promise, fn(inner_value__){#("awaitPromise", json.bool(inner_value__))})
|> utils.add_optional(execution_context_id, fn(inner_value__){#("executionContextId", encode__execution_context_id(inner_value__))})
|> utils.add_optional(object_group, fn(inner_value__){#("objectGroup", json.string(inner_value__))})
)))
)

decode__call_function_on_response(result__)
|> result.replace_error(chrome.ProtocolError)

}

/// Compiles expression.
/// 
/// Parameters:  
///  - `expression` : Expression to compile.
///  - `source_url` : Source url to be set for the script.
///  - `persist_script` : Specifies whether the compiled script should be persisted.
///  - `execution_context_id` : Specifies in which execution context to perform script run. If the parameter is omitted the
/// evaluation will be performed in the context of the inspected page.
/// 
/// Returns:  
///  - `script_id` : Id of the script.
///  - `exception_details` : Exception details.
/// 
pub fn compile_script(
callback__, 
expression expression: String,
source_url source_url: String,
persist_script persist_script: Bool,
execution_context_id execution_context_id: option.Option(ExecutionContextId),
){
use result__ <- result.try(callback__("Runtime.compileScript", option.Some(json.object([#("expression", json.string(expression)),
#("sourceURL", json.string(source_url)),
#("persistScript", json.bool(persist_script)),
]|> utils.add_optional(execution_context_id, fn(inner_value__){#("executionContextId", encode__execution_context_id(inner_value__))})
)))
)

decode__compile_script_response(result__)
|> result.replace_error(chrome.ProtocolError)

}

/// Disables reporting of execution contexts creation.
/// 
pub fn disable(
callback__, 
){
callback__("Runtime.disable", option.None,)


}

/// Discards collected exceptions and console API calls.
/// 
pub fn discard_console_entries(
callback__, 
){
callback__("Runtime.discardConsoleEntries", option.None,)


}

/// Enables reporting of execution contexts creation by means of `executionContextCreated` event.
/// When the reporting gets enabled the event will be sent immediately for each existing execution
/// context.
/// 
pub fn enable(
callback__, 
){
callback__("Runtime.enable", option.None,)


}

/// Evaluates expression on global object.
/// 
/// Parameters:  
///  - `expression` : Expression to evaluate.
///  - `object_group` : Symbolic group name that can be used to release multiple objects.
///  - `include_command_line_api` : Determines whether Command Line API should be available during the evaluation.
///  - `silent` : In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
///  - `context_id` : Specifies in which execution context to perform evaluation. If the parameter is omitted the
/// evaluation will be performed in the context of the inspected page.
/// This is mutually exclusive with `uniqueContextId`, which offers an
/// alternative way to identify the execution context that is more reliable
/// in a multi-process environment.
///  - `return_by_value` : Whether the result is expected to be a JSON object that should be sent by value.
///  - `user_gesture` : Whether execution should be treated as initiated by user in the UI.
///  - `await_promise` : Whether execution should `await` for resulting value and return once awaited promise is
/// resolved.
/// 
/// Returns:  
///  - `result` : Evaluation result.
///  - `exception_details` : Exception details.
/// 
pub fn evaluate(
callback__, 
expression expression: String,
object_group object_group: option.Option(String),
include_command_line_api include_command_line_api: option.Option(Bool),
silent silent: option.Option(Bool),
context_id context_id: option.Option(ExecutionContextId),
return_by_value return_by_value: option.Option(Bool),
user_gesture user_gesture: option.Option(Bool),
await_promise await_promise: option.Option(Bool),
){
use result__ <- result.try(callback__("Runtime.evaluate", option.Some(json.object([#("expression", json.string(expression)),
]|> utils.add_optional(object_group, fn(inner_value__){#("objectGroup", json.string(inner_value__))})
|> utils.add_optional(include_command_line_api, fn(inner_value__){#("includeCommandLineAPI", json.bool(inner_value__))})
|> utils.add_optional(silent, fn(inner_value__){#("silent", json.bool(inner_value__))})
|> utils.add_optional(context_id, fn(inner_value__){#("contextId", encode__execution_context_id(inner_value__))})
|> utils.add_optional(return_by_value, fn(inner_value__){#("returnByValue", json.bool(inner_value__))})
|> utils.add_optional(user_gesture, fn(inner_value__){#("userGesture", json.bool(inner_value__))})
|> utils.add_optional(await_promise, fn(inner_value__){#("awaitPromise", json.bool(inner_value__))})
)))
)

decode__evaluate_response(result__)
|> result.replace_error(chrome.ProtocolError)

}

/// Returns properties of a given object. Object group of the result is inherited from the target
/// object.
/// 
/// Parameters:  
///  - `object_id` : Identifier of the object to return properties for.
///  - `own_properties` : If true, returns properties belonging only to the element itself, not to its prototype
/// chain.
/// 
/// Returns:  
///  - `result` : Object properties.
///  - `internal_properties` : Internal object properties (only of the element itself).
///  - `exception_details` : Exception details.
/// 
pub fn get_properties(
callback__, 
object_id object_id: RemoteObjectId,
own_properties own_properties: option.Option(Bool),
){
use result__ <- result.try(callback__("Runtime.getProperties", option.Some(json.object([#("objectId", encode__remote_object_id(object_id)),
]|> utils.add_optional(own_properties, fn(inner_value__){#("ownProperties", json.bool(inner_value__))})
)))
)

decode__get_properties_response(result__)
|> result.replace_error(chrome.ProtocolError)

}

/// Returns all let, const and class variables from global scope.
/// 
/// Parameters:  
///  - `execution_context_id` : Specifies in which execution context to lookup global scope variables.
/// 
/// Returns:  
///  - `names`
/// 
pub fn global_lexical_scope_names(
callback__, 
execution_context_id execution_context_id: option.Option(ExecutionContextId),
){
use result__ <- result.try(callback__("Runtime.globalLexicalScopeNames", option.Some(json.object([]|> utils.add_optional(execution_context_id, fn(inner_value__){#("executionContextId", encode__execution_context_id(inner_value__))})
)))
)

decode__global_lexical_scope_names_response(result__)
|> result.replace_error(chrome.ProtocolError)

}

/// This generated protocol command has no description
/// 
/// Parameters:  
///  - `prototype_object_id` : Identifier of the prototype to return objects for.
///  - `object_group` : Symbolic group name that can be used to release the results.
/// 
/// Returns:  
///  - `objects` : Array with objects.
/// 
pub fn query_objects(
callback__, 
prototype_object_id prototype_object_id: RemoteObjectId,
object_group object_group: option.Option(String),
){
use result__ <- result.try(callback__("Runtime.queryObjects", option.Some(json.object([#("prototypeObjectId", encode__remote_object_id(prototype_object_id)),
]|> utils.add_optional(object_group, fn(inner_value__){#("objectGroup", json.string(inner_value__))})
)))
)

decode__query_objects_response(result__)
|> result.replace_error(chrome.ProtocolError)

}

/// Releases remote object with given id.
/// 
/// Parameters:  
///  - `object_id` : Identifier of the object to release.
/// 
/// Returns:  
/// 
pub fn release_object(
callback__, 
object_id object_id: RemoteObjectId,
){
callback__("Runtime.releaseObject", option.Some(json.object([#("objectId", encode__remote_object_id(object_id)),
])))


}

/// Releases all remote objects that belong to a given group.
/// 
/// Parameters:  
///  - `object_group` : Symbolic object group name.
/// 
/// Returns:  
/// 
pub fn release_object_group(
callback__, 
object_group object_group: String,
){
callback__("Runtime.releaseObjectGroup", option.Some(json.object([#("objectGroup", json.string(object_group)),
])))


}

/// Tells inspected instance to run if it was waiting for debugger to attach.
/// 
pub fn run_if_waiting_for_debugger(
callback__, 
){
callback__("Runtime.runIfWaitingForDebugger", option.None,)


}

/// Runs script with given id in a given context.
/// 
/// Parameters:  
///  - `script_id` : Id of the script to run.
///  - `execution_context_id` : Specifies in which execution context to perform script run. If the parameter is omitted the
/// evaluation will be performed in the context of the inspected page.
///  - `object_group` : Symbolic group name that can be used to release multiple objects.
///  - `silent` : In silent mode exceptions thrown during evaluation are not reported and do not pause
/// execution. Overrides `setPauseOnException` state.
///  - `include_command_line_api` : Determines whether Command Line API should be available during the evaluation.
///  - `return_by_value` : Whether the result is expected to be a JSON object which should be sent by value.
///  - `generate_preview` : Whether preview should be generated for the result.
///  - `await_promise` : Whether execution should `await` for resulting value and return once awaited promise is
/// resolved.
/// 
/// Returns:  
///  - `result` : Run result.
///  - `exception_details` : Exception details.
/// 
pub fn run_script(
callback__, 
script_id script_id: ScriptId,
execution_context_id execution_context_id: option.Option(ExecutionContextId),
object_group object_group: option.Option(String),
silent silent: option.Option(Bool),
include_command_line_api include_command_line_api: option.Option(Bool),
return_by_value return_by_value: option.Option(Bool),
generate_preview generate_preview: option.Option(Bool),
await_promise await_promise: option.Option(Bool),
){
use result__ <- result.try(callback__("Runtime.runScript", option.Some(json.object([#("scriptId", encode__script_id(script_id)),
]|> utils.add_optional(execution_context_id, fn(inner_value__){#("executionContextId", encode__execution_context_id(inner_value__))})
|> utils.add_optional(object_group, fn(inner_value__){#("objectGroup", json.string(inner_value__))})
|> utils.add_optional(silent, fn(inner_value__){#("silent", json.bool(inner_value__))})
|> utils.add_optional(include_command_line_api, fn(inner_value__){#("includeCommandLineAPI", json.bool(inner_value__))})
|> utils.add_optional(return_by_value, fn(inner_value__){#("returnByValue", json.bool(inner_value__))})
|> utils.add_optional(generate_preview, fn(inner_value__){#("generatePreview", json.bool(inner_value__))})
|> utils.add_optional(await_promise, fn(inner_value__){#("awaitPromise", json.bool(inner_value__))})
)))
)

decode__run_script_response(result__)
|> result.replace_error(chrome.ProtocolError)

}

/// Enables or disables async call stacks tracking.
/// 
/// Parameters:  
///  - `max_depth` : Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
/// call stacks (default).
/// 
/// Returns:  
/// 
pub fn set_async_call_stack_depth(
callback__, 
max_depth max_depth: Int,
){
callback__("Runtime.setAsyncCallStackDepth", option.Some(json.object([#("maxDepth", json.int(max_depth)),
])))


}

/// If executionContextId is empty, adds binding with the given name on the
/// global objects of all inspected contexts, including those created later,
/// bindings survive reloads.
/// Binding function takes exactly one argument, this argument should be string,
/// in case of any other input, function throws an exception.
/// Each binding function call produces Runtime.bindingCalled notification.
/// 
/// Parameters:  
///  - `name`
///  - `execution_context_name` : If specified, the binding is exposed to the executionContext with
/// matching name, even for contexts created after the binding is added.
/// See also `ExecutionContext.name` and `worldName` parameter to
/// `Page.addScriptToEvaluateOnNewDocument`.
/// This parameter is mutually exclusive with `executionContextId`.
/// 
/// Returns:  
/// 
pub fn add_binding(
callback__, 
name name: String,
execution_context_name execution_context_name: option.Option(String),
){
callback__("Runtime.addBinding", option.Some(json.object([#("name", json.string(name)),
]|> utils.add_optional(execution_context_name, fn(inner_value__){#("executionContextName", json.string(inner_value__))})
)))


}

/// This method does not remove binding function from global object but
/// unsubscribes current runtime agent from Runtime.bindingCalled notifications.
/// 
/// Parameters:  
///  - `name`
/// 
/// Returns:  
/// 
pub fn remove_binding(
callback__, 
name name: String,
){
callback__("Runtime.removeBinding", option.Some(json.object([#("name", json.string(name)),
])))


}

